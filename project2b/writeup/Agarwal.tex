\documentclass[11pt, oneside]{article}  
\usepackage{geometry}                		
\geometry{letterpaper}                   		
\usepackage{graphicx}				
\usepackage{amssymb}

\title{Project 2B}
\author{Abhi Agarwal}
\date{}

\begin{document}
\maketitle
\section*{Notes}
\par I have divided this section into how I have ordered my program. I have broken this down into each subsection that is defined on the paper.
\par I have not completed this very successfully. My program was running a while ago, but I could not test it without getting the environment variables setup properly. Here in this particular implementation I have not successfully managed to implement most of the things on the sheet. I have managed to setup Maps, a couple schemes for types, and some basic error checking for a couple Literals and Expressions. 
\par I could not figure out how to do Object Literals, view synthesized attributes, among other things in HACS. 
\par I spent a large portion of my time throughout the last couple weeks to try and figure out most of these things, but as I understood some of the things more I kept on recharging a lot of the other things, and so this particular implementation is my 3-4th implementation. 
\begin{enumerate}
\item[1.2] Types were already defined in the base that was given to us by the professor, and I have not made any changes to them.
\item[1.3.1] I have defined Defined, Lookup, and Extend under the Type sort. Firstly, I defined the Name sort, which has a symbol for an Identifier. This symbol allows Name to be used as a key in a map. Next I defined a Map sort that contains a Map, which basically allows us to recursively define a key-value pair. This particular definition will allow us to do the $k$ to value $v$ mappings.
\item[1.3.2] Each map should have these auxiliary operations. To solve the problem of having many maps I made a Maps sort, which works as a list. The list contains a single key-value map, and the Maps sort defines MoreMaps, and NoMaps. MoreMaps basically allows to traverse through the Map list, and NoMaps alerts us when we reach the end of the Map.
\item[1.3.3] Defined is implemented by returning either a True or a False if that value exists. It never throws an error.
\item[1.3.4] Lookup is implemented by returning either a True if it exists or a TypeError if it isn't. TypeError is the standard error notation I will be using throughout this program.
\item[1.3.5] Extend is implemented by taking a key-value pair, appending it to the list, and then returning the new list. It uses the MoreMaps part of Maps to take in a Map, and the rest of the list and returns the new list.
\item[1.4] The key-value pair for each Map sort is a mapping from Name to TD, which is a sort to allow us to set up a descriptor list. TD definition is in section 1.5.
\item[1.5] I had a slight issue of not understanding how to implement this. I thought I doing the correct thing until I completed the Program section, and then realized that this section was not working well. My initial implementation was to parse the Type, and Argument Signature for the function and Members for the class. Then if neither of these were valid then TypeError. I wasn't too sure how to use the keyword Call, and Class here. 
\item[1.11.4] LValue(E, id) should be the case here rather than the one defined in the documentation given by the professor. For a given environment 

\section{Extras}
\item There is no need for Unif - we don't have floating types, and we only have integer types. To make sure they are both integers we can use the SameType scheme inside the Boolean sort.
\item Other functions I implemented under the Boolean sort were SingleIntType, SingleBooleanType, SameNoVoid, IntType, BooleanType, StingIntType, IsIdentifier, and IsAny.

\end{enumerate}

\end{document}  