/* org.crsx.hacs.HxRaw: PG-generated JavaCC parser specification. */

options {
	SANITY_CHECK  = true;
	BUILD_PARSER = true;
	JDK_VERSION = "1.5";
	ERROR_REPORTING = true;
	DEBUG_PARSER = true;
	BUILD_TOKEN_MANAGER = true;
	FORCE_LA_CHECK = true;
	STATIC = false;
}

PARSER_BEGIN(HxRaw)
package org.crsx.hacs;

public class HxRaw implements net.sf.crsx.Parser
{
	/** Factory. */
	net.sf.crsx.Factory<? extends net.sf.crsx.Term> factory;
	/** Compilation unit name for error messages. */
	String unit;
	/** Whether the parser should capture token locations. */
	boolean captureLocations = true;
	/** Constructor with token location information. */
	private net.sf.crsx.Constructor makeTConstructor(net.sf.crsx.Sink sink, Token t, Object object, String sort)
	{
		net.sf.crsx.Constructor c = sort == null ? sink.makeConstructor(object) : sink.makeLiteral(object, sort);
		if (t == null) t = token;
		if (captureLocations && t != null)
		{
			if (factory.get("meta") == null)
				c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn);
		}
		return c;
	}

	/** Helper interface with category non-terminal calls. */
	abstract class CategoryCall { abstract net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException; }
	/** Direct category invocations. */
	java.util.Map<String,CategoryCall> categoryCall = new java.util.HashMap<String,CategoryCall>();
	{
		categoryCall.put("raw", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxModule$WithEOF(sink, bound);} });
		categoryCall.put("rawHxModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxModule$WithEOF(sink, bound);} });
		categoryCall.put("rawHxModuleName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxModuleName$WithEOF(sink, bound);} });
		categoryCall.put("rawHxEmbeddedModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxEmbeddedModule$WithEOF(sink, bound);} });
		categoryCall.put("rawHxDeclaration", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxDeclaration$WithEOF(sink, bound);} });
		categoryCall.put("rawHxDeclarations", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxDeclarations$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSortAbstraction", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortAbstraction$WithEOF(sink, bound);} });
		categoryCall.put("rawHxMainKind", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxMainKind$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRule$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRulePrefix", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRulePrefix$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRulePriority", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRulePriority$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRuleOptions", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRuleOptions$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSort$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSortParam", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortParam$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSortNames", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortNames$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSimpleSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSimpleSort$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSimpleSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSimpleSorts$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSubstituteSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSubstituteSorts$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSubstituteSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSubstituteSort$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSortAlternative", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortAlternative$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSortAlternatives", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortAlternatives$WithEOF(sink, bound);} });
		categoryCall.put("rawHxForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxForm$WithEOF(sink, bound);} });
		categoryCall.put("rawHxFormPrec", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxFormPrec$WithEOF(sink, bound);} });
		categoryCall.put("rawHxParsedForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxParsedForm$WithEOF(sink, bound);} });
		categoryCall.put("rawHxInheritedRefs", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxInheritedRefs$WithEOF(sink, bound);} });
		categoryCall.put("rawHxInheritedRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxInheritedRef$WithEOF(sink, bound);} });
		categoryCall.put("rawHxAttributeKind", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributeKind$WithEOF(sink, bound);} });
		categoryCall.put("rawHxAttributeForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributeForm$WithEOF(sink, bound);} });
		categoryCall.put("rawHxBindersScopeSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxBindersScopeSorts$WithEOF(sink, bound);} });
		categoryCall.put("rawHxBindersScopeSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxBindersScopeSort$WithEOF(sink, bound);} });
		categoryCall.put("rawHxScopeSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxScopeSort$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRepeat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRepeat$WithEOF(sink, bound);} });
		categoryCall.put("rawHxTokenName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTokenName$WithEOF(sink, bound);} });
		categoryCall.put("rawHxFragmentRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxFragmentRef$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRegExp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExp$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRegExpChoice", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpChoice$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRegExpUnits", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpUnits$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRegExpUnit", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpUnit$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRegExpSimple", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpSimple$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRegExpSub", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpSub$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSeparator", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSeparator$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRegExpWord", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpWord$WithEOF(sink, bound);} });
		categoryCall.put("rawHxLiteral", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxLiteral$WithEOF(sink, bound);} });
		categoryCall.put("rawHxMetaVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxMetaVariable$WithEOF(sink, bound);} });
		categoryCall.put("rawHxMetaVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxMetaVariables$WithEOF(sink, bound);} });
		categoryCall.put("rawHxVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxVariable$WithEOF(sink, bound);} });
		categoryCall.put("rawHxAttributeName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributeName$WithEOF(sink, bound);} });
		categoryCall.put("rawHxRegExpClass", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpClass$WithEOF(sink, bound);} });
		categoryCall.put("rawHxCC", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC$WithEOF(sink, bound);} });
		categoryCall.put("rawHxCC_RangesTop", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_RangesTop$WithEOF(sink, bound);} });
		categoryCall.put("rawHxCC_Ranges", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_Ranges$WithEOF(sink, bound);} });
		categoryCall.put("rawHxCC_FirstRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_FirstRangeStartChar$WithEOF(sink, bound);} });
		categoryCall.put("rawHxCC_NonDashRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_NonDashRangeStartChar$WithEOF(sink, bound);} });
		categoryCall.put("rawHxCC_RangeChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_RangeChar$WithEOF(sink, bound);} });
		categoryCall.put("rawHxPP", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPP$WithEOF(sink, bound);} });
		categoryCall.put("rawHxPPConcreteSpace", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPPConcreteSpace$WithEOF(sink, bound);} });
		categoryCall.put("rawHxPPConcreteSpace", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPPConcreteSpace$WithEOF(sink, bound);} });
		categoryCall.put("rawHxPPConcreteWord", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPPConcreteWord$WithEOF(sink, bound);} });
		categoryCall.put("rawHxPPUnconcrete", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPPUnconcrete$WithEOF(sink, bound);} });
		categoryCall.put("rawHxScopeSortPrec", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxScopeSortPrec$WithEOF(sink, bound);} });
		categoryCall.put("rawHxTopTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTopTerm$WithEOF(sink, bound);} });
		categoryCall.put("rawHxTopPattern", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTopPattern$WithEOF(sink, bound);} });
		categoryCall.put("rawHxAttributes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributes$WithEOF(sink, bound);} });
		categoryCall.put("rawHxSortName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortName$WithEOF(sink, bound);} });
		categoryCall.put("rawHxConstructor", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxConstructor$WithEOF(sink, bound);} });
		categoryCall.put("rawHxTerms", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTerms$WithEOF(sink, bound);} });
		categoryCall.put("rawHxTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTerm$WithEOF(sink, bound);} });
		categoryCall.put("rawHxVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxVariables$WithEOF(sink, bound);} });
		categoryCall.put("rawHxAttribute", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttribute$WithEOF(sink, bound);} });
		categoryCall.put("rawHxAttributeValue", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributeValue$WithEOF(sink, bound);} });
		categoryCall.put("rawHxScopes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxScopes$WithEOF(sink, bound);} });
		categoryCall.put("rawHxScope", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxScope$WithEOF(sink, bound);} });
		categoryCall.put("rawHxConcrete", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxConcrete$WithEOF(sink, bound);} });
		categoryCall.put("rawHxConcreteText", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxConcreteText$WithEOF(sink, bound);} });
	}

	// Constructor.

	/** Construct dummy instance. */
	public HxRaw()
	{
		this((java.io.Reader) null);
		disable_tracing();
	}

	// Parser implementation.

	public net.sf.crsx.Parser parser(net.sf.crsx.Factory<? extends net.sf.crsx.Term> f)
	{
		if (factory != null)
		{
			net.sf.crsx.Parser parser = new HxRaw().parser(f);
			parser.setParserVerbose(trace_enabled); parser.setParserLocation(captureLocations);
			return parser;
		}
		else
		{
			factory = f;
			assert f != null : "Or Else!";
			return this;
		}
	}

	public void setParserVerbose(boolean verbose)
	{
		if (verbose)
			enable_tracing();
		else
			disable_tracing();
	}

	public void setParserLocation(boolean capture)
	{
		captureLocations = capture;
	}

	public void setEmbeddedParser(net.sf.crsx.Parser subparser) throws net.sf.crsx.CRSException
	{}

	public Iterable<String> categories()
	{
		return categoryCall.keySet();
	}

	public net.sf.crsx.Sink parse(net.sf.crsx.Sink sink, String category, java.io.Reader reader, String unit, int firstLine, int firstColumn, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
	{
		try
		{
			this.unit = unit;
			ReInit((java.io.Reader) null);
			jj_input_stream.ReInit(reader, firstLine, firstColumn); token_source = new HxRawTokenManager(jj_input_stream); // hacks to update line and column numbers
			if (bound == null) bound = new net.sf.crsx.util.LinkedExtensibleMap<String, net.sf.crsx.Variable>();
			if (category == null || category.length() == 0) return N_HxModule(sink, bound);
			else if (categoryCall.containsKey(category)) return categoryCall.get(category).call(sink, bound);
			else throw new net.sf.crsx.CRSException("Parser category '"+category+"' not supported!");
		}
		catch (ParseException e)
		{
			throw new net.sf.crsx.CRSException(e.getMessage());
		}
	}

	public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
	{
		net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
		parse(buffer.sink(), category, reader, null, 1, 1, bound);
		return buffer.term(true);
	}


static String hx(String s) {return "Hx_"+s;} // prefix for constructors
static String unwrap(String s) {return s.substring(1, s.length()-1);}
static String checkModuleString(String s) throws ParseException {if (java.util.regex.Pattern.matches("[\"]([a-z0-9]+[.])*[A-Z][A-Za-z0-9]*[\"]", s)) return s; else throw new ParseException("Illegal module name "+s);}
private String storedSort = "";

	/**
	 * Run the parser and print the resulting term.
	 * @param args should contain two strings: the category and an input file name
	 */
	public static void main(String[] args)
	{
		try
		{
			if (args.length != 2)
			{
				System.err.println("Usage: HxRaw category input");
				System.exit(2);
			}
			String category = args[0];
			java.io.Reader reader = new java.io.FileReader(args[1]);
			net.sf.crsx.Factory<net.sf.crsx.generic.GenericTerm> factory = new net.sf.crsx.generic.GenericFactory();
			net.sf.crsx.Parser parser = new HxRaw();
			net.sf.crsx.Sink sink = factory.sink(System.out);
			parser.parser(factory).parse(sink, category, reader, null, 1, 1, null);
		}
		catch (net.sf.crsx.CRSException e)
		{
			System.err.println("CRS error: "+e);
			System.exit(1);
		}
		catch (java.io.IOException e)
		{
			System.err.println("I/O error: "+e);
			System.exit(1);
		}
	}

}
PARSER_END(HxRaw)

/**
 * <em>HxEmbedded</em> ::=   <a href="#T_HX_EMBEDDED">HX_EMBEDDED</a><font color="red">$$:unwrap</font> 
 */
net.sf.crsx.Sink N_HxEmbedded(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	 ( 
	t=<T_HX_EMBEDDED>
	{
		try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

/** <em>HxModule$WithEOF</em> ::= <em>HxModule</em> EOF . */
net.sf.crsx.Sink N_HxModule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxModule(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxModule production. */
TOKEN : {<MT_HxModule : "#HxModule" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxModule production. */
TOKEN : {<IT_HxModule : "%HxModule">}

/**
 * <em>HxModule</em> ::=  <font color="red">{top-module}</font><font color="red">:hx</font>   <a href="#N_HxEmbeddedModule">&lang;HxEmbeddedModule&rang;</a>  
 */
net.sf.crsx.Sink N_HxModule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxModule> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxModule>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("top-module"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxEmbeddedModule(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxEmbeddedModule$WithEOF</em> ::= <em>HxEmbeddedModule</em> EOF . */
net.sf.crsx.Sink N_HxEmbeddedModule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxEmbeddedModule(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxEmbeddedModule production. */
TOKEN : {<MT_HxEmbeddedModule : "#HxEmbeddedModule" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxEmbeddedModule production. */
TOKEN : {<IT_HxEmbeddedModule : "%HxEmbeddedModule">}

/**
 * <em>HxEmbeddedModule</em> ::=   <a href="#T_HX_MODULE">HX_MODULE</a><font color="red">:hx</font>   <a href="#N_HxModuleName">&lang;HxModuleName&rang;</a>     <a href="#T_HX_LBRACE">HX_LBRACE</a>   <a href="#N_Restoring_HxDeclarations">&lang;Restoring_HxDeclarations&rang;</a>     <a href="#T_HX_RBRACE">HX_RBRACE</a> 
 */
net.sf.crsx.Sink N_HxEmbeddedModule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxEmbeddedModule> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxEmbeddedModule>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_MODULE>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxModuleName(sink, env)
	 ) 
	 ( 
	 <T_HX_LBRACE>
	 ) 
	 ( 
	sink=N_Restoring_HxDeclarations(sink, env)
	 ) 
	 ( 
	 <T_HX_RBRACE>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxDeclarations$WithEOF</em> ::= <em>HxDeclarations</em> EOF . */
net.sf.crsx.Sink N_HxDeclarations$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxDeclarations(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxDeclarations production. */
TOKEN : {<MT_HxDeclarations : "#HxDeclarations" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxDeclarations production. */
TOKEN : {<IT_HxDeclarations : "%HxDeclarations">}

/**
 * <em>HxDeclarations</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_HxDeclaration">&lang;HxDeclaration&rang;</a>    <a href="#N_HxDeclarations">&lang;HxDeclarations&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxDeclarations(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxDeclarations> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxDeclarations>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		sink=N_HxDeclaration(sink, env)
		 ) 
		 ( 
		sink=N_HxDeclarations(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxDeclaration$WithEOF</em> ::= <em>HxDeclaration</em> EOF . */
net.sf.crsx.Sink N_HxDeclaration$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxDeclaration(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxDeclaration production. */
TOKEN : {<MT_HxDeclaration : "#HxDeclaration" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxDeclaration production. */
TOKEN : {<IT_HxDeclaration : "%HxDeclaration">}

/**
 * <em>HxDeclaration</em> ::=  <font color="red">{embedded-module}</font><font color="red">:hx</font>   <a href="#N_HxEmbeddedModule">&lang;HxEmbeddedModule&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_IMPORT">HX_IMPORT</a><font color="red">:hx</font>   <a href="#N_HxModuleName">&lang;HxModuleName&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_SPACE">HX_SPACE</a><font color="red">:hx</font>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_TOKEN">HX_TOKEN</a>   (  <font color="red">{'token'}</font><font color="red">:hx</font>   <a href="#N_HxTokenName">&lang;HxTokenName&rang;</a>     <a href="#T_HX_BAR">HX_BAR</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>   |   <a href="#T_HX_FRAGMENT">HX_FRAGMENT</a><font color="red">:hx</font>   <a href="#N_HxTokenName">&lang;HxTokenName&rang;</a>     <a href="#T_HX_BAR">HX_BAR</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>   )    <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_FRAGMENT">HX_FRAGMENT</a><font color="red">:hx</font>   <a href="#N_HxTokenName">&lang;HxTokenName&rang;</a>     <a href="#T_HX_BAR">HX_BAR</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_ATTRIBUTE">HX_ATTRIBUTE</a><font color="red">:hx</font>   <a href="#N_HxAttributeKind">&lang;HxAttributeKind&rang;</a>    <a href="#N_HxAttributeName">&lang;HxAttributeName&rang;</a>    <a href="#N_HxAttributeForm">&lang;HxAttributeForm&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |  <font color="red">{sort}</font><font color="red">:hx</font>   <a href="#N_HxMainKind">&lang;HxMainKind&rang;</a>     <a href="#T_HX_SORT">HX_SORT</a>   <a href="#N_Store_HxSortName">&lang;Store_HxSortName&rang;</a>    <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a>    <a href="#N_HxSortAbstraction">&lang;HxSortAbstraction&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |  <font color="red">{anonymous}</font><font color="red">:hx</font>   <a href="#N_HxSortAlternatives">&lang;HxSortAlternatives&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |  (   <a href="#T_HX_RULE">HX_RULE</a>  )?   <font color="red">{rule}</font><font color="red">:hx</font>   <a href="#N_HxRule">&lang;HxRule&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |  <font color="red">{nestedDeclarations}</font><font color="red">:hx</font>    <a href="#T_HX_LBRACE">HX_LBRACE</a>   <a href="#N_HxDeclarations">&lang;HxDeclarations&rang;</a>     <a href="#T_HX_RBRACE">HX_RBRACE</a> 
 */
net.sf.crsx.Sink N_HxDeclaration(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxDeclaration> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxDeclaration>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("embedded-module"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxEmbeddedModule(sink, env)
	 ) 
	 ( 
	 <T_HX_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_HX_IMPORT>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxModuleName(sink, env)
	 ) 
	 ( 
	 <T_HX_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_HX_SPACE>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRegExp(sink, env)
	 ) 
	 ( 
	 <T_HX_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_HX_TOKEN>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("token"), null)) ;
		}
		 ) 
		 ( 
		sink=N_HxTokenName(sink, env)
		 ) 
		 ( 
		 <T_HX_BAR>
		 ) 
		 ( 
		sink=N_HxRegExp(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_FRAGMENT>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_HxTokenName(sink, env)
		 ) 
		 ( 
		 <T_HX_BAR>
		 ) 
		 ( 
		sink=N_HxRegExp(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	 <T_HX_SEMI>
	 ) 
	{return sink;}
 |
	 ( 
	t=<T_HX_FRAGMENT>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxTokenName(sink, env)
	 ) 
	 ( 
	 <T_HX_BAR>
	 ) 
	 ( 
	sink=N_HxRegExp(sink, env)
	 ) 
	 ( 
	 <T_HX_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	t=<T_HX_ATTRIBUTE>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxAttributeKind(sink, env)
	 ) 
	 ( 
	sink=N_HxAttributeName(sink, env)
	 ) 
	 ( 
	sink=N_HxAttributeForm(sink, env)
	 ) 
	 ( 
	 <T_HX_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("sort"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxMainKind(sink, env)
	 ) 
	 ( 
	 <T_HX_SORT>
	 ) 
	 ( 
	sink=N_Store_HxSortName(sink, env)
	 ) 
	 ( 
	sink=N_HxRepeat(sink, env)
	 ) 
	 ( 
	sink=N_HxSortAbstraction(sink, env)
	 ) 
	 ( 
	 <T_HX_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("anonymous"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSortAlternatives(sink, env)
	 ) 
	 ( 
	 <T_HX_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
		 ( 
		 <T_HX_RULE>
		 ) 
	 )? 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("rule"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRule(sink, env)
	 ) 
	 ( 
	 <T_HX_SEMI>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("nestedDeclarations"), null)) ;
	}
	 ) 
	 ( 
	 <T_HX_LBRACE>
	 ) 
	 ( 
	sink=N_HxDeclarations(sink, env)
	 ) 
	 ( 
	 <T_HX_RBRACE>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxMainKind$WithEOF</em> ::= <em>HxMainKind</em> EOF . */
net.sf.crsx.Sink N_HxMainKind$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxMainKind(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxMainKind production. */
TOKEN : {<MT_HxMainKind : "#HxMainKind" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxMainKind production. */
TOKEN : {<IT_HxMainKind : "%HxMainKind">}

/**
 * <em>HxMainKind</em> ::=  (   <a href="#T_HX_MAIN">HX_MAIN</a><font color="red">:hx</font>  |  <font color="red">{no-main}</font><font color="red">:hx</font>  ) 
 */
net.sf.crsx.Sink N_HxMainKind(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxMainKind> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxMainKind>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		t=<T_HX_MAIN>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("no-main"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxAttributeKind$WithEOF</em> ::= <em>HxAttributeKind</em> EOF . */
net.sf.crsx.Sink N_HxAttributeKind$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxAttributeKind(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxAttributeKind production. */
TOKEN : {<MT_HxAttributeKind : "#HxAttributeKind" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxAttributeKind production. */
TOKEN : {<IT_HxAttributeKind : "%HxAttributeKind">}

/**
 * <em>HxAttributeKind</em> ::=  (  <font color="red">{AttributeKindUp}</font><font color="red">:hx</font>    <a href="#T_HX_UP">HX_UP</a>  |  <font color="red">{AttributeKindDown}</font><font color="red">:hx</font>    <a href="#T_HX_DOWN">HX_DOWN</a>  ) 
 */
net.sf.crsx.Sink N_HxAttributeKind(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxAttributeKind> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxAttributeKind>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeKindUp"), null)) ;
		}
		 ) 
		 ( 
		 <T_HX_UP>
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeKindDown"), null)) ;
		}
		 ) 
		 ( 
		 <T_HX_DOWN>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxRegExp$WithEOF</em> ::= <em>HxRegExp</em> EOF . */
net.sf.crsx.Sink N_HxRegExp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_RE);} sink=N_HxRegExp(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRegExp production. */
<HX_RE> TOKEN : {<MT_HxRegExp : "#HxRegExp" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRegExp production. */
<HX_RE> TOKEN : {<IT_HxRegExp : "%HxRegExp">}

/**
 * <em>HxRegExp</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxRegExpChoice">&lang;HxRegExpChoice&rang;</a>    (   <a href="#T_HX_BAR">HX_BAR</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxRegExp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRegExp> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRegExp>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRegExpChoice(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_BAR>
		 ) 
		 ( 
		sink=N_HxRegExp(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRegExpChoice$WithEOF</em> ::= <em>HxRegExpChoice</em> EOF . */
net.sf.crsx.Sink N_HxRegExpChoice$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_RE);} sink=N_HxRegExpChoice(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRegExpChoice production. */
<HX_RE> TOKEN : {<MT_HxRegExpChoice : "#HxRegExpChoice" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRegExpChoice production. */
<HX_RE> TOKEN : {<IT_HxRegExpChoice : "%HxRegExpChoice">}

/**
 * <em>HxRegExpChoice</em> ::=   <a href="#T_HX_NESTED">HX_NESTED</a><font color="red">:hx</font>   <a href="#N_HxRegExpSimple">&lang;HxRegExpSimple&rang;</a>    <a href="#N_HxRegExpSimple">&lang;HxRegExpSimple&rang;</a>   <br>
 *  |  <font color="red">{RegExpConcat}</font><font color="red">:hx</font>   <a href="#N_HxRegExpUnits">&lang;HxRegExpUnits&rang;</a>  
 */
net.sf.crsx.Sink N_HxRegExpChoice(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRegExpChoice> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRegExpChoice>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_NESTED>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRegExpSimple(sink, env)
	 ) 
	 ( 
	sink=N_HxRegExpSimple(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpConcat"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRegExpUnits(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRegExpUnits$WithEOF</em> ::= <em>HxRegExpUnits</em> EOF . */
net.sf.crsx.Sink N_HxRegExpUnits$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_RE);} sink=N_HxRegExpUnits(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRegExpUnits production. */
<HX_RE> TOKEN : {<MT_HxRegExpUnits : "#HxRegExpUnits" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRegExpUnits production. */
<HX_RE> TOKEN : {<IT_HxRegExpUnits : "%HxRegExpUnits">}

/**
 * <em>HxRegExpUnits</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxRegExpUnit">&lang;HxRegExpUnit&rang;</a>    <a href="#N_HxRegExpUnits">&lang;HxRegExpUnits&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_HxRegExpUnits(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRegExpUnits> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRegExpUnits>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRegExpUnit(sink, env)
	 ) 
	 ( 
	sink=N_HxRegExpUnits(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRegExpUnit$WithEOF</em> ::= <em>HxRegExpUnit</em> EOF . */
net.sf.crsx.Sink N_HxRegExpUnit$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_RE);} sink=N_HxRegExpUnit(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRegExpUnit production. */
<HX_RE> TOKEN : {<MT_HxRegExpUnit : "#HxRegExpUnit" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRegExpUnit production. */
<HX_RE> TOKEN : {<IT_HxRegExpUnit : "%HxRegExpUnit">}

/**
 * <em>HxRegExpUnit</em> ::=  <font color="red">{RegExpUnit}</font><font color="red">:hx</font>   <a href="#N_HxRegExpSimple">&lang;HxRegExpSimple&rang;</a>    <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a>  
 */
net.sf.crsx.Sink N_HxRegExpUnit(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRegExpUnit> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRegExpUnit>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpUnit"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRegExpSimple(sink, env)
	 ) 
	 ( 
	sink=N_HxRepeat(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRepeat$WithEOF</em> ::= <em>HxRepeat</em> EOF . */
net.sf.crsx.Sink N_HxRepeat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_HxRepeat(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRepeat production. */
<DEFAULT, HX_RE> TOKEN : {<MT_HxRepeat : "#HxRepeat" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRepeat production. */
<DEFAULT, HX_RE> TOKEN : {<IT_HxRepeat : "%HxRepeat">}

/**
 * <em>HxRepeat</em> ::=   <a href="#T_HX_PLUS">HX_PLUS</a>   (  <font color="red">{RepeatSomeSep}</font><font color="red">:hx</font>    <a href="#T_HX_SUB">HX_SUB</a>   <a href="#N_HxRegExpSub">&lang;HxRegExpSub&rang;</a>   |  <font color="red">{RepeatSome}</font><font color="red">:hx</font>  )  <br>
 *  |  <font color="red">{RepeatMaybeSome}</font><font color="red">:hx</font>    <a href="#T_HX_STAR">HX_STAR</a>  <br>
 *  |  <font color="red">{RepeatMaybe}</font><font color="red">:hx</font>    <a href="#T_HX_QUEST">HX_QUEST</a>  <br>
 *  |  <font color="red">{RepeatSingle}</font><font color="red">:hx</font> 
 */
net.sf.crsx.Sink N_HxRepeat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRepeat> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRepeat>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	 <T_HX_PLUS>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RepeatSomeSep"), null)) ;
		}
		 ) 
		 ( 
		 <T_HX_SUB>
		 ) 
		 ( 
		sink=N_HxRegExpSub(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RepeatSome"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RepeatMaybeSome"), null)) ;
	}
	 ) 
	 ( 
	 <T_HX_STAR>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RepeatMaybe"), null)) ;
	}
	 ) 
	 ( 
	 <T_HX_QUEST>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RepeatSingle"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRegExpSimple$WithEOF</em> ::= <em>HxRegExpSimple</em> EOF . */
net.sf.crsx.Sink N_HxRegExpSimple$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_RE);} sink=N_HxRegExpSimple(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRegExpSimple production. */
<HX_RE> TOKEN : {<MT_HxRegExpSimple : "#HxRegExpSimple" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRegExpSimple production. */
<HX_RE> TOKEN : {<IT_HxRegExpSimple : "%HxRegExpSimple">}

/**
 * <em>HxRegExpSimple</em> ::=  <font color="red">{RegExpRef}</font><font color="red">:hx</font>   <a href="#N_HxFragmentRef">&lang;HxFragmentRef&rang;</a>   <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:hx</font>   <a href="#N_HxRegExpClass">&lang;HxRegExpClass&rang;</a>   <br>
 *  |  <font color="red">{RegExpAny}</font><font color="red">:hx</font>    <a href="#T_HX_DOT">HX_DOT</a>  <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:hx</font>   <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   (   <a href="#T_HX_ESCAPEDCHAR">HX_ESCAPEDCHAR</a><font color="red">$</font>  )   <font color="red">{RegExpClassDone}</font><font color="red">:hx</font>  <br>
 *  |  <font color="red">{RegExpNest}</font><font color="red">:hx</font>    <a href="#T_HX_LPAREN">HX_LPAREN</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>     <a href="#T_HX_RPAREN">HX_RPAREN</a>  <br>
 *  |  <font color="red">{RegExpString}</font><font color="red">:hx</font>   <a href="#N_HxString">&lang;HxString&rang;</a>   <br>
 *  |  <font color="red">{RegExpWord}</font><font color="red">:hx</font>   <a href="#N_HxRegExpWord">&lang;HxRegExpWord&rang;</a>  
 */
net.sf.crsx.Sink N_HxRegExpSimple(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRegExpSimple> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRegExpSimple>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpRef"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxFragmentRef(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClass"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRegExpClass(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpAny"), null)) ;
	}
	 ) 
	 ( 
	 <T_HX_DOT>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClass"), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		t=<T_HX_ESCAPEDCHAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
	}
	 ) 
	{
		return sink .end().end().end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpNest"), null)) ;
	}
	 ) 
	 ( 
	 <T_HX_LPAREN>
	 ) 
	 ( 
	sink=N_HxRegExp(sink, env)
	 ) 
	 ( 
	 <T_HX_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpString"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxString(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpWord"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRegExpWord(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRegExpSub$WithEOF</em> ::= <em>HxRegExpSub</em> EOF . */
net.sf.crsx.Sink N_HxRegExpSub$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(DEFAULT);} sink=N_HxRegExpSub(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRegExpSub production. */
<DEFAULT, HX_RE> TOKEN : {<MT_HxRegExpSub : "#HxRegExpSub" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRegExpSub production. */
<DEFAULT, HX_RE> TOKEN : {<IT_HxRegExpSub : "%HxRegExpSub">}

/**
 * <em>HxRegExpSub</em> ::=  <font color="red">{RegExpString}</font><font color="red">:hx</font>   <a href="#N_HxString">&lang;HxString&rang;</a>   <br>
 *  |  <font color="red">{RegExpWord}</font><font color="red">:hx</font>   <a href="#N_HxSeparator">&lang;HxSeparator&rang;</a>  
 */
net.sf.crsx.Sink N_HxRegExpSub(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRegExpSub> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRegExpSub>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpString"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxString(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpWord"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSeparator(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxAttributeForm$WithEOF</em> ::= <em>HxAttributeForm</em> EOF . */
net.sf.crsx.Sink N_HxAttributeForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxAttributeForm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxAttributeForm production. */
TOKEN : {<MT_HxAttributeForm : "#HxAttributeForm" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxAttributeForm production. */
TOKEN : {<IT_HxAttributeForm : "%HxAttributeForm">}

/**
 * <em>HxAttributeForm</em> ::=  <font color="red">{AttributeFormSimple}</font><font color="red">:hx</font>    <a href="#T_HX_LPAREN">HX_LPAREN</a>   <a href="#N_HxSort">&lang;HxSort&rang;</a>     <a href="#T_HX_RPAREN">HX_RPAREN</a>  <br>
 *  |   <a href="#T_HX_LBRACE">HX_LBRACE</a>   <a href="#N_HxSort">&lang;HxSort&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeFormMap}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_HX_COLON">HX_COLON</a>   <a href="#N_HxSort">&lang;HxSort&rang;</a>     <a href="#T_HX_RBRACE">HX_RBRACE</a>  |  <font color="red">{AttributeFormSet}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_HX_RBRACE">HX_RBRACE</a>  ) 
 */
net.sf.crsx.Sink N_HxAttributeForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink bs__ = null;
	net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_HxAttributeForm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxAttributeForm>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("AttributeFormSimple"), null)) ;
	}
	 ) 
	 ( 
	 <T_HX_LPAREN>
	 ) 
	 ( 
	sink=N_HxSort(sink, env)
	 ) 
	 ( 
	 <T_HX_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_HX_LBRACE>
	 ) 
	 ( 
	{
		bs__ = b__.sink();
	}
	N_HxSort(bs__, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeFormMap"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__, true) ;
		}
		 ) 
		 ( 
		 <T_HX_COLON>
		 ) 
		 ( 
		sink=N_HxSort(sink, env)
		 ) 
		 ( 
		 <T_HX_RBRACE>
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeFormSet"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__, true) ;
		}
		 ) 
		 ( 
		 <T_HX_RBRACE>
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxSortNames$WithEOF</em> ::= <em>HxSortNames</em> EOF . */
net.sf.crsx.Sink N_HxSortNames$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSortNames(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSortNames production. */
TOKEN : {<MT_HxSortNames : "#HxSortNames" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSortNames production. */
TOKEN : {<IT_HxSortNames : "%HxSortNames">}

/**
 * <em>HxSortNames</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxSortName">&lang;HxSortName&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxSortNames">&lang;HxSortNames&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxSortNames(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSortNames> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSortNames>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSortName(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_COMMA>
		 ) 
		 ( 
		sink=N_HxSortNames(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxSortAbstraction$WithEOF</em> ::= <em>HxSortAbstraction</em> EOF . */
net.sf.crsx.Sink N_HxSortAbstraction$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSortAbstraction(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSortAbstraction production. */
TOKEN : {<MT_HxSortAbstraction : "#HxSortAbstraction" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSortAbstraction production. */
TOKEN : {<IT_HxSortAbstraction : "%HxSortAbstraction">}

/**
 * <em>HxSortAbstraction</em> ::=  <font color="red">{SortAbstractionParam}</font><font color="red">:hx</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">^a</font>   <a href="#N_HxSortAbstraction">&lang;HxSortAbstraction&rang;</a> <font color="red">[a]</font>  <br>
 *  |  <font color="red">{SortAbstractionBody}</font><font color="red">:hx</font>   <a href="#N_HxSortAlternatives">&lang;HxSortAlternatives&rang;</a>  
 */
net.sf.crsx.Sink N_HxSortAbstraction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	String s_a = null;
	Token t = null;
	net.sf.crsx.Variable v_a = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_a = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs_a = null;
}
{
	t=<MT_HxSortAbstraction> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSortAbstraction>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("SortAbstractionParam"), null)) ;
	}
	 ) 
	 ( 
	{
		bs_a = b_a.sink();
	}
	N_HxVariable(bs_a, env)
	{
		if (b_a.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_a.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_a.term(false)+")");
		c0 = b_a.term(true).constructor().symbol();
		s_a = c0;
		v_a = sink.makeVariable(s_a,true);
	}
	 ) 
	 ( 
	{
		{
			net.sf.crsx.Variable[] bs1 = {v_a};
			sink = sink .binds(bs1) ;
		}
	}
	sink=N_HxSortAbstraction(sink, env.extend(s_a, v_a))
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("SortAbstractionBody"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSortAlternatives(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxSortAlternatives$WithEOF</em> ::= <em>HxSortAlternatives</em> EOF . */
net.sf.crsx.Sink N_HxSortAlternatives$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSortAlternatives(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSortAlternatives production. */
TOKEN : {<MT_HxSortAlternatives : "#HxSortAlternatives" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSortAlternatives production. */
TOKEN : {<IT_HxSortAlternatives : "%HxSortAlternatives">}

/**
 * <em>HxSortAlternatives</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxSortAlternative">&lang;HxSortAlternative&rang;</a>    <a href="#N_HxSortAlternatives">&lang;HxSortAlternatives&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_HxSortAlternatives(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSortAlternatives> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSortAlternatives>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSortAlternative(sink, env)
	 ) 
	 ( 
	sink=N_HxSortAlternatives(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxSortAlternative$WithEOF</em> ::= <em>HxSortAlternative</em> EOF . */
net.sf.crsx.Sink N_HxSortAlternative$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSortAlternative(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSortAlternative production. */
TOKEN : {<MT_HxSortAlternative : "#HxSortAlternative" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSortAlternative production. */
TOKEN : {<IT_HxSortAlternative : "%HxSortAlternative">}

/**
 * <em>HxSortAlternative</em> ::=   <a href="#T_HX_BAR">HX_BAR</a>   (   <a href="#T_HX_SCHEME">HX_SCHEME</a><font color="red">:hx</font>   <a href="#N_HxForm">&lang;HxForm&rang;</a>   |  <font color="red">{SynthesizedRef}</font><font color="red">:hx</font>    <a href="#T_HX_UP">HX_UP</a>   <a href="#N_HxAttributeName">&lang;HxAttributeName&rang;</a>   |   <a href="#T_HX_SUGAR">HX_SUGAR</a><font color="red">:hx</font>   <a href="#N_HxForm">&lang;HxForm&rang;</a>     <a href="#T_HX_ARROW">HX_ARROW</a>   <a href="#N_HxTopTerm">&lang;HxTopTerm&rang;</a>   |   <a href="#T_HX_SYMBOL">HX_SYMBOL</a><font color="red">:hx</font>   <a href="#N_HxForm">&lang;HxForm&rang;</a>   |   <a href="#T_HX_STATIC">HX_STATIC</a><font color="red">:hx</font>   (   <a href="#T_HX_SYMBOL">HX_SYMBOL</a>  )?   <a href="#N_HxForm">&lang;HxForm&rang;</a>   |  <font color="red">{data}</font><font color="red">:hx</font>   (   <a href="#T_HX_DATA">HX_DATA</a>  )?   <a href="#N_HxForm">&lang;HxForm&rang;</a>   ) 
 */
net.sf.crsx.Sink N_HxSortAlternative(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSortAlternative> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSortAlternative>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	 <T_HX_BAR>
	 ) 
	 ( 
		 ( 
		t=<T_HX_SCHEME>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_HxForm(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("SynthesizedRef"), null)) ;
		}
		 ) 
		 ( 
		 <T_HX_UP>
		 ) 
		 ( 
		sink=N_HxAttributeName(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_SUGAR>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_HxForm(sink, env)
		 ) 
		 ( 
		 <T_HX_ARROW>
		 ) 
		 ( 
		sink=N_HxTopTerm(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_SYMBOL>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
		sink=N_HxForm(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_STATIC>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_HX_SYMBOL>
			 ) 
		 )? 
		 ( 
		sink=N_HxForm(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("data"), null)) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_HX_DATA>
			 ) 
		 )? 
		 ( 
		sink=N_HxForm(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxForm$WithEOF</em> ::= <em>HxForm</em> EOF . */
net.sf.crsx.Sink N_HxForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxForm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxForm production. */
TOKEN : {<MT_HxForm : "#HxForm" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxForm production. */
TOKEN : {<IT_HxForm : "%HxForm">}

/**
 * <em>HxForm</em> ::=  <font color="red">{FormParsed}</font><font color="red">:hx</font>   <a href="#N_HxParsedForm">&lang;HxParsedForm&rang;</a>    <a href="#N_HxFormPrec">&lang;HxFormPrec&rang;</a>    <a href="#N_HxInheritedRefs">&lang;HxInheritedRefs&rang;</a>   <br>
 *  |  <font color="red">{FormConstruction}</font><font color="red">:hx</font>   <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a>    (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxBindersScopeSorts">&lang;HxBindersScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxInheritedRefs">&lang;HxInheritedRefs&rang;</a>  
 */
net.sf.crsx.Sink N_HxForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxForm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxForm>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("FormParsed"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxParsedForm(sink, env)
	 ) 
	 ( 
	sink=N_HxFormPrec(sink, env)
	 ) 
	 ( 
	sink=N_HxInheritedRefs(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("FormConstruction"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxConstructor(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_LPAREN>
		 ) 
		 ( 
			 ( 
			sink=N_HxBindersScopeSorts(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_HX_RPAREN>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_HxInheritedRefs(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxBindersScopeSorts$WithEOF</em> ::= <em>HxBindersScopeSorts</em> EOF . */
net.sf.crsx.Sink N_HxBindersScopeSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxBindersScopeSorts(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxBindersScopeSorts production. */
TOKEN : {<MT_HxBindersScopeSorts : "#HxBindersScopeSorts" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxBindersScopeSorts production. */
TOKEN : {<IT_HxBindersScopeSorts : "%HxBindersScopeSorts">}

/**
 * <em>HxBindersScopeSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxBindersScopeSort">&lang;HxBindersScopeSort&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxBindersScopeSorts">&lang;HxBindersScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxBindersScopeSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxBindersScopeSorts> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxBindersScopeSorts>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxBindersScopeSort(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_COMMA>
		 ) 
		 ( 
		sink=N_HxBindersScopeSorts(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxBindersScopeSort$WithEOF</em> ::= <em>HxBindersScopeSort</em> EOF . */
net.sf.crsx.Sink N_HxBindersScopeSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxBindersScopeSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxBindersScopeSort production. */
TOKEN : {<MT_HxBindersScopeSort : "#HxBindersScopeSort" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxBindersScopeSort production. */
TOKEN : {<IT_HxBindersScopeSort : "%HxBindersScopeSort">}

/**
 * <em>HxBindersScopeSort</em> ::=   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   <a href="#N_HxBindersScopeSortInside">&lang;HxBindersScopeSortInside&rang;</a>   <br>
 *  |  <a href="#N_HxScopeSort">&lang;HxScopeSort&rang;</a>  
 */
net.sf.crsx.Sink N_HxBindersScopeSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxBindersScopeSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxBindersScopeSort>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	 <T_HX_LBRACKET>
	 ) 
	 ( 
	sink=N_HxBindersScopeSortInside(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	sink=N_HxScopeSort(sink, env)
	 ) 
	{return sink;}
}

/** Special meta-variable for HxBindersScopeSortInside production. */
TOKEN : {<MT_HxBindersScopeSortInside : "#HxBindersScopeSortInside" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxBindersScopeSortInside production. */
TOKEN : {<IT_HxBindersScopeSortInside : "%HxBindersScopeSortInside">}

/**
 * <em>HxBindersScopeSortInside</em> ::=  <a href="#N_HxSort">&lang;HxSort&rang;</a> <font color="red">:#Sort</font>    <a href="#T_HX_BINDS">HX_BINDS</a><font color="red">:hx</font>   <font color="red">{{#Sort}}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>   <a href="#N_HxBindersScopeSortInsideTail">&lang;HxBindersScopeSortInsideTail&rang;</a>  
 */
net.sf.crsx.Sink N_HxBindersScopeSortInside(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.Variable v_HxVariable = null;
	Token t = null;
	net.sf.crsx.Sink bs_HxVariable = null;
	net.sf.crsx.util.Buffer b__Sort = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
	String s_HxVariable = null;
	String c3 = null;
	net.sf.crsx.Sink bs__Sort = null;
}
{
	t=<MT_HxBindersScopeSortInside> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxBindersScopeSortInside>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		bs__Sort = b__Sort.sink();
	}
	N_HxSort(bs__Sort, env)
	 ) 
	 ( 
	t=<T_HX_BINDS>
	{
		sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .copy(b__Sort, true) ;
	}
	 ) 
	 ( 
	{
		bs_HxVariable = b_HxVariable.sink();
	}
	N_HxVariable(bs_HxVariable, env)
	{
		if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");
		c3 = b_HxVariable.term(true).constructor().symbol();
		s_HxVariable = c3;
		v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
		if (v_HxVariable == null) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");
		sink = sink .use(v_HxVariable) ;
	}
	 ) 
	 ( 
	sink=N_HxBindersScopeSortInsideTail(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for HxBindersScopeSortInsideTail production. */
TOKEN : {<MT_HxBindersScopeSortInsideTail : "#HxBindersScopeSortInsideTail" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxBindersScopeSortInsideTail production. */
TOKEN : {<IT_HxBindersScopeSortInsideTail : "%HxBindersScopeSortInsideTail">}

/**
 * <em>HxBindersScopeSortInsideTail</em> ::=   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxBindersScopeSortInside">&lang;HxBindersScopeSortInside&rang;</a>   <br>
 *  |   <a href="#T_HX_RBRACKET">HX_RBRACKET</a>   <a href="#N_HxBindersScopeSort">&lang;HxBindersScopeSort&rang;</a>  
 */
net.sf.crsx.Sink N_HxBindersScopeSortInsideTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxBindersScopeSortInsideTail> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxBindersScopeSortInsideTail>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	 <T_HX_COMMA>
	 ) 
	 ( 
	sink=N_HxBindersScopeSortInside(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	 <T_HX_RBRACKET>
	 ) 
	 ( 
	sink=N_HxBindersScopeSort(sink, env)
	 ) 
	{return sink;}
}

/** <em>HxScopeSort$WithEOF</em> ::= <em>HxScopeSort</em> EOF . */
net.sf.crsx.Sink N_HxScopeSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxScopeSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxScopeSort production. */
TOKEN : {<MT_HxScopeSort : "#HxScopeSort" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxScopeSort production. */
TOKEN : {<IT_HxScopeSort : "%HxScopeSort">}

/**
 * <em>HxScopeSort</em> ::=  <font color="red">{ScopeSort}</font><font color="red">:hx</font>   <a href="#N_HxSort">&lang;HxSort&rang;</a>    <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a>    (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   <a href="#N_HxSubstituteSorts">&lang;HxSubstituteSorts&rang;</a>     <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxScopeSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxScopeSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxScopeSort>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ScopeSort"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSort(sink, env)
	 ) 
	 ( 
	sink=N_HxRepeat(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_LBRACKET>
		 ) 
		 ( 
		sink=N_HxSubstituteSorts(sink, env)
		 ) 
		 ( 
		 <T_HX_RBRACKET>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxSubstituteSorts$WithEOF</em> ::= <em>HxSubstituteSorts</em> EOF . */
net.sf.crsx.Sink N_HxSubstituteSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSubstituteSorts(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSubstituteSorts production. */
TOKEN : {<MT_HxSubstituteSorts : "#HxSubstituteSorts" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSubstituteSorts production. */
TOKEN : {<IT_HxSubstituteSorts : "%HxSubstituteSorts">}

/**
 * <em>HxSubstituteSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxSubstituteSort">&lang;HxSubstituteSort&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxSubstituteSorts">&lang;HxSubstituteSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_HxSubstituteSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSubstituteSorts> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSubstituteSorts>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSubstituteSort(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_COMMA>
		 ) 
		 ( 
		sink=N_HxSubstituteSorts(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxSubstituteSort$WithEOF</em> ::= <em>HxSubstituteSort</em> EOF . */
net.sf.crsx.Sink N_HxSubstituteSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSubstituteSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSubstituteSort production. */
TOKEN : {<MT_HxSubstituteSort : "#HxSubstituteSort" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSubstituteSort production. */
TOKEN : {<IT_HxSubstituteSort : "%HxSubstituteSort">}

/**
 * <em>HxSubstituteSort</em> ::=  <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!:#v</font>   (  <font color="red">{SubstituteSort}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>    <a href="#T_HX_AS">HX_AS</a>   <a href="#N_HxSort">&lang;HxSort&rang;</a>   |  <font color="red">{SubstituteNoSort}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>  ) 
 */
net.sf.crsx.Sink N_HxSubstituteSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	String s__v = null;
	Token t = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__v = null;
	net.sf.crsx.Variable v__v = null;
}
{
	t=<MT_HxSubstituteSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSubstituteSort>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		bs__v = b__v.sink();
	}
	N_HxVariable(bs__v, env)
	{
		if (b__v.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b__v.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b__v.term(false)+")");
		c0 = b__v.term(true).constructor().symbol();
		s__v = c0;
		v__v = (env.containsKey(s__v) ? env.get(s__v) : factory.freeVariable(s__v, true, true));
		if (v__v == null) throw new ParseException("Variable "+s__v+" cannot be resolved?");
	}
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("SubstituteSort"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .use(v__v) ;
		}
		 ) 
		 ( 
		 <T_HX_AS>
		 ) 
		 ( 
		sink=N_HxSort(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("SubstituteNoSort"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .use(v__v) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxSort$WithEOF</em> ::= <em>HxSort</em> EOF . */
net.sf.crsx.Sink N_HxSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSort production. */
TOKEN : {<MT_HxSort : "#HxSort" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSort production. */
TOKEN : {<IT_HxSort : "%HxSort">}

/**
 * <em>HxSort</em> ::=  <font color="red">{Sort}</font><font color="red">:hx</font>   <a href="#N_HxSimpleSort">&lang;HxSimpleSort&rang;</a>    <a href="#N_HxSimpleSorts">&lang;HxSimpleSorts&rang;</a>  
 */
net.sf.crsx.Sink N_HxSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSort>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Sort"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSimpleSort(sink, env)
	 ) 
	 ( 
	sink=N_HxSimpleSorts(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxSimpleSorts$WithEOF</em> ::= <em>HxSimpleSorts</em> EOF . */
net.sf.crsx.Sink N_HxSimpleSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSimpleSorts(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSimpleSorts production. */
TOKEN : {<MT_HxSimpleSorts : "#HxSimpleSorts" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSimpleSorts production. */
TOKEN : {<IT_HxSimpleSorts : "%HxSimpleSorts">}

/**
 * <em>HxSimpleSorts</em> ::=   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <font color="red">{$Cons}</font>   <a href="#N_HxSimpleSort">&lang;HxSimpleSort&rang;</a>    <a href="#N_HxSimpleSortTail">&lang;HxSimpleSortTail&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_HxSimpleSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSimpleSorts> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSimpleSorts>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	 <T_HX_LPAREN>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		sink=N_HxSimpleSort(sink, env)
		 ) 
		 ( 
		sink=N_HxSimpleSortTail(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	 <T_HX_RPAREN>
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for HxSimpleSortTail production. */
TOKEN : {<MT_HxSimpleSortTail : "#HxSimpleSortTail" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSimpleSortTail production. */
TOKEN : {<IT_HxSimpleSortTail : "%HxSimpleSortTail">}

/**
 * <em>HxSimpleSortTail</em> ::=   <a href="#T_HX_COMMA">HX_COMMA</a>   <font color="red">{$Cons}</font>   <a href="#N_HxSimpleSort">&lang;HxSimpleSort&rang;</a>    <a href="#N_HxSimpleSortTail">&lang;HxSimpleSortTail&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_HxSimpleSortTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSimpleSortTail> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSimpleSortTail>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	 <T_HX_COMMA>
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSimpleSort(sink, env)
	 ) 
	 ( 
	sink=N_HxSimpleSortTail(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxSimpleSort$WithEOF</em> ::= <em>HxSimpleSort</em> EOF . */
net.sf.crsx.Sink N_HxSimpleSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSimpleSort(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSimpleSort production. */
TOKEN : {<MT_HxSimpleSort : "#HxSimpleSort" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSimpleSort production. */
TOKEN : {<IT_HxSimpleSort : "%HxSimpleSort">}

/**
 * <em>HxSimpleSort</em> ::=  <font color="red">{SortName}</font><font color="red">:hx</font>   <a href="#N_HxSortName">&lang;HxSortName&rang;</a>    <a href="#N_HxMetaVariables">&lang;HxMetaVariables&rang;</a>   <br>
 *  |  <font color="red">{SortParam}</font><font color="red">:hx</font>   <a href="#N_HxSortParam">&lang;HxSortParam&rang;</a>  
 */
net.sf.crsx.Sink N_HxSimpleSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSimpleSort> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSimpleSort>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("SortName"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSortName(sink, env)
	 ) 
	 ( 
	sink=N_HxMetaVariables(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("SortParam"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxSortParam(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxMetaVariables$WithEOF</em> ::= <em>HxMetaVariables</em> EOF . */
net.sf.crsx.Sink N_HxMetaVariables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxMetaVariables(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxMetaVariables production. */
TOKEN : {<MT_HxMetaVariables : "#HxMetaVariables" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxMetaVariables production. */
TOKEN : {<IT_HxMetaVariables : "%HxMetaVariables">}

/**
 * <em>HxMetaVariables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>    <font color="red">{$Nil}</font>  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_HxMetaVariables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxMetaVariables> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxMetaVariables>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxMetaVariable(sink, env)
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end().end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxSortParam$WithEOF</em> ::= <em>HxSortParam</em> EOF . */
net.sf.crsx.Sink N_HxSortParam$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSortParam(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSortParam production. */
TOKEN : {<MT_HxSortParam : "#HxSortParam" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSortParam production. */
TOKEN : {<IT_HxSortParam : "%HxSortParam">}

/**
 * <em>HxSortParam</em> ::=  <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!</font> 
 */
net.sf.crsx.Sink N_HxSortParam(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.Variable v_HxVariable = null;
	Token t = null;
	net.sf.crsx.Sink bs_HxVariable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
	String s_HxVariable = null;
}
{
	t=<MT_HxSortParam> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSortParam>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		bs_HxVariable = b_HxVariable.sink();
	}
	N_HxVariable(bs_HxVariable, env)
	{
		if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");
		c0 = b_HxVariable.term(true).constructor().symbol();
		s_HxVariable = c0;
		v_HxVariable = env.get(s_HxVariable);
		if (v_HxVariable == null) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");
		sink = sink .use(v_HxVariable) ;
	}
	 ) 
	{return sink;}
}

/** <em>HxFormPrec$WithEOF</em> ::= <em>HxFormPrec</em> EOF . */
net.sf.crsx.Sink N_HxFormPrec$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxFormPrec(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxFormPrec production. */
TOKEN : {<MT_HxFormPrec : "#HxFormPrec" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxFormPrec production. */
TOKEN : {<IT_HxFormPrec : "%HxFormPrec">}

/**
 * <em>HxFormPrec</em> ::=  (   <a href="#T_HX_AT">HX_AT</a>   <a href="#N_HxNatural">&lang;HxNatural&rang;</a>   |  <font color="red">{"0"}</font>  ) 
 */
net.sf.crsx.Sink N_HxFormPrec(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxFormPrec> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxFormPrec>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		 <T_HX_AT>
		 ) 
		 ( 
		sink=N_HxNatural(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "0", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxInheritedRefs$WithEOF</em> ::= <em>HxInheritedRefs</em> EOF . */
net.sf.crsx.Sink N_HxInheritedRefs$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxInheritedRefs(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxInheritedRefs production. */
TOKEN : {<MT_HxInheritedRefs : "#HxInheritedRefs" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxInheritedRefs production. */
TOKEN : {<IT_HxInheritedRefs : "%HxInheritedRefs">}

/**
 * <em>HxInheritedRefs</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_HxInheritedRef">&lang;HxInheritedRef&rang;</a>    <a href="#N_HxInheritedRefs">&lang;HxInheritedRefs&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxInheritedRefs(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxInheritedRefs> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxInheritedRefs>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		sink=N_HxInheritedRef(sink, env)
		 ) 
		 ( 
		sink=N_HxInheritedRefs(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxInheritedRef$WithEOF</em> ::= <em>HxInheritedRef</em> EOF . */
net.sf.crsx.Sink N_HxInheritedRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxInheritedRef(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxInheritedRef production. */
TOKEN : {<MT_HxInheritedRef : "#HxInheritedRef" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxInheritedRef production. */
TOKEN : {<IT_HxInheritedRef : "%HxInheritedRef">}

/**
 * <em>HxInheritedRef</em> ::=   <a href="#T_HX_DOWN">HX_DOWN</a>   <a href="#N_HxAttributeName">&lang;HxAttributeName&rang;</a>  
 */
net.sf.crsx.Sink N_HxInheritedRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxInheritedRef> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxInheritedRef>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	 <T_HX_DOWN>
	 ) 
	 ( 
	sink=N_HxAttributeName(sink, env)
	 ) 
	{return sink;}
}

/** <em>HxRule$WithEOF</em> ::= <em>HxRule</em> EOF . */
net.sf.crsx.Sink N_HxRule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxRule(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRule production. */
TOKEN : {<MT_HxRule : "#HxRule" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRule production. */
TOKEN : {<IT_HxRule : "%HxRule">}

/**
 * <em>HxRule</em> ::=  <font color="red">{Rule}</font><font color="red">:hx</font>   <a href="#N_HxRulePrefix">&lang;HxRulePrefix&rang;</a>    <a href="#N_HxTopPattern">&lang;HxTopPattern&rang;</a>    (   <a href="#T_HX_ARROW">HX_ARROW</a>   <a href="#N_HxTopTerm">&lang;HxTopTerm&rang;</a>   |  <font color="red">{NullTerm}</font><font color="red">:hx</font>  ) 
 */
net.sf.crsx.Sink N_HxRule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRule> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRule>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Rule"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRulePrefix(sink, env)
	 ) 
	 ( 
	sink=N_HxTopPattern(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_ARROW>
		 ) 
		 ( 
		sink=N_HxTopTerm(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("NullTerm"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRulePrefix$WithEOF</em> ::= <em>HxRulePrefix</em> EOF . */
net.sf.crsx.Sink N_HxRulePrefix$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxRulePrefix(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRulePrefix production. */
TOKEN : {<MT_HxRulePrefix : "#HxRulePrefix" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRulePrefix production. */
TOKEN : {<IT_HxRulePrefix : "%HxRulePrefix">}

/**
 * <em>HxRulePrefix</em> ::=  <font color="red">{RulePrefix}</font><font color="red">:hx</font>   <a href="#N_HxRulePriority">&lang;HxRulePriority&rang;</a>    (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   (  <a href="#N_HxRuleOptions">&lang;HxRuleOptions&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxRulePrefix(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRulePrefix> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRulePrefix>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RulePrefix"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxRulePriority(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_LBRACKET>
		 ) 
		 ( 
			 ( 
			sink=N_HxRuleOptions(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_HX_RBRACKET>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRulePriority$WithEOF</em> ::= <em>HxRulePriority</em> EOF . */
net.sf.crsx.Sink N_HxRulePriority$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxRulePriority(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRulePriority production. */
TOKEN : {<MT_HxRulePriority : "#HxRulePriority" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRulePriority production. */
TOKEN : {<IT_HxRulePriority : "%HxRulePriority">}

/**
 * <em>HxRulePriority</em> ::=  (   <a href="#T_HX_DEFAULT">HX_DEFAULT</a><font color="red">:hx</font>  |   <a href="#T_HX_PRIORITY">HX_PRIORITY</a><font color="red">:hx</font>  |  <font color="red">{Normal}</font><font color="red">:hx</font>  ) 
 */
net.sf.crsx.Sink N_HxRulePriority(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRulePriority> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRulePriority>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		t=<T_HX_DEFAULT>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_PRIORITY>
		{
			sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Normal"), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxRuleOptions$WithEOF</em> ::= <em>HxRuleOptions</em> EOF . */
net.sf.crsx.Sink N_HxRuleOptions$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxRuleOptions(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRuleOptions production. */
TOKEN : {<MT_HxRuleOptions : "#HxRuleOptions" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRuleOptions production. */
TOKEN : {<IT_HxRuleOptions : "%HxRuleOptions">}

/**
 * <em>HxRuleOptions</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxTopPattern">&lang;HxTopPattern&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxRuleOptions">&lang;HxRuleOptions&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxRuleOptions(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRuleOptions> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRuleOptions>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxTopPattern(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_COMMA>
		 ) 
		 ( 
		sink=N_HxRuleOptions(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/* "Last top level sort name" hack. */

net.sf.crsx.Sink N_Store_HxSortName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b = new net.sf.crsx.util.Buffer(sink);
}
{
	N_HxSortName(b.sink(), env)
	{
		net.sf.crsx.Term term = b.term(false);
		storedSort = net.sf.crsx.util.Util.symbol(term);
		return term.copy(sink, true, net.sf.crsx.util.LinkedExtensibleMap.EMPTY_RENAMING);
	}
}

net.sf.crsx.Sink N_Restoring_HxDeclarations(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	String savedStoredSort = storedSort;
}
{
	sink=N_HxDeclarations(sink, env)
	{
		storedSort = savedStoredSort;
		return sink;
	}
}

// Shared nesting state.

TOKEN_MGR_DECLS : { int nesting ; int nestedState; }


/** <em>HxTopTerm$WithEOF</em> ::= <em>HxTopTerm</em> EOF . */
net.sf.crsx.Sink N_HxTopTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxTopTerm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxTopTerm production. */
TOKEN : {<MT_HxTopTerm : "#HxTopTerm" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxTopTerm production. */
TOKEN : {<IT_HxTopTerm : "%HxTopTerm">}

/**
 * <em>HxTopTerm</em> ::=  <a href="#N_HxTerm">&lang;HxTerm&rang;</a>  
 */
net.sf.crsx.Sink N_HxTopTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxTopTerm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxTopTerm>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	sink=N_HxTerm(sink, env)
	 ) 
	{return sink;}
}

/** <em>HxTopPattern$WithEOF</em> ::= <em>HxTopPattern</em> EOF . */
net.sf.crsx.Sink N_HxTopPattern$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxTopPattern(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxTopPattern production. */
TOKEN : {<MT_HxTopPattern : "#HxTopPattern" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxTopPattern production. */
TOKEN : {<IT_HxTopPattern : "%HxTopPattern">}

/**
 * <em>HxTopPattern</em> ::=  <a href="#N_HxPattern">&lang;HxPattern&rang;</a>  
 */
net.sf.crsx.Sink N_HxTopPattern(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxTopPattern> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxTopPattern>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	sink=N_HxPattern(sink, env)
	 ) 
	{return sink;}
}

/** <em>HxAttributes$WithEOF</em> ::= <em>HxAttributes</em> EOF . */
net.sf.crsx.Sink N_HxAttributes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxAttributes(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxAttributes production. */
TOKEN : {<MT_HxAttributes : "#HxAttributes" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxAttributes production. */
TOKEN : {<IT_HxAttributes : "%HxAttributes">}

/**
 * <em>HxAttributes</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_HxAttribute">&lang;HxAttribute&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxAttributes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxAttributes> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxAttributes>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
		}
		 ) 
		 ( 
		sink=N_HxAttribute(sink, env)
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxSortName$WithEOF</em> ::= <em>HxSortName</em> EOF . */
net.sf.crsx.Sink N_HxSortName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSortName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSortName production. */
TOKEN : {<MT_HxSortName : "#HxSortName" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSortName production. */
TOKEN : {<IT_HxSortName : "%HxSortName">}

/**
 * <em>HxSortName</em> ::=   <a href="#T_HX_CONSTRUCTOR">HX_CONSTRUCTOR</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxSortName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSortName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSortName>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_CONSTRUCTOR>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxConstructor$WithEOF</em> ::= <em>HxConstructor</em> EOF . */
net.sf.crsx.Sink N_HxConstructor$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxConstructor(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxConstructor production. */
TOKEN : {<MT_HxConstructor : "#HxConstructor" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxConstructor production. */
TOKEN : {<IT_HxConstructor : "%HxConstructor">}

/**
 * <em>HxConstructor</em> ::=   <a href="#T_HX_CONSTRUCTOR">HX_CONSTRUCTOR</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxConstructor(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxConstructor> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxConstructor>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_CONSTRUCTOR>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxTerm$WithEOF</em> ::= <em>HxTerm</em> EOF . */
net.sf.crsx.Sink N_HxTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxTerm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxTerm production. */
TOKEN : {<MT_HxTerm : "#HxTerm" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxTerm production. */
TOKEN : {<IT_HxTerm : "%HxTerm">}

/**
 * <em>HxTerm</em> ::=  <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!:#v</font>   (  <font color="red">{Special}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>   <a href="#N_HxConcreteText">&lang;HxConcreteText&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{VariableUse}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   )  <br>
 *  |  <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a> <font color="red">:#C</font>   <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{UnparsedSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxConcrete">&lang;HxConcrete&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{MetaApplicationSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>    (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   (  <a href="#N_HxTerms">&lang;HxTerms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a>    (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{VariableUseSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{LiteralSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxLiteral">&lang;HxLiteral&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:hx</font>   <a href="#N_HxLiteral">&lang;HxLiteral&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   <br>
 *  |  <font color="red">{Unparsed}</font><font color="red">:hx</font>   <a href="#N_HxConcrete">&lang;HxConcrete&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   <br>
 *  |  <font color="red">{MetaApplication}</font><font color="red">:hx</font>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>    (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   (  <a href="#N_HxTerms">&lang;HxTerms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>  
 */
net.sf.crsx.Sink N_HxTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.Variable v_HxVariable = null;
	net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__C = null;
	String s_HxVariable = null;
	net.sf.crsx.Variable v__v = null;
	String c9 = null;
	net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
	String s__v = null;
	Token t = null;
	net.sf.crsx.Sink bs_HxVariable = null;
	net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
	String c0 = null;
	net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__R = null;
	net.sf.crsx.Sink bs__v = null;
}
{
	t=<MT_HxTerm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxTerm>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		bs__v = b__v.sink();
	}
	N_HxVariable(bs__v, env)
	{
		if (b__v.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b__v.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b__v.term(false)+")");
		c0 = b__v.term(true).constructor().symbol();
		s__v = c0;
		v__v = (env.containsKey(s__v) ? env.get(s__v) : factory.freeVariable(s__v, true, true));
		if (v__v == null) throw new ParseException("Variable "+s__v+" cannot be resolved?");
	}
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Special"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .use(v__v) ;
		}
		 ) 
		 ( 
		sink=N_HxConcreteText(sink, env)
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("VariableUse"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .use(v__v) ;
		}
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		bs__C = b__C.sink();
	}
	N_HxConstructor(bs__C, env)
	 ) 
	 ( 
	{
		bs__R = b__R.sink();
	}
	N_HxRepeat(bs__R, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("UnparsedSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_HxConcrete(sink, env)
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("MetaApplicationSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_HxMetaVariable(sink, env)
		 ) 
		 ( 
			 ( 
			 <T_HX_LBRACKET>
			 ) 
			 ( 
				 ( 
				sink=N_HxTerms(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_HX_RBRACKET>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("ConstructionSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_HxConstructor(sink, env)
		 ) 
		 ( 
			 ( 
			 <T_HX_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_HxScopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_HX_RPAREN>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("VariableUseSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		{
			bs_HxVariable = b_HxVariable.sink();
		}
		N_HxVariable(bs_HxVariable, env)
		{
			if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
			 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");
			c9 = b_HxVariable.term(true).constructor().symbol();
			s_HxVariable = c9;
			v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
			if (v_HxVariable == null) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");
			sink = sink .use(v_HxVariable) ;
		}
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("LiteralSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_HxLiteral(sink, env)
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Construction"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_HX_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_HxScopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_HX_RPAREN>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Literal"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxLiteral(sink, env)
	 ) 
	 ( 
	sink=N_HxAttributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Unparsed"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxConcrete(sink, env)
	 ) 
	 ( 
	sink=N_HxAttributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("MetaApplication"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxMetaVariable(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_LBRACKET>
		 ) 
		 ( 
			 ( 
			sink=N_HxTerms(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_HX_RBRACKET>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_HxAttributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for HxPattern production. */
TOKEN : {<MT_HxPattern : "#HxPattern" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxPattern production. */
TOKEN : {<IT_HxPattern : "%HxPattern">}

/**
 * <em>HxPattern</em> ::=  <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a> <font color="red">:#C</font>   <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{UnparsedSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxConcrete">&lang;HxConcrete&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a>    (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{LiteralSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxLiteral">&lang;HxLiteral&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:hx</font>   <a href="#N_HxLiteral">&lang;HxLiteral&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   <br>
 *  |  <font color="red">{Unparsed}</font><font color="red">:hx</font>   <a href="#N_HxConcrete">&lang;HxConcrete&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>  
 */
net.sf.crsx.Sink N_HxPattern(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
	Token t = null;
	net.sf.crsx.Sink bs__C = null;
	net.sf.crsx.Sink bs__R = null;
}
{
	t=<MT_HxPattern> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxPattern>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		bs__C = b__C.sink();
	}
	N_HxConstructor(bs__C, env)
	 ) 
	 ( 
	{
		bs__R = b__R.sink();
	}
	N_HxRepeat(bs__R, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("UnparsedSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_HxConcrete(sink, env)
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("ConstructionSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_HxConstructor(sink, env)
		 ) 
		 ( 
			 ( 
			 <T_HX_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_HxScopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_HX_RPAREN>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("LiteralSorted"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__R, true) ;
		}
		 ) 
		 ( 
		sink=N_HxLiteral(sink, env)
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Construction"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__C, true) ;
		}
		 ) 
		 ( 
			 ( 
			 <T_HX_LPAREN>
			 ) 
			 ( 
				 ( 
				sink=N_HxScopes(sink, env)
				 ) 
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
			 ( 
			 <T_HX_RPAREN>
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		sink=N_HxAttributes(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Literal"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxLiteral(sink, env)
	 ) 
	 ( 
	sink=N_HxAttributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Unparsed"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxConcrete(sink, env)
	 ) 
	 ( 
	sink=N_HxAttributes(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxScopes$WithEOF</em> ::= <em>HxScopes</em> EOF . */
net.sf.crsx.Sink N_HxScopes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxScopes(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxScopes production. */
TOKEN : {<MT_HxScopes : "#HxScopes" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxScopes production. */
TOKEN : {<IT_HxScopes : "%HxScopes">}

/**
 * <em>HxScopes</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxScope">&lang;HxScope&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxScopes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxScopes> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxScopes>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxScope(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_COMMA>
		 ) 
		 ( 
		sink=N_HxScopes(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxScope$WithEOF</em> ::= <em>HxScope</em> EOF . */
net.sf.crsx.Sink N_HxScope$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxScope(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxScope production. */
TOKEN : {<MT_HxScope : "#HxScope" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxScope production. */
TOKEN : {<IT_HxScope : "%HxScope">}

/**
 * <em>HxScope</em> ::=  <font color="red">{Scope}</font><font color="red">:hx</font>   (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   (  <a href="#N_HxVariableList">&lang;HxVariableList&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>  
 */
net.sf.crsx.Sink N_HxScope(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxScope> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxScope>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("Scope"), null)) ;
	}
	 ) 
	 ( 
		 ( 
		 <T_HX_LBRACKET>
		 ) 
		 ( 
			 ( 
			sink=N_HxVariableList(sink, env)
			 ) 
		|
			 ( 
			{
				sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
			}
			 ) 
			{
				sink = sink .end() ;
			}
		 ) 
		 ( 
		 <T_HX_RBRACKET>
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	sink=N_HxTerm(sink, env)
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxVariables$WithEOF</em> ::= <em>HxVariables</em> EOF . */
net.sf.crsx.Sink N_HxVariables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxVariables(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxVariables production. */
TOKEN : {<MT_HxVariables : "#HxVariables" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxVariables production. */
TOKEN : {<IT_HxVariables : "%HxVariables">}

/**
 * <em>HxVariables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>   <a href="#N_HxVariables">&lang;HxVariables&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
net.sf.crsx.Sink N_HxVariables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.Variable v_HxVariable = null;
	Token t = null;
	net.sf.crsx.Sink bs_HxVariable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
	String s_HxVariable = null;
}
{
	t=<MT_HxVariables> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxVariables>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	{
		bs_HxVariable = b_HxVariable.sink();
	}
	N_HxVariable(bs_HxVariable, env)
	{
		if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");
		c0 = b_HxVariable.term(true).constructor().symbol();
		s_HxVariable = c0;
		v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
		if (v_HxVariable == null) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");
		sink = sink .use(v_HxVariable) ;
	}
	 ) 
	 ( 
	sink=N_HxVariables(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for HxVariableList production. */
TOKEN : {<MT_HxVariableList : "#HxVariableList" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxVariableList production. */
TOKEN : {<IT_HxVariableList : "%HxVariableList">}

/**
 * <em>HxVariableList</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>   (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxVariableList">&lang;HxVariableList&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxVariableList(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.Variable v_HxVariable = null;
	Token t = null;
	net.sf.crsx.Sink bs_HxVariable = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
	String s_HxVariable = null;
}
{
	t=<MT_HxVariableList> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxVariableList>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	{
		bs_HxVariable = b_HxVariable.sink();
	}
	N_HxVariable(bs_HxVariable, env)
	{
		if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
		 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");
		c0 = b_HxVariable.term(true).constructor().symbol();
		s_HxVariable = c0;
		v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
		if (v_HxVariable == null) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");
		sink = sink .use(v_HxVariable) ;
	}
	 ) 
	 ( 
		 ( 
		 <T_HX_COMMA>
		 ) 
		 ( 
		sink=N_HxVariableList(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxTerms$WithEOF</em> ::= <em>HxTerms</em> EOF . */
net.sf.crsx.Sink N_HxTerms$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxTerms(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxTerms production. */
TOKEN : {<MT_HxTerms : "#HxTerms" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxTerms production. */
TOKEN : {<IT_HxTerms : "%HxTerms">}

/**
 * <em>HxTerms</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxTerms">&lang;HxTerms&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
net.sf.crsx.Sink N_HxTerms(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxTerms> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxTerms>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
	}
	 ) 
	 ( 
	sink=N_HxTerm(sink, env)
	 ) 
	 ( 
		 ( 
		 <T_HX_COMMA>
		 ) 
		 ( 
		sink=N_HxTerms(sink, env)
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxAttribute$WithEOF</em> ::= <em>HxAttribute</em> EOF . */
net.sf.crsx.Sink N_HxAttribute$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxAttribute(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxAttribute production. */
TOKEN : {<MT_HxAttribute : "#HxAttribute" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxAttribute production. */
TOKEN : {<IT_HxAttribute : "%HxAttribute">}

/**
 * <em>HxAttribute</em> ::=  <a href="#N_HxAttributeKind">&lang;HxAttributeKind&rang;</a> <font color="red">:#kind</font>   (  <font color="red">{Attribute}</font><font color="red">:hx</font>   <font color="red">{{#kind}}</font>   <a href="#N_HxAttributeName">&lang;HxAttributeName&rang;</a>    <a href="#N_HxAttributeValue">&lang;HxAttributeValue&rang;</a>   |  <font color="red">{CatchAllAttributes}</font><font color="red">:hx</font>   <font color="red">{{#kind}}</font>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>   |  <a href="#N_HxSystemAttribute">&lang;HxSystemAttribute&rang;</a>   ) 
 */
net.sf.crsx.Sink N_HxAttribute(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink bs__kind = null;
	net.sf.crsx.util.Buffer b__kind = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_HxAttribute> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxAttribute>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		bs__kind = b__kind.sink();
	}
	N_HxAttributeKind(bs__kind, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("Attribute"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__kind, true) ;
		}
		 ) 
		 ( 
		sink=N_HxAttributeName(sink, env)
		 ) 
		 ( 
		sink=N_HxAttributeValue(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("CatchAllAttributes"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__kind, true) ;
		}
		 ) 
		 ( 
		sink=N_HxMetaVariable(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		sink=N_HxSystemAttribute(sink, env)
		 ) 
	 ) 
	{return sink;}
}

/** Special meta-variable for HxSystemAttribute production. */
TOKEN : {<MT_HxSystemAttribute : "#HxSystemAttribute" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSystemAttribute production. */
TOKEN : {<IT_HxSystemAttribute : "%HxSystemAttribute">}

/**
 * <em>HxSystemAttribute</em> ::=  <font color="red">{SystemAttribute}</font><font color="red">:hx</font>    <a href="#T_HX_DOT">HX_DOT</a>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a>     <a href="#T_HX_LPAREN">HX_LPAREN</a>   <a href="#N_HxTopPattern">&lang;HxTopPattern&rang;</a>     <a href="#T_HX_RPAREN">HX_RPAREN</a> 
 */
net.sf.crsx.Sink N_HxSystemAttribute(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSystemAttribute> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSystemAttribute>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("SystemAttribute"), null)) ;
	}
	 ) 
	 ( 
	 <T_HX_DOT>
	 ) 
	 ( 
	sink=N_HxVariable(sink, env)
	 ) 
	 ( 
	 <T_HX_LPAREN>
	 ) 
	 ( 
	sink=N_HxTopPattern(sink, env)
	 ) 
	 ( 
	 <T_HX_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxAttributeValue$WithEOF</em> ::= <em>HxAttributeValue</em> EOF . */
net.sf.crsx.Sink N_HxAttributeValue$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxAttributeValue(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxAttributeValue production. */
TOKEN : {<MT_HxAttributeValue : "#HxAttributeValue" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxAttributeValue production. */
TOKEN : {<IT_HxAttributeValue : "%HxAttributeValue">}

/**
 * <em>HxAttributeValue</em> ::=  <font color="red">{AttributeValue}</font><font color="red">:hx</font>    <a href="#T_HX_LPAREN">HX_LPAREN</a>   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>     <a href="#T_HX_RPAREN">HX_RPAREN</a>  <br>
 *  |   <a href="#T_HX_LBRACE">HX_LBRACE</a>   (  (  <a href="#N_HxTerm">&lang;HxTerm&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeKeyValue}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_HX_COLON">HX_COLON</a>   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>   |  <font color="red">{AttributeKey}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>  )  )  |  <font color="red">{AttributeCatchAll}</font><font color="red">:hx</font>    <a href="#T_HX_COLON">HX_COLON</a>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>   |  <font color="red">{AttributeNotKey}</font><font color="red">:hx</font>    <a href="#T_HX_NOT">HX_NOT</a>   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>   )    <a href="#T_HX_RBRACE">HX_RBRACE</a> 
 */
net.sf.crsx.Sink N_HxAttributeValue(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink bs__ = null;
	net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_HxAttributeValue> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxAttributeValue>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("AttributeValue"), null)) ;
	}
	 ) 
	 ( 
	 <T_HX_LPAREN>
	 ) 
	 ( 
	sink=N_HxTerm(sink, env)
	 ) 
	 ( 
	 <T_HX_RPAREN>
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_HX_LBRACE>
	 ) 
	 ( 
		 ( 
			 ( 
			{
				bs__ = b__.sink();
			}
			N_HxTerm(bs__, env)
			 ) 
			 ( 
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, hx("AttributeKeyValue"), null)) ;
				}
				 ) 
				 ( 
				{
					sink = sink .copy(b__, true) ;
				}
				 ) 
				 ( 
				 <T_HX_COLON>
				 ) 
				 ( 
				sink=N_HxTerm(sink, env)
				 ) 
				{
					sink = sink .end() ;
				}
			|
				 ( 
				{
					sink = sink .start(makeTConstructor(sink, t, hx("AttributeKey"), null)) ;
				}
				 ) 
				 ( 
				{
					sink = sink .copy(b__, true) ;
				}
				 ) 
				{
					sink = sink .end() ;
				}
			 ) 
		 ) 
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeCatchAll"), null)) ;
		}
		 ) 
		 ( 
		 <T_HX_COLON>
		 ) 
		 ( 
		sink=N_HxMetaVariable(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("AttributeNotKey"), null)) ;
		}
		 ) 
		 ( 
		 <T_HX_NOT>
		 ) 
		 ( 
		sink=N_HxTerm(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	 ( 
	 <T_HX_RBRACE>
	 ) 
	{return sink;}
}

/** <em>HxConcrete$WithEOF</em> ::= <em>HxConcrete</em> EOF . */
net.sf.crsx.Sink N_HxConcrete$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxConcrete(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxConcrete production. */
TOKEN : {<MT_HxConcrete : "#HxConcrete" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxConcrete production. */
TOKEN : {<IT_HxConcrete : "%HxConcrete">}

/**
 * <em>HxConcrete</em> ::=   <a href="#T_HX_CONCRETE">HX_CONCRETE</a><font color="red">$:unwrap</font> 
 */
net.sf.crsx.Sink N_HxConcrete(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxConcrete> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxConcrete>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_CONCRETE>
	{
		sink = sink .start(makeTConstructor(sink, t, unwrap(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxConcreteText$WithEOF</em> ::= <em>HxConcreteText</em> EOF . */
net.sf.crsx.Sink N_HxConcreteText$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxConcreteText(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxConcreteText production. */
TOKEN : {<MT_HxConcreteText : "#HxConcreteText" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxConcreteText production. */
TOKEN : {<IT_HxConcreteText : "%HxConcreteText">}

/**
 * <em>HxConcreteText</em> ::=   <a href="#T_HX_CONCRETE">HX_CONCRETE</a><font color="red">$$:unwrap:{n}</font> 
 */
net.sf.crsx.Sink N_HxConcreteText(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxConcreteText> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxConcreteText>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_CONCRETE>
	{
		try {sink = factory.parser(factory).parse(sink, "n", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

// Nested concrete token ⟦...⟧. 
<DEFAULT,HX_RE> MORE : { "\u27e6" { nesting = 0; nestedState = curLexState; } : HX_IN_CONCRETE }
<HX_IN_CONCRETE> MORE : { "\u27e6" { nesting = 1; } : HX_IN_NESTED_CONCRETE }
<HX_IN_NESTED_CONCRETE> MORE : { "\u27e6" { nesting++; } }
<HX_IN_NESTED_CONCRETE> MORE : { "\u27e7" { if (--nesting <= 0) SwitchTo(HX_IN_CONCRETE); } }
<HX_IN_CONCRETE> TOKEN : { <T_HX_CONCRETE : "\u27e7"> { SwitchTo(nestedState); } }
<HX_IN_CONCRETE,HX_IN_NESTED_CONCRETE> MORE : { < ~[] > }


// Nested comments JavaCC hack...
<DEFAULT,HX_RE> SKIP : { "/*" { nesting = 1; nestedState = curLexState; } : HX_NESTED_COMMENT }
<HX_NESTED_COMMENT> SKIP : { "/*" { nesting += 1; } }
<HX_NESTED_COMMENT> SKIP : { "*/" { nesting -= 1; if (nesting<=0) SwitchTo(nestedState); } }
<HX_NESTED_COMMENT> SKIP : { < ~[] > }


/** <em>HxModuleName$WithEOF</em> ::= <em>HxModuleName</em> EOF . */
net.sf.crsx.Sink N_HxModuleName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxModuleName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxModuleName production. */
TOKEN : {<MT_HxModuleName : "#HxModuleName" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxModuleName production. */
TOKEN : {<IT_HxModuleName : "%HxModuleName">}

/**
 * <em>HxModuleName</em> ::=  (  <a href="#N_HxString">&lang;HxString&rang;</a> <font color="red">:checkModuleString</font>  |   <a href="#T_HX_DOTTEDNAME">HX_DOTTEDNAME</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_HxModuleName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink bs_HxString = null;
	String c0 = null;
	net.sf.crsx.util.Buffer b_HxString = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_HxModuleName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxModuleName>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		{
			bs_HxString = b_HxString.sink();
		}
		N_HxString(bs_HxString, env)
		{
			if (b_HxString.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxString.term(false).arity() != 0)
			 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxString.term(false)+")");
			c0 = b_HxString.term(true).constructor().symbol();
			sink = sink .start(makeTConstructor(sink, t, checkModuleString(c0), null)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_DOTTEDNAME>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxVariable$WithEOF</em> ::= <em>HxVariable</em> EOF . */
net.sf.crsx.Sink N_HxVariable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxVariable(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxVariable production. */
TOKEN : {<MT_HxVariable : "#HxVariable" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxVariable production. */
TOKEN : {<IT_HxVariable : "%HxVariable">}

/**
 * <em>HxVariable</em> ::=   <a href="#T_HX_VAR">HX_VAR</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxVariable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxVariable> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxVariable>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_VAR>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxMetaVariable$WithEOF</em> ::= <em>HxMetaVariable</em> EOF . */
net.sf.crsx.Sink N_HxMetaVariable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxMetaVariable(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxMetaVariable production. */
TOKEN : {<MT_HxMetaVariable : "#HxMetaVariable" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxMetaVariable production. */
TOKEN : {<IT_HxMetaVariable : "%HxMetaVariable">}

/**
 * <em>HxMetaVariable</em> ::=   <a href="#T_HX_META">HX_META</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxMetaVariable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxMetaVariable> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxMetaVariable>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_META>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxAttributeName$WithEOF</em> ::= <em>HxAttributeName</em> EOF . */
net.sf.crsx.Sink N_HxAttributeName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxAttributeName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxAttributeName production. */
TOKEN : {<MT_HxAttributeName : "#HxAttributeName" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxAttributeName production. */
TOKEN : {<IT_HxAttributeName : "%HxAttributeName">}

/**
 * <em>HxAttributeName</em> ::=   <a href="#T_HX_VAR">HX_VAR</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxAttributeName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxAttributeName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxAttributeName>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_VAR>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxSeparator$WithEOF</em> ::= <em>HxSeparator</em> EOF . */
net.sf.crsx.Sink N_HxSeparator$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxSeparator(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxSeparator production. */
TOKEN : {<MT_HxSeparator : "#HxSeparator" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxSeparator production. */
TOKEN : {<IT_HxSeparator : "%HxSeparator">}

/**
 * <em>HxSeparator</em> ::=  (   <a href="#T_HX_BAR">HX_BAR</a><font color="red">$</font>  |   <a href="#T_HX_SEMI">HX_SEMI</a><font color="red">$</font>  |   <a href="#T_HX_COMMA">HX_COMMA</a><font color="red">$</font>  |   <a href="#T_HX_COLON">HX_COLON</a><font color="red">$</font>  |   <a href="#T_HX_STAR">HX_STAR</a><font color="red">$</font>  |   <a href="#T_HX_DOT">HX_DOT</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_HxSeparator(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxSeparator> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxSeparator>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		t=<T_HX_BAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_SEMI>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_COMMA>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_COLON>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_STAR>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_DOT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxTokenName$WithEOF</em> ::= <em>HxTokenName</em> EOF . */
net.sf.crsx.Sink N_HxTokenName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_RE);} sink=N_HxTokenName(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxTokenName production. */
<HX_RE> TOKEN : {<MT_HxTokenName : "#HxTokenName" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxTokenName production. */
<HX_RE> TOKEN : {<IT_HxTokenName : "%HxTokenName">}

/**
 * <em>HxTokenName</em> ::=   <a href="#T_HX_RE_NAME">HX_RE_NAME</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxTokenName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxTokenName> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxTokenName>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_RE_NAME>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxFragmentRef$WithEOF</em> ::= <em>HxFragmentRef</em> EOF . */
net.sf.crsx.Sink N_HxFragmentRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_RE);} sink=N_HxFragmentRef(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxFragmentRef production. */
<HX_RE> TOKEN : {<MT_HxFragmentRef : "#HxFragmentRef" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxFragmentRef production. */
<HX_RE> TOKEN : {<IT_HxFragmentRef : "%HxFragmentRef">}

/**
 * <em>HxFragmentRef</em> ::=   <a href="#T_HX_FRAGMENT_REF">HX_FRAGMENT_REF</a><font color="red">$:unwrap</font> 
 */
net.sf.crsx.Sink N_HxFragmentRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxFragmentRef> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxFragmentRef>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_FRAGMENT_REF>
	{
		sink = sink .start(makeTConstructor(sink, t, unwrap(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRegExpWord$WithEOF</em> ::= <em>HxRegExpWord</em> EOF . */
net.sf.crsx.Sink N_HxRegExpWord$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_RE);} sink=N_HxRegExpWord(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRegExpWord production. */
<HX_RE> TOKEN : {<MT_HxRegExpWord : "#HxRegExpWord" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRegExpWord production. */
<HX_RE> TOKEN : {<IT_HxRegExpWord : "%HxRegExpWord">}

/**
 * <em>HxRegExpWord</em> ::=  (   <a href="#T_HX_RE_NAME">HX_RE_NAME</a><font color="red">$</font>  |   <a href="#T_HX_RE_WORD">HX_RE_WORD</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_HxRegExpWord(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRegExpWord> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRegExpWord>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		t=<T_HX_RE_NAME>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_RE_WORD>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxLiteral$WithEOF</em> ::= <em>HxLiteral</em> EOF . */
net.sf.crsx.Sink N_HxLiteral$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxLiteral(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxLiteral production. */
TOKEN : {<MT_HxLiteral : "#HxLiteral" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxLiteral production. */
TOKEN : {<IT_HxLiteral : "%HxLiteral">}

/**
 * <em>HxLiteral</em> ::=  (  <a href="#N_HxString">&lang;HxString&rang;</a>   |  <a href="#N_HxNumber">&lang;HxNumber&rang;</a>   ) 
 */
net.sf.crsx.Sink N_HxLiteral(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxLiteral> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxLiteral>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		sink=N_HxString(sink, env)
		 ) 
	|
		 ( 
		sink=N_HxNumber(sink, env)
		 ) 
	 ) 
	{return sink;}
}

/** Special meta-variable for HxNumber production. */
TOKEN : {<MT_HxNumber : "#HxNumber" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxNumber production. */
TOKEN : {<IT_HxNumber : "%HxNumber">}

/**
 * <em>HxNumber</em> ::=  (  <a href="#N_HxNatural">&lang;HxNatural&rang;</a>   |   <a href="#T_HX_UNNATURAL">HX_UNNATURAL</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_HxNumber(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxNumber> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxNumber>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		sink=N_HxNatural(sink, env)
		 ) 
	|
		 ( 
		t=<T_HX_UNNATURAL>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** Special meta-variable for HxNatural production. */
TOKEN : {<MT_HxNatural : "#HxNatural" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxNatural production. */
TOKEN : {<IT_HxNatural : "%HxNatural">}

/**
 * <em>HxNatural</em> ::=   <a href="#T_HX_NATURAL">HX_NATURAL</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxNatural(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxNatural> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxNatural>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_NATURAL>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for HxString production. */
<DEFAULT, HX_RE> TOKEN : {<MT_HxString : "#HxString" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxString production. */
<DEFAULT, HX_RE> TOKEN : {<IT_HxString : "%HxString">}

/**
 * <em>HxString</em> ::=   <a href="#T_HX_STRING">HX_STRING</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxString(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxString> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxString>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_STRING>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxRegExpClass$WithEOF</em> ::= <em>HxRegExpClass</em> EOF . */
net.sf.crsx.Sink N_HxRegExpClass$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_RE);} sink=N_HxRegExpClass(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxRegExpClass production. */
<HX_RE> TOKEN : {<MT_HxRegExpClass : "#HxRegExpClass" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxRegExpClass production. */
<HX_RE> TOKEN : {<IT_HxRegExpClass : "%HxRegExpClass">}

/**
 * <em>HxRegExpClass</em> ::=   <a href="#T_HX_CHAR_CLASS">HX_CHAR_CLASS</a><font color="red">$$:unwrap:{rawHxCC}</font> 
 */
net.sf.crsx.Sink N_HxRegExpClass(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxRegExpClass> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxRegExpClass>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_CHAR_CLASS>
	{
		try {sink = factory.parser(factory).parse(sink, "rawHxCC", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

/** <em>HxCC$WithEOF</em> ::= <em>HxCC</em> EOF . */
net.sf.crsx.Sink N_HxCC$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_CC);} sink=N_HxCC(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxCC production. */
<HX_CC> TOKEN : {<MT_HxCC : "#HxCC" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxCC production. */
<HX_CC> TOKEN : {<IT_HxCC : "%HxCC">}

/**
 * <em>HxCC</em> ::=  <a href="#N_HxCC_RangesTop">&lang;HxCC_RangesTop&rang;</a>  
 */
net.sf.crsx.Sink N_HxCC(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxCC> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxCC>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	sink=N_HxCC_RangesTop(sink, env)
	 ) 
	{return sink;}
}

/** <em>HxCC_RangesTop$WithEOF</em> ::= <em>HxCC_RangesTop</em> EOF . */
net.sf.crsx.Sink N_HxCC_RangesTop$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_CC);} sink=N_HxCC_RangesTop(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxCC_RangesTop production. */
<HX_CC> TOKEN : {<MT_HxCC_RangesTop : "#HxCC_RangesTop" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxCC_RangesTop production. */
<HX_CC> TOKEN : {<IT_HxCC_RangesTop : "%HxCC_RangesTop">}

/**
 * <em>HxCC_RangesTop</em> ::=  <font color="red">{RegExpClassNot}</font><font color="red">:hx</font>    <a href="#T_HX_CC_NOT">HX_CC_NOT</a>   <a href="#N_HxCC_FirstRangeStartChar">&lang;HxCC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo&rang;</a>   <br>
 *  |  <a href="#N_HxCC_FirstRangeStartChar">&lang;HxCC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo&rang;</a>   <br>
 *  |   <a href="#T_HX_CC_SKIP">HX_CC_SKIP</a>   <a href="#N_HxCC_RangesTop">&lang;HxCC_RangesTop&rang;</a>  
 */
net.sf.crsx.Sink N_HxCC_RangesTop(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink s1 = null;
	net.sf.crsx.Sink bs__lo = null;
	net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_HxCC_RangesTop> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxCC_RangesTop>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassNot"), null)) ;
	}
	 ) 
	 ( 
	 <T_HX_CC_NOT>
	 ) 
	 ( 
	{
		bs__lo = b__lo.sink();
	}
	N_HxCC_FirstRangeStartChar(bs__lo, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, true) ;
	}
	sink=N_HxCC_RangeTail(sink, env, b1)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		bs__lo = b__lo.sink();
	}
	N_HxCC_FirstRangeStartChar(bs__lo, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, true) ;
	}
	sink=N_HxCC_RangeTail(sink, env, b1)
	 ) 
	{return sink;}
 |
	 ( 
	 <T_HX_CC_SKIP>
	 ) 
	 ( 
	sink=N_HxCC_RangesTop(sink, env)
	 ) 
	{return sink;}
}

/** <em>HxCC_Ranges$WithEOF</em> ::= <em>HxCC_Ranges</em> EOF . */
net.sf.crsx.Sink N_HxCC_Ranges$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_CC);} sink=N_HxCC_Ranges(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxCC_Ranges production. */
<HX_CC> TOKEN : {<MT_HxCC_Ranges : "#HxCC_Ranges" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxCC_Ranges production. */
<HX_CC> TOKEN : {<IT_HxCC_Ranges : "%HxCC_Ranges">}

/**
 * <em>HxCC_Ranges</em> ::=  <a href="#N_HxCC_RangeChar">&lang;HxCC_RangeChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo&rang;</a>   <br>
 *  |   <a href="#T_HX_CC_SKIP">HX_CC_SKIP</a>   <a href="#N_HxCC_Ranges">&lang;HxCC_Ranges&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassDone}</font><font color="red">:hx</font> 
 */
net.sf.crsx.Sink N_HxCC_Ranges(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
	net.sf.crsx.Sink s1 = null;
	net.sf.crsx.Sink bs__lo = null;
	net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_HxCC_Ranges> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxCC_Ranges>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		bs__lo = b__lo.sink();
	}
	N_HxCC_RangeChar(bs__lo, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, true) ;
	}
	sink=N_HxCC_RangeTail(sink, env, b1)
	 ) 
	{return sink;}
 |
	 ( 
	 <T_HX_CC_SKIP>
	 ) 
	 ( 
	sink=N_HxCC_Ranges(sink, env)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** Special meta-variable for HxCC_RangeTail production. */
<HX_CC> TOKEN : {<MT_HxCC_RangeTail : "#HxCC_RangeTail" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxCC_RangeTail production. */
<HX_CC> TOKEN : {<IT_HxCC_RangeTail : "%HxCC_RangeTail">}

/**
 * <em>HxCC_RangeTail</em> ::=   <a href="#T_HX_CC_DASH">HX_CC_DASH</a>   (  <font color="red">{RegExpClassRange}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <a href="#N_HxCC_RangeChar">&lang;HxCC_RangeChar&rang;</a>    <a href="#N_HxCC_Ranges">&lang;HxCC_Ranges&rang;</a>   |  <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:hx</font>  )  <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <a href="#N_HxCC_NonDashRangeStartChar">&lang;HxCC_NonDashRangeStartChar&rang;</a> <font color="red">:#lo2</font>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo2&rang;</a>   <br>
 *  |   <a href="#T_HX_CC_SKIP">HX_CC_SKIP</a>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:hx</font> 
 */
net.sf.crsx.Sink N_HxCC_RangeTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__lo) :
{
	Token t = null;
	net.sf.crsx.Sink s1 = null;
	net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Sink bs__lo2 = null;
	net.sf.crsx.util.Buffer b__lo2 = new net.sf.crsx.util.Buffer(sink);
}
{
	t=<MT_HxCC_RangeTail> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxCC_RangeTail>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	 <T_HX_CC_DASH>
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassRange"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__lo, false) ;
		}
		 ) 
		 ( 
		sink=N_HxCC_RangeChar(sink, env)
		 ) 
		 ( 
		sink=N_HxCC_Ranges(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__lo, false) ;
		}
		 ) 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
		}
		 ) 
		{
			sink = sink .end().end() ;
		}
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .copy(b__lo, false) ;
	}
	 ) 
	 ( 
	{
		bs__lo2 = b__lo2.sink();
	}
	N_HxCC_NonDashRangeStartChar(bs__lo2, env)
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo2, true) ;
	}
	sink=N_HxCC_RangeTail(sink, env, b1)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	 <T_HX_CC_SKIP>
	 ) 
	 ( 
	{
		s1 = b1.sink();
		s1 .copy(b__lo, false) ;
	}
	sink=N_HxCC_RangeTail(sink, env, b1)
	 ) 
	{return sink;}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
	}
	 ) 
	 ( 
	{
		sink = sink .copy(b__lo, false) ;
	}
	 ) 
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
	}
	 ) 
	{
		return sink .end().end() ;
	}
}

/** <em>HxCC_FirstRangeStartChar$WithEOF</em> ::= <em>HxCC_FirstRangeStartChar</em> EOF . */
net.sf.crsx.Sink N_HxCC_FirstRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_CC);} sink=N_HxCC_FirstRangeStartChar(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxCC_FirstRangeStartChar production. */
<HX_CC> TOKEN : {<MT_HxCC_FirstRangeStartChar : "#HxCC_FirstRangeStartChar" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxCC_FirstRangeStartChar production. */
<HX_CC> TOKEN : {<IT_HxCC_FirstRangeStartChar : "%HxCC_FirstRangeStartChar">}

/**
 * <em>HxCC_FirstRangeStartChar</em> ::=  (   <a href="#T_HX_CC_RBRACKET">HX_CC_RBRACKET</a><font color="red">$</font>  |   <a href="#T_HX_CC_DASH">HX_CC_DASH</a><font color="red">$</font>  |   <a href="#T_HX_CC_OTHER">HX_CC_OTHER</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_HxCC_FirstRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxCC_FirstRangeStartChar> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxCC_FirstRangeStartChar>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		t=<T_HX_CC_RBRACKET>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_CC_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_CC_OTHER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxCC_NonDashRangeStartChar$WithEOF</em> ::= <em>HxCC_NonDashRangeStartChar</em> EOF . */
net.sf.crsx.Sink N_HxCC_NonDashRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_CC);} sink=N_HxCC_NonDashRangeStartChar(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxCC_NonDashRangeStartChar production. */
<HX_CC> TOKEN : {<MT_HxCC_NonDashRangeStartChar : "#HxCC_NonDashRangeStartChar" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxCC_NonDashRangeStartChar production. */
<HX_CC> TOKEN : {<IT_HxCC_NonDashRangeStartChar : "%HxCC_NonDashRangeStartChar">}

/**
 * <em>HxCC_NonDashRangeStartChar</em> ::=  (   <a href="#T_HX_CC_NOT">HX_CC_NOT</a><font color="red">$</font>  |   <a href="#T_HX_CC_OTHER">HX_CC_OTHER</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_HxCC_NonDashRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxCC_NonDashRangeStartChar> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxCC_NonDashRangeStartChar>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		t=<T_HX_CC_NOT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_CC_OTHER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxCC_RangeChar$WithEOF</em> ::= <em>HxCC_RangeChar</em> EOF . */
net.sf.crsx.Sink N_HxCC_RangeChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_CC);} sink=N_HxCC_RangeChar(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxCC_RangeChar production. */
<HX_CC> TOKEN : {<MT_HxCC_RangeChar : "#HxCC_RangeChar" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxCC_RangeChar production. */
<HX_CC> TOKEN : {<IT_HxCC_RangeChar : "%HxCC_RangeChar">}

/**
 * <em>HxCC_RangeChar</em> ::=  (   <a href="#T_HX_CC_NOT">HX_CC_NOT</a><font color="red">$</font>  |   <a href="#T_HX_CC_DASH">HX_CC_DASH</a><font color="red">$</font>  |   <a href="#T_HX_CC_OTHER">HX_CC_OTHER</a><font color="red">$</font>  ) 
 */
net.sf.crsx.Sink N_HxCC_RangeChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxCC_RangeChar> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxCC_RangeChar>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
		 ( 
		t=<T_HX_CC_NOT>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_CC_DASH>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		t=<T_HX_CC_OTHER>
		{
			sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

/** <em>HxParsedForm$WithEOF</em> ::= <em>HxParsedForm</em> EOF . */
net.sf.crsx.Sink N_HxParsedForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxParsedForm(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxParsedForm production. */
TOKEN : {<MT_HxParsedForm : "#HxParsedForm" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxParsedForm production. */
TOKEN : {<IT_HxParsedForm : "%HxParsedForm">}

/**
 * <em>HxParsedForm</em> ::=   <a href="#T_HX_CONCRETE">HX_CONCRETE</a><font color="red">$$:unwrap:{rawHxPP}</font> 
 */
net.sf.crsx.Sink N_HxParsedForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxParsedForm> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxParsedForm>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_CONCRETE>
	{
		try {sink = factory.parser(factory).parse(sink, "rawHxPP", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

/** <em>HxPP$WithEOF</em> ::= <em>HxPP</em> EOF . */
net.sf.crsx.Sink N_HxPP$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_PP);} sink=N_HxPP(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxPP production. */
<HX_PP> TOKEN : {<MT_HxPP : "#HxPP" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxPP production. */
<HX_PP> TOKEN : {<IT_HxPP : "%HxPP">}

/**
 * <em>HxPP</em> ::=  <font color="red">{ParsedFormSpace}</font><font color="red">:hx</font>   <a href="#N_HxPPConcreteSpace">&lang;HxPPConcreteSpace&rang;</a>    <a href="#N_HxPP">&lang;HxPP&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormWord}</font><font color="red">:hx</font>   <a href="#N_HxPPConcreteWord">&lang;HxPPConcreteWord&rang;</a>    <a href="#N_HxPP">&lang;HxPP&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormTerm}</font><font color="red">:hx</font>   <a href="#N_HxPPUnconcrete">&lang;HxPPUnconcrete&rang;</a>    <a href="#N_HxPP">&lang;HxPP&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormDone}</font><font color="red">:hx</font> 
 */
net.sf.crsx.Sink N_HxPP(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxPP> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxPP>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormSpace"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxPPConcreteSpace(sink, env)
	 ) 
	 ( 
	sink=N_HxPP(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormWord"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxPPConcreteWord(sink, env)
	 ) 
	 ( 
	sink=N_HxPP(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormTerm"), null)) ;
	}
	 ) 
	 ( 
	sink=N_HxPPUnconcrete(sink, env)
	 ) 
	 ( 
	sink=N_HxPP(sink, env)
	 ) 
	{
		return sink .end() ;
	}
 |
	 ( 
	{
		sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormDone"), null)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxPPConcreteSpace$WithEOF</em> ::= <em>HxPPConcreteSpace</em> EOF . */
net.sf.crsx.Sink N_HxPPConcreteSpace$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_PP);} sink=N_HxPPConcreteSpace(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxPPConcreteSpace production. */
<HX_PP> TOKEN : {<MT_HxPPConcreteSpace : "#HxPPConcreteSpace" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxPPConcreteSpace production. */
<HX_PP> TOKEN : {<IT_HxPPConcreteSpace : "%HxPPConcreteSpace">}

/**
 * <em>HxPPConcreteSpace</em> ::=   <a href="#T_HX_PP_CONCRETE_SPACE">HX_PP_CONCRETE_SPACE</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxPPConcreteSpace(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxPPConcreteSpace> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxPPConcreteSpace>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_PP_CONCRETE_SPACE>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxPPConcreteWord$WithEOF</em> ::= <em>HxPPConcreteWord</em> EOF . */
net.sf.crsx.Sink N_HxPPConcreteWord$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_PP);} sink=N_HxPPConcreteWord(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxPPConcreteWord production. */
<HX_PP> TOKEN : {<MT_HxPPConcreteWord : "#HxPPConcreteWord" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxPPConcreteWord production. */
<HX_PP> TOKEN : {<IT_HxPPConcreteWord : "%HxPPConcreteWord">}

/**
 * <em>HxPPConcreteWord</em> ::=   <a href="#T_HX_PP_CONCRETE_WORD">HX_PP_CONCRETE_WORD</a><font color="red">$</font> 
 */
net.sf.crsx.Sink N_HxPPConcreteWord(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxPPConcreteWord> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxPPConcreteWord>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_PP_CONCRETE_WORD>
	{
		sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
	}
	 ) 
	{
		return sink .end() ;
	}
}

/** <em>HxPPUnconcrete$WithEOF</em> ::= <em>HxPPUnconcrete</em> EOF . */
net.sf.crsx.Sink N_HxPPUnconcrete$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ {token_source.SwitchTo(HX_PP);} sink=N_HxPPUnconcrete(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxPPUnconcrete production. */
<HX_PP> TOKEN : {<MT_HxPPUnconcrete : "#HxPPUnconcrete" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxPPUnconcrete production. */
<HX_PP> TOKEN : {<IT_HxPPUnconcrete : "%HxPPUnconcrete">}

/**
 * <em>HxPPUnconcrete</em> ::=   <a href="#T_HX_PP_UNCONCRETE">HX_PP_UNCONCRETE</a><font color="red">$$:unwrap:{rawHxScopeSortPrec}</font> 
 */
net.sf.crsx.Sink N_HxPPUnconcrete(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	Token t = null;
}
{
	t=<MT_HxPPUnconcrete> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxPPUnconcrete>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	t=<T_HX_PP_UNCONCRETE>
	{
		try {sink = factory.parser(factory).parse(sink, "rawHxScopeSortPrec", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
		catch (java.io.IOException e) {throw new ParseException(e.getMessage());}
		catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) throw (ParseException) cause; else throw new ParseException(e.getMessage());}
	}
	 ) 
	{return sink;}
}

/** <em>HxScopeSortPrec$WithEOF</em> ::= <em>HxScopeSortPrec</em> EOF . */
net.sf.crsx.Sink N_HxScopeSortPrec$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{}
{ sink=N_HxScopeSortPrec(sink, env) <EOF> {return sink;} }

/** Special meta-variable for HxScopeSortPrec production. */
TOKEN : {<MT_HxScopeSortPrec : "#HxScopeSortPrec" ((["0"-"9"])* | "_" (["A"-"Z","a"-"z","0"-"9"])*) "#">}

/** Special inject token HxScopeSortPrec production. */
TOKEN : {<IT_HxScopeSortPrec : "%HxScopeSortPrec">}

/**
 * <em>HxScopeSortPrec</em> ::=  <a href="#N_HxScopeSort">&lang;HxScopeSort&rang;</a> <font color="red">:#S</font>   (  <font color="red">{ScopeSortPrecBind}</font><font color="red">:hx</font>    <a href="#T_HX_BINDS">HX_BINDS</a>   <font color="red">{{#S}}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>  |  <font color="red">{ScopeSortPrec}</font><font color="red">:hx</font>   <font color="red">{{#S}}</font>   <a href="#N_HxFormPrec">&lang;HxFormPrec&rang;</a>   ) 
 */
net.sf.crsx.Sink N_HxScopeSortPrec(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) :
{
	net.sf.crsx.util.Buffer b__S = new net.sf.crsx.util.Buffer(sink);
	net.sf.crsx.Variable v_HxVariable = null;
	Token t = null;
	net.sf.crsx.Sink bs_HxVariable = null;
	String c2 = null;
	net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
	String s_HxVariable = null;
	net.sf.crsx.Sink bs__S = null;
}
{
	t=<MT_HxScopeSortPrec> {sink = sink .startMetaApplication(t.toString());} [ "\u2983" sink=N_HxSortParam(sink, env)( "\u2225" sink=N_HxSortParam(sink, env))* "\u2984" ] {return sink.endMetaApplication();}
|
	<IT_HxScopeSortPrec>  sink=N_HxEmbedded(sink, env)  {return sink;}
|
	 ( 
	{
		bs__S = b__S.sink();
	}
	N_HxScopeSort(bs__S, env)
	 ) 
	 ( 
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("ScopeSortPrecBind"), null)) ;
		}
		 ) 
		 ( 
		 <T_HX_BINDS>
		 ) 
		 ( 
		{
			sink = sink .copy(b__S, true) ;
		}
		 ) 
		 ( 
		{
			bs_HxVariable = b_HxVariable.sink();
		}
		N_HxVariable(bs_HxVariable, env)
		{
			if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
			 throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");
			c2 = b_HxVariable.term(true).constructor().symbol();
			s_HxVariable = c2;
			v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
			if (v_HxVariable == null) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");
			sink = sink .use(v_HxVariable) ;
		}
		 ) 
		{
			sink = sink .end() ;
		}
	|
		 ( 
		{
			sink = sink .start(makeTConstructor(sink, t, hx("ScopeSortPrec"), null)) ;
		}
		 ) 
		 ( 
		{
			sink = sink .copy(b__S, true) ;
		}
		 ) 
		 ( 
		sink=N_HxFormPrec(sink, env)
		 ) 
		{
			sink = sink .end() ;
		}
	 ) 
	{return sink;}
}

// Nested unconcrete token ⟨...⟩ inside PP.
<HX_PP> MORE : { "\u27e8" { nesting = 0; nestedState = curLexState; } : IN_PP_UNCONCRETE }
<IN_PP_UNCONCRETE> MORE : { "\u27e8" { nesting = 1; } : IN_PP_NESTED_UNCONCRETE }
<IN_PP_NESTED_UNCONCRETE> MORE : { "\u27e8" { nesting++; } }
<IN_PP_NESTED_UNCONCRETE> MORE : { "\u27e9" { if (--nesting <= 0) SwitchTo(IN_PP_UNCONCRETE); } }
<IN_PP_UNCONCRETE> TOKEN : { <T_HX_PP_UNCONCRETE : "\u27e9"> { SwitchTo(nestedState); } }
<IN_PP_UNCONCRETE,IN_PP_NESTED_UNCONCRETE> MORE : { < ~[] > }


/**
 * HX_EMBEDDED ::=  "<code>«</code>" (&not;["<code>«</code>","<code>»</code>"])*  "<code>»</code>"
 */
<*> TOKEN : {<T_HX_EMBEDDED : "\253" (~["\253","\273"])* "\273" >}

/**
 * <b>skip</b><font color="red"> (DEFAULT, HX_RE)</font> ::=  "<code> </code>" | <code>&#92;r</code> | <code>&#92;t</code> | <code>&#92;n</code> |  "<code>//</code>" &not;[<code>&#92;n</code><code>&#92;r</code>]* | <code>&#92;u1</code>
 */
<DEFAULT, HX_RE> SKIP : { <" " | "\r" | "\t" | "\n" | "//" (~["\n","\r"])* | "\001"> }

/**
 * HX_SEMI ::=  "<code>;</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_SEMI : ";" >: DEFAULT}

/**
 * HX_BAR ::=  "<code>|</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_BAR : "|" >}

/**
 * HX_LPAREN ::=  "<code>(</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_LPAREN : "(" >}

/**
 * HX_RPAREN ::=  "<code>)</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_RPAREN : ")" >}

/**
 * HX_STAR ::=  "<code>*</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_STAR : "*" >}

/**
 * HX_PLUS ::=  "<code>+</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_PLUS : "+" >}

/**
 * HX_QUEST ::=  "<code>?</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_QUEST : "?" >}

/**
 * HX_SUB ::=  "<code>_</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_SUB : "_" >}

/**
 * HX_DOT ::=  "<code>.</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_DOT : "." >}

/**
 * HX_COLON ::=  "<code>:</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_COLON : ":" >}

/**
 * HX_LBRACE ::=  "<code>{</code>"
 */
TOKEN : {<T_HX_LBRACE : "{" >}

/**
 * HX_RBRACE ::=  "<code>}</code>"
 */
TOKEN : {<T_HX_RBRACE : "}" >}

/**
 * HX_LBRACKET ::=  "<code>[</code>"
 */
TOKEN : {<T_HX_LBRACKET : "[" >}

/**
 * HX_RBRACKET ::=  "<code>]</code>"
 */
TOKEN : {<T_HX_RBRACKET : "]" >}

/**
 * HX_COMMA ::=  "<code>,</code>"
 */
TOKEN : {<T_HX_COMMA : "," >}

/**
 * HX_FORALL ::= <code>&#92;u2200</code>
 */
TOKEN : {<T_HX_FORALL : "\u2200" >}

/**
 * HX_ARROW ::= <code>&#92;u2192</code>
 */
TOKEN : {<T_HX_ARROW : "\u2192" >}

/**
 * HX_UP ::= <code>&#92;u2191</code>
 */
TOKEN : {<T_HX_UP : "\u2191" >}

/**
 * HX_DOWN ::= <code>&#92;u2193</code>
 */
TOKEN : {<T_HX_DOWN : "\u2193" >}

/**
 * HX_NOT ::= <code>&#92;u00ac</code>
 */
TOKEN : {<T_HX_NOT : "\254" >}

/**
 * HX_AT ::=  "<code>@</code>"
 */
TOKEN : {<T_HX_AT : "@" >}

/**
 * HX_DOTTEDNAME ::= ([<code>a-z</code>] [<code>A-Za-z0-9</code><code>_</code><code>$</code>]* HX_DOT)+ [<code>A-Z</code>] [<code>A-Za-z0-9</code><code>_</code><code>$</code>]*
 */
TOKEN : {<T_HX_DOTTEDNAME : (["a"-"z"] (["A"-"Z","a"-"z","0"-"9","_","$"])* <T_HX_DOT>)+ ["A"-"Z"] (["A"-"Z","a"-"z","0"-"9","_","$"])* >}

/**
 * HX_MODULE ::=  "<code>module</code>"
 */
TOKEN : {<T_HX_MODULE : "module" >}

/**
 * HX_SORT ::=  "<code>sort</code>"
 */
TOKEN : {<T_HX_SORT : "sort" >}

/**
 * HX_MAIN ::=  "<code>main</code>"
 */
TOKEN : {<T_HX_MAIN : "main" >}

/**
 * HX_DATA ::=  "<code>data</code>"
 */
TOKEN : {<T_HX_DATA : "data" >}

/**
 * HX_SCHEME ::=  "<code>scheme</code>"
 */
TOKEN : {<T_HX_SCHEME : "scheme" >}

/**
 * HX_AUTOMATIC ::=  "<code>automatic</code>"
 */
TOKEN : {<T_HX_AUTOMATIC : "automatic" >}

/**
 * HX_SYMBOL ::=  "<code>symbol</code>"
 */
TOKEN : {<T_HX_SYMBOL : "symbol" >}

/**
 * HX_STATIC ::=  "<code>static</code>"
 */
TOKEN : {<T_HX_STATIC : "static" >}

/**
 * HX_ATTRIBUTE ::=  "<code>attribute</code>"
 */
TOKEN : {<T_HX_ATTRIBUTE : "attribute" >}

/**
 * HX_COMPOSE ::=  "<code>compose</code>"
 */
TOKEN : {<T_HX_COMPOSE : "compose" >}

/**
 * HX_SUGAR ::=  "<code>sugar</code>"
 */
TOKEN : {<T_HX_SUGAR : "sugar" >}

/**
 * HX_RULE ::=  "<code>rule</code>"
 */
TOKEN : {<T_HX_RULE : "rule" >}

/**
 * HX_PRIORITY ::=  "<code>priority</code>"
 */
TOKEN : {<T_HX_PRIORITY : "priority" >}

/**
 * HX_DEFAULT ::=  "<code>default</code>"
 */
TOKEN : {<T_HX_DEFAULT : "default" >}

/**
 * HX_IMPORT ::=  "<code>import</code>"
 */
TOKEN : {<T_HX_IMPORT : "import" >}

/**
 * HX_TAG ::=  "<code>tag</code>"
 */
TOKEN : {<T_HX_TAG : "tag" >}

/**
 * HX_BINDS ::=  "<code>binds</code>"
 */
TOKEN : {<T_HX_BINDS : "binds" >}

/**
 * HX_AS ::=  "<code>as</code>"
 */
TOKEN : {<T_HX_AS : "as" >}

/**
 * HX_SPACE ::=  "<code>space</code>"
 */
<DEFAULT> TOKEN : {<T_HX_SPACE : "space" >: HX_RE}

/**
 * HX_TOKEN ::=  "<code>token</code>"
 */
<DEFAULT> TOKEN : {<T_HX_TOKEN : "token" >: HX_RE}

/**
 * HX_FRAGMENT ::=  "<code>fragment</code>"
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_FRAGMENT : "fragment" >: HX_RE}

/**
 * HX_NESTED ::=  "<code>nested</code>"
 */
<HX_RE> TOKEN : {<T_HX_NESTED : "nested" >}

/**
 * HX_FRAGMENT_REF ::= <code>&#92;u27e8</code> HX_RE_NAME <code>&#92;u27e9</code>
 */
<HX_RE> TOKEN : {<T_HX_FRAGMENT_REF : "\u27e8" <T_HX_RE_NAME> "\u27e9" >}

/**
 * HX_RE_NAME ::= [<code>A-Z</code>] [<code>A-Za-z0-9</code><code>_</code><code>$</code>]*
 */
<HX_RE> TOKEN : {<T_HX_RE_NAME : ["A"-"Z"] (["A"-"Z","a"-"z","0"-"9","_","$"])* >}

/**
 * HX_RE_WORD ::= &not;["<code>⟨</code>","<code>⟩</code>","<code>⟦</code>","<code>⟧</code>","<code>(</code>","<code>)</code>","<code>[</code>","<code>]</code>","<code>.</code>","<code>*</code>","<code>+</code>","<code>?</code>","<code>;</code>","<code>"</code>","<code>'</code>","<code>,</code>","<code>:</code>","<code>«</code>","<code>»</code>","<code> </code>",<code>&#92;t</code>,<code>&#92;&#92;</code>,<code>&#92;n</code>]+
 */
<HX_RE> TOKEN : {<T_HX_RE_WORD : (~["\u27e8","\u27e9","\u27e6","\u27e7","(",")","[","]",".","*","+","?",";","\"","\'",",",":","\253","\273"," ","\t","\\","\n"])+ >}

/**
 * HX_META ::= ["<code>#</code>"] [<code>A-Za-z0-9</code><code>_</code><code>$</code>]*
 */
TOKEN : {<T_HX_META : ["#"] (["A"-"Z","a"-"z","0"-"9","_","$"])* >}

/**
 * HX_VAR ::= [<code>a-z</code>] [<code>A-Za-z0-9</code><code>_</code><code>$</code>]*
 */
TOKEN : {<T_HX_VAR : ["a"-"z"] (["A"-"Z","a"-"z","0"-"9","_","$"])* >}

/**
 * HX_NATURAL ::= [<code>0</code>&ndash;<code>9</code>]+
 */
TOKEN : {<T_HX_NATURAL : (["0"-"9"])+ >}

/**
 * HX_INTEGER ::= [&ndash;<code>+</code>]* HX_NATURAL
 */
TOKEN : {<#T_HX_INTEGER : (["-","+"])* <T_HX_NATURAL> >}

/**
 * HX_UNNATURAL ::= (HX_INTEGER?  "<code>.</code>" HX_NATURAL) ([<code>Ee</code>] HX_INTEGER)? | HX_INTEGER [<code>Ee</code>] HX_INTEGER
 */
TOKEN : {<T_HX_UNNATURAL : ((<T_HX_INTEGER>)? "." <T_HX_NATURAL>) (["E","e"] <T_HX_INTEGER>)? | <T_HX_INTEGER> ["E","e"] <T_HX_INTEGER> >}

/**
 * HX_STRING ::= ( "<code>'</code>" HX_STRING1CHAR*  "<code>'</code>" |  "<code>"</code>" HX_STRING2CHAR*  "<code>"</code>")
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_STRING : ("\'" (<T_HX_STRING1CHAR>)* "\'" | "\"" (<T_HX_STRING2CHAR>)* "\"") >}

/**
 * HX_STRING1CHAR ::= (&not;[<code>&#92;&#92;</code><code>'</code><code>&#92;n</code>] | HX_ESCAPEDCHAR)
 */
TOKEN : {<#T_HX_STRING1CHAR : (~["\\","\'","\n"] | <T_HX_ESCAPEDCHAR>) >}

/**
 * HX_STRING2CHAR ::= (&not;[<code>&#92;&#92;</code><code>"</code><code>&#92;n</code>] | HX_ESCAPEDCHAR)
 */
TOKEN : {<#T_HX_STRING2CHAR : (~["\\","\"","\n"] | <T_HX_ESCAPEDCHAR>) >}

/**
 * HX_ESCAPEDCHAR ::= [<code>&#92;&#92;</code>] &not;[<code>0</code>&ndash;<code>9</code><code>ux</code>] | [<code>&#92;&#92;</code>] [<code>0</code>&ndash;<code>3</code>]? [<code>0</code>&ndash;<code>7</code>]? [<code>0</code>&ndash;<code>7</code>] | [<code>&#92;&#92;</code>] [<code>u</code>] HX_HEX? HX_HEX? HX_HEX? HX_HEX | [<code>&#92;&#92;</code>] [<code>x</code>] (HX_HEX HX_HEX |  "<code>{</code>" HX_HEX+  "<code>}</code>")
 */
<DEFAULT, HX_RE> TOKEN : {<T_HX_ESCAPEDCHAR : ["\\"] ~["0"-"9","u","x"] | ["\\"] (["0"-"3"])? (["0"-"7"])? ["0"-"7"] | ["\\"] ["u"] (<T_HX_HEX>)? (<T_HX_HEX>)? (<T_HX_HEX>)? <T_HX_HEX> | ["\\"] ["x"] (<T_HX_HEX> <T_HX_HEX> | "{" (<T_HX_HEX>)+ "}") >}

/**
 * HX_HEX ::= [<code>0</code>&ndash;<code>9</code><code>A-Fa-f</code>]
 */
TOKEN : {<#T_HX_HEX : ["0"-"9","A"-"F","a"-"f"] >}

/**
 * HX_CHAR_CLASS ::=  "<code>[</code>" ( "<code>^</code>")? ( "<code>]</code>")? (&not;["<code>]</code>",<code>&#92;&#92;</code>,<code>&#92;n</code>] | HX_ESCAPEDCHAR)*  "<code>]</code>"
 */
<HX_RE> TOKEN : {<T_HX_CHAR_CLASS : "[" ("^")? ("]")? (~["]","\\","\n"] | <T_HX_ESCAPEDCHAR>)* "]" >}

/**
 * HX_CC_NOT ::=  "<code>^</code>"
 */
<HX_CC> TOKEN : {<T_HX_CC_NOT : "^" >}

/**
 * HX_CC_RBRACKET ::=  "<code>]</code>"
 */
<HX_CC> TOKEN : {<T_HX_CC_RBRACKET : "]" >}

/**
 * HX_CC_DASH ::=  "<code>-</code>"
 */
<HX_CC> TOKEN : {<T_HX_CC_DASH : "-" >}

/**
 * HX_CC_OTHER ::= &not;["<code>^</code>","<code>]</code>","<code>-</code>",<code>&#92;&#92;</code>,<code>&#92;n</code>,<code>&#92;u1</code>] | HX_ESCAPEDCHAR
 */
<HX_CC> TOKEN : {<T_HX_CC_OTHER : ~["^","]","-","\\","\n","\001"] | <T_HX_ESCAPEDCHAR> >}

/**
 * HX_CC_SKIP ::= <code>&#92;u1</code>
 */
<HX_CC> TOKEN : {<T_HX_CC_SKIP : "\001" >}

/**
 * HX_PP_CONCRETE_SPACE ::= ["<code> </code>",<code>&#92;t</code><code>&#92;r</code><code>&#92;n</code>,<code>&#92;ub6</code>]+
 */
<HX_PP> TOKEN : {<T_HX_PP_CONCRETE_SPACE : ([" ","\t","\r","\n","\266"])+ >}

/**
 * HX_PP_CONCRETE_WORD ::= &not;["<code> </code>",<code>&#92;t</code><code>&#92;r</code><code>&#92;n</code><code>&#92;ub6</code><code>&#92;u27e6</code><code>&#92;u27e7</code><code>&#92;u27e8</code><code>&#92;u27e9</code>]+
 */
<HX_PP> TOKEN : {<T_HX_PP_CONCRETE_WORD : (~[" ","\t","\r","\n","\266","\u27e6","\u27e7","\u27e8","\u27e9"])+ >}

/**
 * HX_CONSTRUCTOR ::= [<code>A-Z</code><code>$</code>] [<code>A-Za-z0-9</code><code>_</code><code>$</code>]*
 */
TOKEN : {<T_HX_CONSTRUCTOR : ["A"-"Z","$"] (["A"-"Z","a"-"z","0"-"9","_","$"])* >}
