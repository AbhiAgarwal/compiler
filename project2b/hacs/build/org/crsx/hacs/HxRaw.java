/* HxRaw.java */
/* Generated By:JavaCC: Do not edit this line. HxRaw.java */
package org.crsx.hacs;

public class HxRaw implements net.sf.crsx.Parser, HxRawConstants {
        /** Factory. */
        net.sf.crsx.Factory<? extends net.sf.crsx.Term> factory;
        /** Compilation unit name for error messages. */
        String unit;
        /** Whether the parser should capture token locations. */
        boolean captureLocations = true;
        /** Constructor with token location information. */
        private net.sf.crsx.Constructor makeTConstructor(net.sf.crsx.Sink sink, Token t, Object object, String sort)
        {
                net.sf.crsx.Constructor c = sort == null ? sink.makeConstructor(object) : sink.makeLiteral(object, sort);
                if (t == null) t = token;
                if (captureLocations && t != null)
                {
                        if (factory.get("meta") == null)
                                c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn);
                }
                return c;
        }

        /** Helper interface with category non-terminal calls. */
        abstract class CategoryCall { abstract net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException; }
        /** Direct category invocations. */
        java.util.Map<String,CategoryCall> categoryCall = new java.util.HashMap<String,CategoryCall>();
        {
                categoryCall.put("raw", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxModule$WithEOF(sink, bound);} });
                categoryCall.put("rawHxModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxModule$WithEOF(sink, bound);} });
                categoryCall.put("rawHxModuleName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxModuleName$WithEOF(sink, bound);} });
                categoryCall.put("rawHxEmbeddedModule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxEmbeddedModule$WithEOF(sink, bound);} });
                categoryCall.put("rawHxDeclaration", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxDeclaration$WithEOF(sink, bound);} });
                categoryCall.put("rawHxDeclarations", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxDeclarations$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSortAbstraction", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortAbstraction$WithEOF(sink, bound);} });
                categoryCall.put("rawHxMainKind", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxMainKind$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRule", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRule$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRulePrefix", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRulePrefix$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRulePriority", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRulePriority$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRuleOptions", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRuleOptions$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSort$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSortParam", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortParam$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSortNames", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortNames$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSimpleSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSimpleSort$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSimpleSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSimpleSorts$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSubstituteSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSubstituteSorts$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSubstituteSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSubstituteSort$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSortAlternative", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortAlternative$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSortAlternatives", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortAlternatives$WithEOF(sink, bound);} });
                categoryCall.put("rawHxForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxForm$WithEOF(sink, bound);} });
                categoryCall.put("rawHxFormPrec", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxFormPrec$WithEOF(sink, bound);} });
                categoryCall.put("rawHxParsedForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxParsedForm$WithEOF(sink, bound);} });
                categoryCall.put("rawHxInheritedRefs", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxInheritedRefs$WithEOF(sink, bound);} });
                categoryCall.put("rawHxInheritedRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxInheritedRef$WithEOF(sink, bound);} });
                categoryCall.put("rawHxAttributeKind", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributeKind$WithEOF(sink, bound);} });
                categoryCall.put("rawHxAttributeForm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributeForm$WithEOF(sink, bound);} });
                categoryCall.put("rawHxBindersScopeSorts", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxBindersScopeSorts$WithEOF(sink, bound);} });
                categoryCall.put("rawHxBindersScopeSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxBindersScopeSort$WithEOF(sink, bound);} });
                categoryCall.put("rawHxScopeSort", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxScopeSort$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRepeat", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRepeat$WithEOF(sink, bound);} });
                categoryCall.put("rawHxTokenName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTokenName$WithEOF(sink, bound);} });
                categoryCall.put("rawHxFragmentRef", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxFragmentRef$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRegExp", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExp$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRegExpChoice", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpChoice$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRegExpUnits", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpUnits$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRegExpUnit", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpUnit$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRegExpSimple", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpSimple$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRegExpSub", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpSub$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSeparator", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSeparator$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRegExpWord", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpWord$WithEOF(sink, bound);} });
                categoryCall.put("rawHxLiteral", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxLiteral$WithEOF(sink, bound);} });
                categoryCall.put("rawHxMetaVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxMetaVariable$WithEOF(sink, bound);} });
                categoryCall.put("rawHxMetaVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxMetaVariables$WithEOF(sink, bound);} });
                categoryCall.put("rawHxVariable", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxVariable$WithEOF(sink, bound);} });
                categoryCall.put("rawHxAttributeName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributeName$WithEOF(sink, bound);} });
                categoryCall.put("rawHxRegExpClass", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxRegExpClass$WithEOF(sink, bound);} });
                categoryCall.put("rawHxCC", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC$WithEOF(sink, bound);} });
                categoryCall.put("rawHxCC_RangesTop", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_RangesTop$WithEOF(sink, bound);} });
                categoryCall.put("rawHxCC_Ranges", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_Ranges$WithEOF(sink, bound);} });
                categoryCall.put("rawHxCC_FirstRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_FirstRangeStartChar$WithEOF(sink, bound);} });
                categoryCall.put("rawHxCC_NonDashRangeStartChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_NonDashRangeStartChar$WithEOF(sink, bound);} });
                categoryCall.put("rawHxCC_RangeChar", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxCC_RangeChar$WithEOF(sink, bound);} });
                categoryCall.put("rawHxPP", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPP$WithEOF(sink, bound);} });
                categoryCall.put("rawHxPPConcreteSpace", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPPConcreteSpace$WithEOF(sink, bound);} });
                categoryCall.put("rawHxPPConcreteSpace", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPPConcreteSpace$WithEOF(sink, bound);} });
                categoryCall.put("rawHxPPConcreteWord", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPPConcreteWord$WithEOF(sink, bound);} });
                categoryCall.put("rawHxPPUnconcrete", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxPPUnconcrete$WithEOF(sink, bound);} });
                categoryCall.put("rawHxScopeSortPrec", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxScopeSortPrec$WithEOF(sink, bound);} });
                categoryCall.put("rawHxTopTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTopTerm$WithEOF(sink, bound);} });
                categoryCall.put("rawHxTopPattern", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTopPattern$WithEOF(sink, bound);} });
                categoryCall.put("rawHxAttributes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributes$WithEOF(sink, bound);} });
                categoryCall.put("rawHxSortName", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxSortName$WithEOF(sink, bound);} });
                categoryCall.put("rawHxConstructor", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxConstructor$WithEOF(sink, bound);} });
                categoryCall.put("rawHxTerms", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTerms$WithEOF(sink, bound);} });
                categoryCall.put("rawHxTerm", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxTerm$WithEOF(sink, bound);} });
                categoryCall.put("rawHxVariables", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxVariables$WithEOF(sink, bound);} });
                categoryCall.put("rawHxAttribute", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttribute$WithEOF(sink, bound);} });
                categoryCall.put("rawHxAttributeValue", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxAttributeValue$WithEOF(sink, bound);} });
                categoryCall.put("rawHxScopes", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxScopes$WithEOF(sink, bound);} });
                categoryCall.put("rawHxScope", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxScope$WithEOF(sink, bound);} });
                categoryCall.put("rawHxConcrete", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxConcrete$WithEOF(sink, bound);} });
                categoryCall.put("rawHxConcreteText", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_HxConcreteText$WithEOF(sink, bound);} });
        }

        // Constructor.

        /** Construct dummy instance. */
        public HxRaw()
        {
                this((java.io.Reader) null);
                disable_tracing();
        }

        // Parser implementation.

        public net.sf.crsx.Parser parser(net.sf.crsx.Factory<? extends net.sf.crsx.Term> f)
        {
                if (factory != null)
                {
                        net.sf.crsx.Parser parser = new HxRaw().parser(f);
                        parser.setParserVerbose(trace_enabled); parser.setParserLocation(captureLocations);
                        return parser;
                }
                else
                {
                        factory = f;
                        assert f != null : "Or Else!";
                        return this;
                }
        }

        public void setParserVerbose(boolean verbose)
        {
                if (verbose)
                        enable_tracing();
                else
                        disable_tracing();
        }

        public void setParserLocation(boolean capture)
        {
                captureLocations = capture;
        }

        public void setEmbeddedParser(net.sf.crsx.Parser subparser) throws net.sf.crsx.CRSException
        {}

        public Iterable<String> categories()
        {
                return categoryCall.keySet();
        }

        public net.sf.crsx.Sink parse(net.sf.crsx.Sink sink, String category, java.io.Reader reader, String unit, int firstLine, int firstColumn, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                try
                {
                        this.unit = unit;
                        ReInit((java.io.Reader) null);
                        jj_input_stream.ReInit(reader, firstLine, firstColumn); token_source = new HxRawTokenManager(jj_input_stream); // hacks to update line and column numbers
                        if (bound == null) bound = new net.sf.crsx.util.LinkedExtensibleMap<String, net.sf.crsx.Variable>();
                        if (category == null || category.length() == 0) return N_HxModule(sink, bound);
                        else if (categoryCall.containsKey(category)) return categoryCall.get(category).call(sink, bound);
                        else throw new net.sf.crsx.CRSException("Parser category '"+category+"' not supported!");
                }
                catch (ParseException e)
                {
                        throw new net.sf.crsx.CRSException(e.getMessage());
                }
        }

        public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
                parse(buffer.sink(), category, reader, null, 1, 1, bound);
                return buffer.term(true);
        }


static String hx(String s) {return "Hx_"+s;} // prefix for constructors
static String unwrap(String s) {return s.substring(1, s.length()-1);}
static String checkModuleString(String s) throws ParseException {if (java.util.regex.Pattern.matches("[\u005c"]([a-z0-9]+[.])*[A-Z][A-Za-z0-9]*[\u005c"]", s)) return s; else throw new ParseException("Illegal module name "+s);}
private String storedSort = "";

        /**
	 * Run the parser and print the resulting term.
	 * @param args should contain two strings: the category and an input file name
	 */
        public static void main(String[] args)
        {
                try
                {
                        if (args.length != 2)
                        {
                                System.err.println("Usage: HxRaw category input");
                                System.exit(2);
                        }
                        String category = args[0];
                        java.io.Reader reader = new java.io.FileReader(args[1]);
                        net.sf.crsx.Factory<net.sf.crsx.generic.GenericTerm> factory = new net.sf.crsx.generic.GenericFactory();
                        net.sf.crsx.Parser parser = new HxRaw();
                        net.sf.crsx.Sink sink = factory.sink(System.out);
                        parser.parser(factory).parse(sink, category, reader, null, 1, 1, null);
                }
                catch (net.sf.crsx.CRSException e)
                {
                        System.err.println("CRS error: "+e);
                        System.exit(1);
                }
                catch (java.io.IOException e)
                {
                        System.err.println("I/O error: "+e);
                        System.exit(1);
                }
        }

/**
 * <em>HxEmbedded</em> ::=   <a href="#T_HX_EMBEDDED">HX_EMBEDDED</a><font color="red">$$:unwrap</font> 
 */
  final public net.sf.crsx.Sink N_HxEmbedded(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxEmbedded");
    try {Token t = null;
      t = jj_consume_token(T_HX_EMBEDDED);
try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxEmbedded");
    }
  }

/** <em>HxModule$WithEOF</em> ::= <em>HxModule</em> EOF . */
  final public net.sf.crsx.Sink N_HxModule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxModule$WithEOF");
    try {
      sink = N_HxModule(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxModule$WithEOF");
    }
  }

/**
 * <em>HxModule</em> ::=  <font color="red">{top-module}</font><font color="red">:hx</font>   <a href="#N_HxEmbeddedModule">&lang;HxEmbeddedModule&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxModule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxModule");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxModule:{
        t = jj_consume_token(MT_HxModule);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_1:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[0] = jj_gen;
              break label_1;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[1] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxModule:{
        jj_consume_token(IT_HxModule);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxEmbeddedModule:
      case IT_HxEmbeddedModule:
      case T_HX_MODULE:{
sink = sink .start(makeTConstructor(sink, t, hx("top-module"), null)) ;
        sink = N_HxEmbeddedModule(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxModule");
    }
  }

/** <em>HxEmbeddedModule$WithEOF</em> ::= <em>HxEmbeddedModule</em> EOF . */
  final public net.sf.crsx.Sink N_HxEmbeddedModule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxEmbeddedModule$WithEOF");
    try {
      sink = N_HxEmbeddedModule(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxEmbeddedModule$WithEOF");
    }
  }

/**
 * <em>HxEmbeddedModule</em> ::=   <a href="#T_HX_MODULE">HX_MODULE</a><font color="red">:hx</font>   <a href="#N_HxModuleName">&lang;HxModuleName&rang;</a>     <a href="#T_HX_LBRACE">HX_LBRACE</a>   <a href="#N_Restoring_HxDeclarations">&lang;Restoring_HxDeclarations&rang;</a>     <a href="#T_HX_RBRACE">HX_RBRACE</a> 
 */
  final public net.sf.crsx.Sink N_HxEmbeddedModule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxEmbeddedModule");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxEmbeddedModule:{
        t = jj_consume_token(MT_HxEmbeddedModule);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_2:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[3] = jj_gen;
              break label_2;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[4] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxEmbeddedModule:{
        jj_consume_token(IT_HxEmbeddedModule);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_MODULE:{
        t = jj_consume_token(T_HX_MODULE);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
        sink = N_HxModuleName(sink, env);
        jj_consume_token(T_HX_LBRACE);
        sink = N_Restoring_HxDeclarations(sink, env);
        jj_consume_token(T_HX_RBRACE);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxEmbeddedModule");
    }
  }

/** <em>HxDeclarations$WithEOF</em> ::= <em>HxDeclarations</em> EOF . */
  final public net.sf.crsx.Sink N_HxDeclarations$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxDeclarations$WithEOF");
    try {
      sink = N_HxDeclarations(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxDeclarations$WithEOF");
    }
  }

/**
 * <em>HxDeclarations</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_HxDeclaration">&lang;HxDeclaration&rang;</a>    <a href="#N_HxDeclarations">&lang;HxDeclarations&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxDeclarations(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxDeclarations");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxDeclarations:{
        t = jj_consume_token(MT_HxDeclarations);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_3:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[6] = jj_gen;
              break label_3;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[7] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxDeclarations:{
        jj_consume_token(IT_HxDeclarations);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[9] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxEmbeddedModule:
        case IT_HxEmbeddedModule:
        case MT_HxDeclaration:
        case IT_HxDeclaration:
        case MT_HxMainKind:
        case IT_HxMainKind:
        case MT_HxSortAlternatives:
        case IT_HxSortAlternatives:
        case MT_HxSortAlternative:
        case IT_HxSortAlternative:
        case MT_HxRule:
        case IT_HxRule:
        case MT_HxRulePrefix:
        case IT_HxRulePrefix:
        case MT_HxRulePriority:
        case IT_HxRulePriority:
        case MT_HxTopPattern:
        case IT_HxTopPattern:
        case MT_HxConstructor:
        case IT_HxConstructor:
        case MT_HxPattern:
        case IT_HxPattern:
        case MT_HxConcrete:
        case IT_HxConcrete:
        case T_HX_CONCRETE:
        case MT_HxLiteral:
        case IT_HxLiteral:
        case MT_HxNumber:
        case IT_HxNumber:
        case MT_HxNatural:
        case IT_HxNatural:
        case MT_HxString:
        case IT_HxString:
        case T_HX_SEMI:
        case T_HX_BAR:
        case T_HX_LBRACE:
        case T_HX_LBRACKET:
        case T_HX_MODULE:
        case T_HX_SORT:
        case T_HX_MAIN:
        case T_HX_ATTRIBUTE:
        case T_HX_RULE:
        case T_HX_PRIORITY:
        case T_HX_DEFAULT:
        case T_HX_IMPORT:
        case T_HX_SPACE:
        case T_HX_TOKEN:
        case T_HX_FRAGMENT:
        case T_HX_NATURAL:
        case T_HX_UNNATURAL:
        case T_HX_STRING:
        case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
          sink = N_HxDeclaration(sink, env);
          sink = N_HxDeclarations(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[8] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxDeclarations");
    }
  }

/** <em>HxDeclaration$WithEOF</em> ::= <em>HxDeclaration</em> EOF . */
  final public net.sf.crsx.Sink N_HxDeclaration$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxDeclaration$WithEOF");
    try {
      sink = N_HxDeclaration(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxDeclaration$WithEOF");
    }
  }

/**
 * <em>HxDeclaration</em> ::=  <font color="red">{embedded-module}</font><font color="red">:hx</font>   <a href="#N_HxEmbeddedModule">&lang;HxEmbeddedModule&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_IMPORT">HX_IMPORT</a><font color="red">:hx</font>   <a href="#N_HxModuleName">&lang;HxModuleName&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_SPACE">HX_SPACE</a><font color="red">:hx</font>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_TOKEN">HX_TOKEN</a>   (  <font color="red">{'token'}</font><font color="red">:hx</font>   <a href="#N_HxTokenName">&lang;HxTokenName&rang;</a>     <a href="#T_HX_BAR">HX_BAR</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>   |   <a href="#T_HX_FRAGMENT">HX_FRAGMENT</a><font color="red">:hx</font>   <a href="#N_HxTokenName">&lang;HxTokenName&rang;</a>     <a href="#T_HX_BAR">HX_BAR</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>   )    <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_FRAGMENT">HX_FRAGMENT</a><font color="red">:hx</font>   <a href="#N_HxTokenName">&lang;HxTokenName&rang;</a>     <a href="#T_HX_BAR">HX_BAR</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |   <a href="#T_HX_ATTRIBUTE">HX_ATTRIBUTE</a><font color="red">:hx</font>   <a href="#N_HxAttributeKind">&lang;HxAttributeKind&rang;</a>    <a href="#N_HxAttributeName">&lang;HxAttributeName&rang;</a>    <a href="#N_HxAttributeForm">&lang;HxAttributeForm&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |  <font color="red">{sort}</font><font color="red">:hx</font>   <a href="#N_HxMainKind">&lang;HxMainKind&rang;</a>     <a href="#T_HX_SORT">HX_SORT</a>   <a href="#N_Store_HxSortName">&lang;Store_HxSortName&rang;</a>    <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a>    <a href="#N_HxSortAbstraction">&lang;HxSortAbstraction&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |  <font color="red">{anonymous}</font><font color="red">:hx</font>   <a href="#N_HxSortAlternatives">&lang;HxSortAlternatives&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |  (   <a href="#T_HX_RULE">HX_RULE</a>  )?   <font color="red">{rule}</font><font color="red">:hx</font>   <a href="#N_HxRule">&lang;HxRule&rang;</a>     <a href="#T_HX_SEMI">HX_SEMI</a>  <br>
 *  |  <font color="red">{nestedDeclarations}</font><font color="red">:hx</font>    <a href="#T_HX_LBRACE">HX_LBRACE</a>   <a href="#N_HxDeclarations">&lang;HxDeclarations&rang;</a>     <a href="#T_HX_RBRACE">HX_RBRACE</a> 
 */
  final public net.sf.crsx.Sink N_HxDeclaration(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxDeclaration");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxDeclaration:{
        t = jj_consume_token(MT_HxDeclaration);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_4:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[10] = jj_gen;
              break label_4;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[11] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxDeclaration:{
        jj_consume_token(IT_HxDeclaration);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxEmbeddedModule:
      case IT_HxEmbeddedModule:
      case T_HX_MODULE:{
sink = sink .start(makeTConstructor(sink, t, hx("embedded-module"), null)) ;
        sink = N_HxEmbeddedModule(sink, env);
        jj_consume_token(T_HX_SEMI);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_IMPORT:{
        t = jj_consume_token(T_HX_IMPORT);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
        sink = N_HxModuleName(sink, env);
        jj_consume_token(T_HX_SEMI);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_SPACE:{
        t = jj_consume_token(T_HX_SPACE);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
        sink = N_HxRegExp(sink, env);
        jj_consume_token(T_HX_SEMI);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_TOKEN:{
        jj_consume_token(T_HX_TOKEN);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxTokenName:
        case IT_HxTokenName:
        case T_HX_RE_NAME:{
sink = sink .start(makeTConstructor(sink, t, hx("token"), null)) ;
          sink = N_HxTokenName(sink, env);
          jj_consume_token(T_HX_BAR);
          sink = N_HxRegExp(sink, env);
sink = sink .end() ;
          break;
          }
        case T_HX_FRAGMENT:{
          t = jj_consume_token(T_HX_FRAGMENT);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
          sink = N_HxTokenName(sink, env);
          jj_consume_token(T_HX_BAR);
          sink = N_HxRegExp(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[12] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(T_HX_SEMI);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_FRAGMENT:{
        t = jj_consume_token(T_HX_FRAGMENT);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
        sink = N_HxTokenName(sink, env);
        jj_consume_token(T_HX_BAR);
        sink = N_HxRegExp(sink, env);
        jj_consume_token(T_HX_SEMI);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_ATTRIBUTE:{
        t = jj_consume_token(T_HX_ATTRIBUTE);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
        sink = N_HxAttributeKind(sink, env);
        sink = N_HxAttributeName(sink, env);
        sink = N_HxAttributeForm(sink, env);
        jj_consume_token(T_HX_SEMI);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxMainKind:
      case IT_HxMainKind:
      case T_HX_SORT:
      case T_HX_MAIN:{
sink = sink .start(makeTConstructor(sink, t, hx("sort"), null)) ;
        sink = N_HxMainKind(sink, env);
        jj_consume_token(T_HX_SORT);
        sink = N_Store_HxSortName(sink, env);
        sink = N_HxRepeat(sink, env);
        sink = N_HxSortAbstraction(sink, env);
        jj_consume_token(T_HX_SEMI);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxSortAlternatives:
      case IT_HxSortAlternatives:
      case MT_HxSortAlternative:
      case IT_HxSortAlternative:
      case T_HX_SEMI:
      case T_HX_BAR:{
sink = sink .start(makeTConstructor(sink, t, hx("anonymous"), null)) ;
        sink = N_HxSortAlternatives(sink, env);
        jj_consume_token(T_HX_SEMI);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxRule:
      case IT_HxRule:
      case MT_HxRulePrefix:
      case IT_HxRulePrefix:
      case MT_HxRulePriority:
      case IT_HxRulePriority:
      case MT_HxTopPattern:
      case IT_HxTopPattern:
      case MT_HxConstructor:
      case IT_HxConstructor:
      case MT_HxPattern:
      case IT_HxPattern:
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_LBRACKET:
      case T_HX_RULE:
      case T_HX_PRIORITY:
      case T_HX_DEFAULT:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:
      case T_HX_CONSTRUCTOR:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_RULE:{
          jj_consume_token(T_HX_RULE);
          break;
          }
        default:
          jj_la1[13] = jj_gen;
          ;
        }
sink = sink .start(makeTConstructor(sink, t, hx("rule"), null)) ;
        sink = N_HxRule(sink, env);
        jj_consume_token(T_HX_SEMI);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_LBRACE:{
sink = sink .start(makeTConstructor(sink, t, hx("nestedDeclarations"), null)) ;
        jj_consume_token(T_HX_LBRACE);
        sink = N_HxDeclarations(sink, env);
        jj_consume_token(T_HX_RBRACE);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxDeclaration");
    }
  }

/** <em>HxMainKind$WithEOF</em> ::= <em>HxMainKind</em> EOF . */
  final public net.sf.crsx.Sink N_HxMainKind$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxMainKind$WithEOF");
    try {
      sink = N_HxMainKind(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxMainKind$WithEOF");
    }
  }

/**
 * <em>HxMainKind</em> ::=  (   <a href="#T_HX_MAIN">HX_MAIN</a><font color="red">:hx</font>  |  <font color="red">{no-main}</font><font color="red">:hx</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxMainKind(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxMainKind");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxMainKind:{
        t = jj_consume_token(MT_HxMainKind);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_5:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[15] = jj_gen;
              break label_5;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[16] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxMainKind:{
        jj_consume_token(IT_HxMainKind);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[18] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_MAIN:{
          t = jj_consume_token(T_HX_MAIN);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[17] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("no-main"), null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxMainKind");
    }
  }

/** <em>HxAttributeKind$WithEOF</em> ::= <em>HxAttributeKind</em> EOF . */
  final public net.sf.crsx.Sink N_HxAttributeKind$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributeKind$WithEOF");
    try {
      sink = N_HxAttributeKind(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributeKind$WithEOF");
    }
  }

/**
 * <em>HxAttributeKind</em> ::=  (  <font color="red">{AttributeKindUp}</font><font color="red">:hx</font>    <a href="#T_HX_UP">HX_UP</a>  |  <font color="red">{AttributeKindDown}</font><font color="red">:hx</font>    <a href="#T_HX_DOWN">HX_DOWN</a>  ) 
 */
  final public net.sf.crsx.Sink N_HxAttributeKind(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributeKind");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxAttributeKind:{
        t = jj_consume_token(MT_HxAttributeKind);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_6:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[19] = jj_gen;
              break label_6;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[20] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxAttributeKind:{
        jj_consume_token(IT_HxAttributeKind);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_UP:
      case T_HX_DOWN:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_UP:{
sink = sink .start(makeTConstructor(sink, t, hx("AttributeKindUp"), null)) ;
          jj_consume_token(T_HX_UP);
sink = sink .end() ;
          break;
          }
        case T_HX_DOWN:{
sink = sink .start(makeTConstructor(sink, t, hx("AttributeKindDown"), null)) ;
          jj_consume_token(T_HX_DOWN);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributeKind");
    }
  }

/** <em>HxRegExp$WithEOF</em> ::= <em>HxRegExp</em> EOF . */
  final public net.sf.crsx.Sink N_HxRegExp$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExp$WithEOF");
    try {
token_source.SwitchTo(HX_RE);
      sink = N_HxRegExp(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExp$WithEOF");
    }
  }

/**
 * <em>HxRegExp</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxRegExpChoice">&lang;HxRegExpChoice&rang;</a>    (   <a href="#T_HX_BAR">HX_BAR</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxRegExp(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExp");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRegExp:{
        t = jj_consume_token(MT_HxRegExp);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_7:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[23] = jj_gen;
              break label_7;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[24] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRegExp:{
        jj_consume_token(IT_HxRegExp);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[26] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxRegExpChoice(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_BAR:{
          jj_consume_token(T_HX_BAR);
          sink = N_HxRegExp(sink, env);
          break;
          }
        default:
          jj_la1[25] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExp");
    }
  }

/** <em>HxRegExpChoice$WithEOF</em> ::= <em>HxRegExpChoice</em> EOF . */
  final public net.sf.crsx.Sink N_HxRegExpChoice$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpChoice$WithEOF");
    try {
token_source.SwitchTo(HX_RE);
      sink = N_HxRegExpChoice(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpChoice$WithEOF");
    }
  }

/**
 * <em>HxRegExpChoice</em> ::=   <a href="#T_HX_NESTED">HX_NESTED</a><font color="red">:hx</font>   <a href="#N_HxRegExpSimple">&lang;HxRegExpSimple&rang;</a>    <a href="#N_HxRegExpSimple">&lang;HxRegExpSimple&rang;</a>   <br>
 *  |  <font color="red">{RegExpConcat}</font><font color="red">:hx</font>   <a href="#N_HxRegExpUnits">&lang;HxRegExpUnits&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxRegExpChoice(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpChoice");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRegExpChoice:{
        t = jj_consume_token(MT_HxRegExpChoice);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_8:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[27] = jj_gen;
              break label_8;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[28] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRegExpChoice:{
        jj_consume_token(IT_HxRegExpChoice);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_NESTED:{
        t = jj_consume_token(T_HX_NESTED);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
        sink = N_HxRegExpSimple(sink, env);
        sink = N_HxRegExpSimple(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[29] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("RegExpConcat"), null)) ;
        sink = N_HxRegExpUnits(sink, env);
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpChoice");
    }
  }

/** <em>HxRegExpUnits$WithEOF</em> ::= <em>HxRegExpUnits</em> EOF . */
  final public net.sf.crsx.Sink N_HxRegExpUnits$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpUnits$WithEOF");
    try {
token_source.SwitchTo(HX_RE);
      sink = N_HxRegExpUnits(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpUnits$WithEOF");
    }
  }

/**
 * <em>HxRegExpUnits</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxRegExpUnit">&lang;HxRegExpUnit&rang;</a>    <a href="#N_HxRegExpUnits">&lang;HxRegExpUnits&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_HxRegExpUnits(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpUnits");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRegExpUnits:{
        t = jj_consume_token(MT_HxRegExpUnits);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_9:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[30] = jj_gen;
              break label_9;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[31] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRegExpUnits:{
        jj_consume_token(IT_HxRegExpUnits);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxRegExpUnit:
      case IT_HxRegExpUnit:
      case MT_HxRegExpSimple:
      case IT_HxRegExpSimple:
      case MT_HxFragmentRef:
      case IT_HxFragmentRef:
      case MT_HxRegExpWord:
      case IT_HxRegExpWord:
      case MT_HxString:
      case IT_HxString:
      case MT_HxRegExpClass:
      case IT_HxRegExpClass:
      case T_HX_LPAREN:
      case T_HX_DOT:
      case T_HX_FRAGMENT_REF:
      case T_HX_RE_NAME:
      case T_HX_RE_WORD:
      case T_HX_STRING:
      case T_HX_ESCAPEDCHAR:
      case T_HX_CHAR_CLASS:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxRegExpUnit(sink, env);
        sink = N_HxRegExpUnits(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[32] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpUnits");
    }
  }

/** <em>HxRegExpUnit$WithEOF</em> ::= <em>HxRegExpUnit</em> EOF . */
  final public net.sf.crsx.Sink N_HxRegExpUnit$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpUnit$WithEOF");
    try {
token_source.SwitchTo(HX_RE);
      sink = N_HxRegExpUnit(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpUnit$WithEOF");
    }
  }

/**
 * <em>HxRegExpUnit</em> ::=  <font color="red">{RegExpUnit}</font><font color="red">:hx</font>   <a href="#N_HxRegExpSimple">&lang;HxRegExpSimple&rang;</a>    <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxRegExpUnit(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpUnit");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRegExpUnit:{
        t = jj_consume_token(MT_HxRegExpUnit);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_10:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[33] = jj_gen;
              break label_10;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[34] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRegExpUnit:{
        jj_consume_token(IT_HxRegExpUnit);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxRegExpSimple:
      case IT_HxRegExpSimple:
      case MT_HxFragmentRef:
      case IT_HxFragmentRef:
      case MT_HxRegExpWord:
      case IT_HxRegExpWord:
      case MT_HxString:
      case IT_HxString:
      case MT_HxRegExpClass:
      case IT_HxRegExpClass:
      case T_HX_LPAREN:
      case T_HX_DOT:
      case T_HX_FRAGMENT_REF:
      case T_HX_RE_NAME:
      case T_HX_RE_WORD:
      case T_HX_STRING:
      case T_HX_ESCAPEDCHAR:
      case T_HX_CHAR_CLASS:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpUnit"), null)) ;
        sink = N_HxRegExpSimple(sink, env);
        sink = N_HxRepeat(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpUnit");
    }
  }

/** <em>HxRepeat$WithEOF</em> ::= <em>HxRepeat</em> EOF . */
  final public net.sf.crsx.Sink N_HxRepeat$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRepeat$WithEOF");
    try {
token_source.SwitchTo(DEFAULT);
      sink = N_HxRepeat(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRepeat$WithEOF");
    }
  }

/**
 * <em>HxRepeat</em> ::=   <a href="#T_HX_PLUS">HX_PLUS</a>   (  <font color="red">{RepeatSomeSep}</font><font color="red">:hx</font>    <a href="#T_HX_SUB">HX_SUB</a>   <a href="#N_HxRegExpSub">&lang;HxRegExpSub&rang;</a>   |  <font color="red">{RepeatSome}</font><font color="red">:hx</font>  )  <br>
 *  |  <font color="red">{RepeatMaybeSome}</font><font color="red">:hx</font>    <a href="#T_HX_STAR">HX_STAR</a>  <br>
 *  |  <font color="red">{RepeatMaybe}</font><font color="red">:hx</font>    <a href="#T_HX_QUEST">HX_QUEST</a>  <br>
 *  |  <font color="red">{RepeatSingle}</font><font color="red">:hx</font> 
 */
  final public net.sf.crsx.Sink N_HxRepeat(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRepeat");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRepeat:{
        t = jj_consume_token(MT_HxRepeat);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_11:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[36] = jj_gen;
              break label_11;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[37] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRepeat:{
        jj_consume_token(IT_HxRepeat);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_PLUS:{
        jj_consume_token(T_HX_PLUS);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_SUB:{
sink = sink .start(makeTConstructor(sink, t, hx("RepeatSomeSep"), null)) ;
          jj_consume_token(T_HX_SUB);
          sink = N_HxRegExpSub(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[38] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("RepeatSome"), null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink;}
        break;
        }
      case T_HX_STAR:{
sink = sink .start(makeTConstructor(sink, t, hx("RepeatMaybeSome"), null)) ;
        jj_consume_token(T_HX_STAR);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_QUEST:{
sink = sink .start(makeTConstructor(sink, t, hx("RepeatMaybe"), null)) ;
        jj_consume_token(T_HX_QUEST);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[39] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("RepeatSingle"), null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRepeat");
    }
  }

/** <em>HxRegExpSimple$WithEOF</em> ::= <em>HxRegExpSimple</em> EOF . */
  final public net.sf.crsx.Sink N_HxRegExpSimple$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpSimple$WithEOF");
    try {
token_source.SwitchTo(HX_RE);
      sink = N_HxRegExpSimple(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpSimple$WithEOF");
    }
  }

/**
 * <em>HxRegExpSimple</em> ::=  <font color="red">{RegExpRef}</font><font color="red">:hx</font>   <a href="#N_HxFragmentRef">&lang;HxFragmentRef&rang;</a>   <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:hx</font>   <a href="#N_HxRegExpClass">&lang;HxRegExpClass&rang;</a>   <br>
 *  |  <font color="red">{RegExpAny}</font><font color="red">:hx</font>    <a href="#T_HX_DOT">HX_DOT</a>  <br>
 *  |  <font color="red">{RegExpClass}</font><font color="red">:hx</font>   <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   (   <a href="#T_HX_ESCAPEDCHAR">HX_ESCAPEDCHAR</a><font color="red">$</font>  )   <font color="red">{RegExpClassDone}</font><font color="red">:hx</font>  <br>
 *  |  <font color="red">{RegExpNest}</font><font color="red">:hx</font>    <a href="#T_HX_LPAREN">HX_LPAREN</a>   <a href="#N_HxRegExp">&lang;HxRegExp&rang;</a>     <a href="#T_HX_RPAREN">HX_RPAREN</a>  <br>
 *  |  <font color="red">{RegExpString}</font><font color="red">:hx</font>   <a href="#N_HxString">&lang;HxString&rang;</a>   <br>
 *  |  <font color="red">{RegExpWord}</font><font color="red">:hx</font>   <a href="#N_HxRegExpWord">&lang;HxRegExpWord&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxRegExpSimple(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpSimple");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRegExpSimple:{
        t = jj_consume_token(MT_HxRegExpSimple);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_12:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[40] = jj_gen;
              break label_12;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[41] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRegExpSimple:{
        jj_consume_token(IT_HxRegExpSimple);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxFragmentRef:
      case IT_HxFragmentRef:
      case T_HX_FRAGMENT_REF:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpRef"), null)) ;
        sink = N_HxFragmentRef(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxRegExpClass:
      case IT_HxRegExpClass:
      case T_HX_CHAR_CLASS:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClass"), null)) ;
        sink = N_HxRegExpClass(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_DOT:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpAny"), null)) ;
        jj_consume_token(T_HX_DOT);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_ESCAPEDCHAR:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClass"), null)) ;
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
        t = jj_consume_token(T_HX_ESCAPEDCHAR);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
{if ("" != null) return sink .end().end().end() ;}
        break;
        }
      case T_HX_LPAREN:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpNest"), null)) ;
        jj_consume_token(T_HX_LPAREN);
        sink = N_HxRegExp(sink, env);
        jj_consume_token(T_HX_RPAREN);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxString:
      case IT_HxString:
      case T_HX_STRING:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpString"), null)) ;
        sink = N_HxString(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxRegExpWord:
      case IT_HxRegExpWord:
      case T_HX_RE_NAME:
      case T_HX_RE_WORD:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpWord"), null)) ;
        sink = N_HxRegExpWord(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpSimple");
    }
  }

/** <em>HxRegExpSub$WithEOF</em> ::= <em>HxRegExpSub</em> EOF . */
  final public net.sf.crsx.Sink N_HxRegExpSub$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpSub$WithEOF");
    try {
token_source.SwitchTo(DEFAULT);
      sink = N_HxRegExpSub(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpSub$WithEOF");
    }
  }

/**
 * <em>HxRegExpSub</em> ::=  <font color="red">{RegExpString}</font><font color="red">:hx</font>   <a href="#N_HxString">&lang;HxString&rang;</a>   <br>
 *  |  <font color="red">{RegExpWord}</font><font color="red">:hx</font>   <a href="#N_HxSeparator">&lang;HxSeparator&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxRegExpSub(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpSub");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRegExpSub:{
        t = jj_consume_token(MT_HxRegExpSub);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_13:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[43] = jj_gen;
              break label_13;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[44] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRegExpSub:{
        jj_consume_token(IT_HxRegExpSub);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxString:
      case IT_HxString:
      case T_HX_STRING:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpString"), null)) ;
        sink = N_HxString(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxSeparator:
      case IT_HxSeparator:
      case T_HX_SEMI:
      case T_HX_BAR:
      case T_HX_STAR:
      case T_HX_DOT:
      case T_HX_COLON:
      case T_HX_COMMA:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpWord"), null)) ;
        sink = N_HxSeparator(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpSub");
    }
  }

/** <em>HxAttributeForm$WithEOF</em> ::= <em>HxAttributeForm</em> EOF . */
  final public net.sf.crsx.Sink N_HxAttributeForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributeForm$WithEOF");
    try {
      sink = N_HxAttributeForm(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributeForm$WithEOF");
    }
  }

/**
 * <em>HxAttributeForm</em> ::=  <font color="red">{AttributeFormSimple}</font><font color="red">:hx</font>    <a href="#T_HX_LPAREN">HX_LPAREN</a>   <a href="#N_HxSort">&lang;HxSort&rang;</a>     <a href="#T_HX_RPAREN">HX_RPAREN</a>  <br>
 *  |   <a href="#T_HX_LBRACE">HX_LBRACE</a>   <a href="#N_HxSort">&lang;HxSort&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeFormMap}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_HX_COLON">HX_COLON</a>   <a href="#N_HxSort">&lang;HxSort&rang;</a>     <a href="#T_HX_RBRACE">HX_RBRACE</a>  |  <font color="red">{AttributeFormSet}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_HX_RBRACE">HX_RBRACE</a>  ) 
 */
  final public net.sf.crsx.Sink N_HxAttributeForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributeForm");
    try {Token t = null;
        net.sf.crsx.Sink bs__ = null;
        net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxAttributeForm:{
        t = jj_consume_token(MT_HxAttributeForm);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_14:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[46] = jj_gen;
              break label_14;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[47] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxAttributeForm:{
        jj_consume_token(IT_HxAttributeForm);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_LPAREN:{
sink = sink .start(makeTConstructor(sink, t, hx("AttributeFormSimple"), null)) ;
        jj_consume_token(T_HX_LPAREN);
        sink = N_HxSort(sink, env);
        jj_consume_token(T_HX_RPAREN);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_LBRACE:{
        jj_consume_token(T_HX_LBRACE);
bs__ = b__.sink();
        N_HxSort(bs__, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_COLON:{
sink = sink .start(makeTConstructor(sink, t, hx("AttributeFormMap"), null)) ;
sink = sink .copy(b__, true) ;
          jj_consume_token(T_HX_COLON);
          sink = N_HxSort(sink, env);
          jj_consume_token(T_HX_RBRACE);
sink = sink .end() ;
          break;
          }
        case T_HX_RBRACE:{
sink = sink .start(makeTConstructor(sink, t, hx("AttributeFormSet"), null)) ;
sink = sink .copy(b__, true) ;
          jj_consume_token(T_HX_RBRACE);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[48] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributeForm");
    }
  }

/** <em>HxSortNames$WithEOF</em> ::= <em>HxSortNames</em> EOF . */
  final public net.sf.crsx.Sink N_HxSortNames$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortNames$WithEOF");
    try {
      sink = N_HxSortNames(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortNames$WithEOF");
    }
  }

/**
 * <em>HxSortNames</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxSortName">&lang;HxSortName&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxSortNames">&lang;HxSortNames&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxSortNames(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortNames");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSortNames:{
        t = jj_consume_token(MT_HxSortNames);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_15:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[50] = jj_gen;
              break label_15;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[51] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSortNames:{
        jj_consume_token(IT_HxSortNames);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxSortName:
      case IT_HxSortName:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxSortName(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_COMMA:{
          jj_consume_token(T_HX_COMMA);
          sink = N_HxSortNames(sink, env);
          break;
          }
        default:
          jj_la1[52] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortNames");
    }
  }

/** <em>HxSortAbstraction$WithEOF</em> ::= <em>HxSortAbstraction</em> EOF . */
  final public net.sf.crsx.Sink N_HxSortAbstraction$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortAbstraction$WithEOF");
    try {
      sink = N_HxSortAbstraction(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortAbstraction$WithEOF");
    }
  }

/**
 * <em>HxSortAbstraction</em> ::=  <font color="red">{SortAbstractionParam}</font><font color="red">:hx</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">^a</font>   <a href="#N_HxSortAbstraction">&lang;HxSortAbstraction&rang;</a> <font color="red">[a]</font>  <br>
 *  |  <font color="red">{SortAbstractionBody}</font><font color="red">:hx</font>   <a href="#N_HxSortAlternatives">&lang;HxSortAlternatives&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxSortAbstraction(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortAbstraction");
    try {String s_a = null;
        Token t = null;
        net.sf.crsx.Variable v_a = null;
        String c0 = null;
        net.sf.crsx.util.Buffer b_a = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs_a = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSortAbstraction:{
        t = jj_consume_token(MT_HxSortAbstraction);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_16:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[54] = jj_gen;
              break label_16;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[55] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSortAbstraction:{
        jj_consume_token(IT_HxSortAbstraction);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:{
sink = sink .start(makeTConstructor(sink, t, hx("SortAbstractionParam"), null)) ;
bs_a = b_a.sink();
        N_HxVariable(bs_a, env);
if (b_a.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_a.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_a.term(false)+")");}
                c0 = b_a.term(true).constructor().symbol();
                s_a = c0;
                v_a = sink.makeVariable(s_a,true);
{
                        net.sf.crsx.Variable[] bs1 = {v_a};
                        sink = sink .binds(bs1) ;
                }
        sink = N_HxSortAbstraction(sink, env.extend(s_a, v_a));
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[56] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("SortAbstractionBody"), null)) ;
        sink = N_HxSortAlternatives(sink, env);
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortAbstraction");
    }
  }

/** <em>HxSortAlternatives$WithEOF</em> ::= <em>HxSortAlternatives</em> EOF . */
  final public net.sf.crsx.Sink N_HxSortAlternatives$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortAlternatives$WithEOF");
    try {
      sink = N_HxSortAlternatives(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortAlternatives$WithEOF");
    }
  }

/**
 * <em>HxSortAlternatives</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxSortAlternative">&lang;HxSortAlternative&rang;</a>    <a href="#N_HxSortAlternatives">&lang;HxSortAlternatives&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_HxSortAlternatives(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortAlternatives");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSortAlternatives:{
        t = jj_consume_token(MT_HxSortAlternatives);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_17:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[57] = jj_gen;
              break label_17;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[58] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSortAlternatives:{
        jj_consume_token(IT_HxSortAlternatives);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxSortAlternative:
      case IT_HxSortAlternative:
      case T_HX_BAR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxSortAlternative(sink, env);
        sink = N_HxSortAlternatives(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[59] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortAlternatives");
    }
  }

/** <em>HxSortAlternative$WithEOF</em> ::= <em>HxSortAlternative</em> EOF . */
  final public net.sf.crsx.Sink N_HxSortAlternative$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortAlternative$WithEOF");
    try {
      sink = N_HxSortAlternative(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortAlternative$WithEOF");
    }
  }

/**
 * <em>HxSortAlternative</em> ::=   <a href="#T_HX_BAR">HX_BAR</a>   (   <a href="#T_HX_SCHEME">HX_SCHEME</a><font color="red">:hx</font>   <a href="#N_HxForm">&lang;HxForm&rang;</a>   |  <font color="red">{SynthesizedRef}</font><font color="red">:hx</font>    <a href="#T_HX_UP">HX_UP</a>   <a href="#N_HxAttributeName">&lang;HxAttributeName&rang;</a>   |   <a href="#T_HX_SUGAR">HX_SUGAR</a><font color="red">:hx</font>   <a href="#N_HxForm">&lang;HxForm&rang;</a>     <a href="#T_HX_ARROW">HX_ARROW</a>   <a href="#N_HxTopTerm">&lang;HxTopTerm&rang;</a>   |   <a href="#T_HX_SYMBOL">HX_SYMBOL</a><font color="red">:hx</font>   <a href="#N_HxForm">&lang;HxForm&rang;</a>   |   <a href="#T_HX_STATIC">HX_STATIC</a><font color="red">:hx</font>   (   <a href="#T_HX_SYMBOL">HX_SYMBOL</a>  )?   <a href="#N_HxForm">&lang;HxForm&rang;</a>   |  <font color="red">{data}</font><font color="red">:hx</font>   (   <a href="#T_HX_DATA">HX_DATA</a>  )?   <a href="#N_HxForm">&lang;HxForm&rang;</a>   ) 
 */
  final public net.sf.crsx.Sink N_HxSortAlternative(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortAlternative");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSortAlternative:{
        t = jj_consume_token(MT_HxSortAlternative);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_18:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[60] = jj_gen;
              break label_18;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[61] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSortAlternative:{
        jj_consume_token(IT_HxSortAlternative);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_BAR:{
        jj_consume_token(T_HX_BAR);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_SCHEME:{
          t = jj_consume_token(T_HX_SCHEME);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
          sink = N_HxForm(sink, env);
sink = sink .end() ;
          break;
          }
        case T_HX_UP:{
sink = sink .start(makeTConstructor(sink, t, hx("SynthesizedRef"), null)) ;
          jj_consume_token(T_HX_UP);
          sink = N_HxAttributeName(sink, env);
sink = sink .end() ;
          break;
          }
        case T_HX_SUGAR:{
          t = jj_consume_token(T_HX_SUGAR);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
          sink = N_HxForm(sink, env);
          jj_consume_token(T_HX_ARROW);
          sink = N_HxTopTerm(sink, env);
sink = sink .end() ;
          break;
          }
        case T_HX_SYMBOL:{
          t = jj_consume_token(T_HX_SYMBOL);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
          sink = N_HxForm(sink, env);
sink = sink .end() ;
          break;
          }
        case T_HX_STATIC:{
          t = jj_consume_token(T_HX_STATIC);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case T_HX_SYMBOL:{
            jj_consume_token(T_HX_SYMBOL);
            break;
            }
          default:
            jj_la1[62] = jj_gen;
            ;
          }
          sink = N_HxForm(sink, env);
sink = sink .end() ;
          break;
          }
        case MT_HxForm:
        case IT_HxForm:
        case MT_HxConstructor:
        case IT_HxConstructor:
        case T_HX_CONCRETE:
        case MT_HxParsedForm:
        case IT_HxParsedForm:
        case T_HX_DATA:
        case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, hx("data"), null)) ;
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case T_HX_DATA:{
            jj_consume_token(T_HX_DATA);
            break;
            }
          default:
            jj_la1[63] = jj_gen;
            ;
          }
          sink = N_HxForm(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[64] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[65] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortAlternative");
    }
  }

/** <em>HxForm$WithEOF</em> ::= <em>HxForm</em> EOF . */
  final public net.sf.crsx.Sink N_HxForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxForm$WithEOF");
    try {
      sink = N_HxForm(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxForm$WithEOF");
    }
  }

/**
 * <em>HxForm</em> ::=  <font color="red">{FormParsed}</font><font color="red">:hx</font>   <a href="#N_HxParsedForm">&lang;HxParsedForm&rang;</a>    <a href="#N_HxFormPrec">&lang;HxFormPrec&rang;</a>    <a href="#N_HxInheritedRefs">&lang;HxInheritedRefs&rang;</a>   <br>
 *  |  <font color="red">{FormConstruction}</font><font color="red">:hx</font>   <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a>    (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxBindersScopeSorts">&lang;HxBindersScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxInheritedRefs">&lang;HxInheritedRefs&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxForm");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxForm:{
        t = jj_consume_token(MT_HxForm);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_19:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[66] = jj_gen;
              break label_19;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[67] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxForm:{
        jj_consume_token(IT_HxForm);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CONCRETE:
      case MT_HxParsedForm:
      case IT_HxParsedForm:{
sink = sink .start(makeTConstructor(sink, t, hx("FormParsed"), null)) ;
        sink = N_HxParsedForm(sink, env);
        sink = N_HxFormPrec(sink, env);
        sink = N_HxInheritedRefs(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxConstructor:
      case IT_HxConstructor:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, hx("FormConstruction"), null)) ;
        sink = N_HxConstructor(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_LPAREN:{
          jj_consume_token(T_HX_LPAREN);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case MT_HxBindersScopeSorts:
          case IT_HxBindersScopeSorts:
          case MT_HxBindersScopeSort:
          case IT_HxBindersScopeSort:
          case MT_HxScopeSort:
          case IT_HxScopeSort:
          case MT_HxSort:
          case IT_HxSort:
          case MT_HxSimpleSort:
          case IT_HxSimpleSort:
          case MT_HxSortParam:
          case IT_HxSortParam:
          case MT_HxSortName:
          case IT_HxSortName:
          case MT_HxVariable:
          case IT_HxVariable:
          case T_HX_LBRACKET:
          case T_HX_VAR:
          case T_HX_CONSTRUCTOR:{
            sink = N_HxBindersScopeSorts(sink, env);
            break;
            }
          default:
            jj_la1[68] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
          }
          jj_consume_token(T_HX_RPAREN);
          break;
          }
        default:
          jj_la1[69] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
        sink = N_HxInheritedRefs(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[70] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxForm");
    }
  }

/** <em>HxBindersScopeSorts$WithEOF</em> ::= <em>HxBindersScopeSorts</em> EOF . */
  final public net.sf.crsx.Sink N_HxBindersScopeSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxBindersScopeSorts$WithEOF");
    try {
      sink = N_HxBindersScopeSorts(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxBindersScopeSorts$WithEOF");
    }
  }

/**
 * <em>HxBindersScopeSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxBindersScopeSort">&lang;HxBindersScopeSort&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxBindersScopeSorts">&lang;HxBindersScopeSorts&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxBindersScopeSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxBindersScopeSorts");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxBindersScopeSorts:{
        t = jj_consume_token(MT_HxBindersScopeSorts);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_20:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[71] = jj_gen;
              break label_20;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[72] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxBindersScopeSorts:{
        jj_consume_token(IT_HxBindersScopeSorts);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxBindersScopeSort:
      case IT_HxBindersScopeSort:
      case MT_HxScopeSort:
      case IT_HxScopeSort:
      case MT_HxSort:
      case IT_HxSort:
      case MT_HxSimpleSort:
      case IT_HxSimpleSort:
      case MT_HxSortParam:
      case IT_HxSortParam:
      case MT_HxSortName:
      case IT_HxSortName:
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_LBRACKET:
      case T_HX_VAR:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxBindersScopeSort(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_COMMA:{
          jj_consume_token(T_HX_COMMA);
          sink = N_HxBindersScopeSorts(sink, env);
          break;
          }
        default:
          jj_la1[73] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[74] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxBindersScopeSorts");
    }
  }

/** <em>HxBindersScopeSort$WithEOF</em> ::= <em>HxBindersScopeSort</em> EOF . */
  final public net.sf.crsx.Sink N_HxBindersScopeSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxBindersScopeSort$WithEOF");
    try {
      sink = N_HxBindersScopeSort(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxBindersScopeSort$WithEOF");
    }
  }

/**
 * <em>HxBindersScopeSort</em> ::=   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   <a href="#N_HxBindersScopeSortInside">&lang;HxBindersScopeSortInside&rang;</a>   <br>
 *  |  <a href="#N_HxScopeSort">&lang;HxScopeSort&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxBindersScopeSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxBindersScopeSort");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxBindersScopeSort:{
        t = jj_consume_token(MT_HxBindersScopeSort);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_21:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[75] = jj_gen;
              break label_21;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[76] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxBindersScopeSort:{
        jj_consume_token(IT_HxBindersScopeSort);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_LBRACKET:{
        jj_consume_token(T_HX_LBRACKET);
        sink = N_HxBindersScopeSortInside(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxScopeSort:
      case IT_HxScopeSort:
      case MT_HxSort:
      case IT_HxSort:
      case MT_HxSimpleSort:
      case IT_HxSimpleSort:
      case MT_HxSortParam:
      case IT_HxSortParam:
      case MT_HxSortName:
      case IT_HxSortName:
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:
      case T_HX_CONSTRUCTOR:{
        sink = N_HxScopeSort(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[77] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxBindersScopeSort");
    }
  }

/**
 * <em>HxBindersScopeSortInside</em> ::=  <a href="#N_HxSort">&lang;HxSort&rang;</a> <font color="red">:#Sort</font>    <a href="#T_HX_BINDS">HX_BINDS</a><font color="red">:hx</font>   <font color="red">{{#Sort}}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>   <a href="#N_HxBindersScopeSortInsideTail">&lang;HxBindersScopeSortInsideTail&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxBindersScopeSortInside(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxBindersScopeSortInside");
    try {net.sf.crsx.Variable v_HxVariable = null;
        Token t = null;
        net.sf.crsx.Sink bs_HxVariable = null;
        net.sf.crsx.util.Buffer b__Sort = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
        String s_HxVariable = null;
        String c3 = null;
        net.sf.crsx.Sink bs__Sort = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxBindersScopeSortInside:{
        t = jj_consume_token(MT_HxBindersScopeSortInside);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_22:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[78] = jj_gen;
              break label_22;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[79] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxBindersScopeSortInside:{
        jj_consume_token(IT_HxBindersScopeSortInside);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxSort:
      case IT_HxSort:
      case MT_HxSimpleSort:
      case IT_HxSimpleSort:
      case MT_HxSortParam:
      case IT_HxSortParam:
      case MT_HxSortName:
      case IT_HxSortName:
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:
      case T_HX_CONSTRUCTOR:{
bs__Sort = b__Sort.sink();
        N_HxSort(bs__Sort, env);
        t = jj_consume_token(T_HX_BINDS);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
sink = sink .copy(b__Sort, true) ;
bs_HxVariable = b_HxVariable.sink();
        N_HxVariable(bs_HxVariable, env);
if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");}
                c3 = b_HxVariable.term(true).constructor().symbol();
                s_HxVariable = c3;
                v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
                if (v_HxVariable == null) {if (true) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");}
                sink = sink .use(v_HxVariable) ;
        sink = N_HxBindersScopeSortInsideTail(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[80] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxBindersScopeSortInside");
    }
  }

/**
 * <em>HxBindersScopeSortInsideTail</em> ::=   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxBindersScopeSortInside">&lang;HxBindersScopeSortInside&rang;</a>   <br>
 *  |   <a href="#T_HX_RBRACKET">HX_RBRACKET</a>   <a href="#N_HxBindersScopeSort">&lang;HxBindersScopeSort&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxBindersScopeSortInsideTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxBindersScopeSortInsideTail");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxBindersScopeSortInsideTail:{
        t = jj_consume_token(MT_HxBindersScopeSortInsideTail);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_23:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[81] = jj_gen;
              break label_23;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[82] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxBindersScopeSortInsideTail:{
        jj_consume_token(IT_HxBindersScopeSortInsideTail);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_COMMA:{
        jj_consume_token(T_HX_COMMA);
        sink = N_HxBindersScopeSortInside(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_RBRACKET:{
        jj_consume_token(T_HX_RBRACKET);
        sink = N_HxBindersScopeSort(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[83] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxBindersScopeSortInsideTail");
    }
  }

/** <em>HxScopeSort$WithEOF</em> ::= <em>HxScopeSort</em> EOF . */
  final public net.sf.crsx.Sink N_HxScopeSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxScopeSort$WithEOF");
    try {
      sink = N_HxScopeSort(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxScopeSort$WithEOF");
    }
  }

/**
 * <em>HxScopeSort</em> ::=  <font color="red">{ScopeSort}</font><font color="red">:hx</font>   <a href="#N_HxSort">&lang;HxSort&rang;</a>    <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a>    (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   <a href="#N_HxSubstituteSorts">&lang;HxSubstituteSorts&rang;</a>     <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxScopeSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxScopeSort");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxScopeSort:{
        t = jj_consume_token(MT_HxScopeSort);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_24:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[84] = jj_gen;
              break label_24;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[85] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxScopeSort:{
        jj_consume_token(IT_HxScopeSort);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxSort:
      case IT_HxSort:
      case MT_HxSimpleSort:
      case IT_HxSimpleSort:
      case MT_HxSortParam:
      case IT_HxSortParam:
      case MT_HxSortName:
      case IT_HxSortName:
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, hx("ScopeSort"), null)) ;
        sink = N_HxSort(sink, env);
        sink = N_HxRepeat(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_LBRACKET:{
          jj_consume_token(T_HX_LBRACKET);
          sink = N_HxSubstituteSorts(sink, env);
          jj_consume_token(T_HX_RBRACKET);
          break;
          }
        default:
          jj_la1[86] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[87] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxScopeSort");
    }
  }

/** <em>HxSubstituteSorts$WithEOF</em> ::= <em>HxSubstituteSorts</em> EOF . */
  final public net.sf.crsx.Sink N_HxSubstituteSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSubstituteSorts$WithEOF");
    try {
      sink = N_HxSubstituteSorts(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSubstituteSorts$WithEOF");
    }
  }

/**
 * <em>HxSubstituteSorts</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxSubstituteSort">&lang;HxSubstituteSort&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxSubstituteSorts">&lang;HxSubstituteSorts&rang;</a>   |  <font color="red">{$Nil}</font>  )  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_HxSubstituteSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSubstituteSorts");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSubstituteSorts:{
        t = jj_consume_token(MT_HxSubstituteSorts);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_25:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[88] = jj_gen;
              break label_25;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[89] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSubstituteSorts:{
        jj_consume_token(IT_HxSubstituteSorts);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxSubstituteSort:
      case IT_HxSubstituteSort:
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxSubstituteSort(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_COMMA:{
          jj_consume_token(T_HX_COMMA);
          sink = N_HxSubstituteSorts(sink, env);
          break;
          }
        default:
          jj_la1[90] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[91] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSubstituteSorts");
    }
  }

/** <em>HxSubstituteSort$WithEOF</em> ::= <em>HxSubstituteSort</em> EOF . */
  final public net.sf.crsx.Sink N_HxSubstituteSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSubstituteSort$WithEOF");
    try {
      sink = N_HxSubstituteSort(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSubstituteSort$WithEOF");
    }
  }

/**
 * <em>HxSubstituteSort</em> ::=  <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!:#v</font>   (  <font color="red">{SubstituteSort}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>    <a href="#T_HX_AS">HX_AS</a>   <a href="#N_HxSort">&lang;HxSort&rang;</a>   |  <font color="red">{SubstituteNoSort}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxSubstituteSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSubstituteSort");
    try {String s__v = null;
        Token t = null;
        String c0 = null;
        net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs__v = null;
        net.sf.crsx.Variable v__v = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSubstituteSort:{
        t = jj_consume_token(MT_HxSubstituteSort);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_26:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[92] = jj_gen;
              break label_26;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[93] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSubstituteSort:{
        jj_consume_token(IT_HxSubstituteSort);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:{
bs__v = b__v.sink();
        N_HxVariable(bs__v, env);
if (b__v.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b__v.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b__v.term(false)+")");}
                c0 = b__v.term(true).constructor().symbol();
                s__v = c0;
                v__v = (env.containsKey(s__v) ? env.get(s__v) : factory.freeVariable(s__v, true, true));
                if (v__v == null) {if (true) throw new ParseException("Variable "+s__v+" cannot be resolved?");}
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_AS:{
sink = sink .start(makeTConstructor(sink, t, hx("SubstituteSort"), null)) ;
sink = sink .use(v__v) ;
          jj_consume_token(T_HX_AS);
          sink = N_HxSort(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[94] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("SubstituteNoSort"), null)) ;
sink = sink .use(v__v) ;
sink = sink .end() ;
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[95] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSubstituteSort");
    }
  }

/** <em>HxSort$WithEOF</em> ::= <em>HxSort</em> EOF . */
  final public net.sf.crsx.Sink N_HxSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSort$WithEOF");
    try {
      sink = N_HxSort(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSort$WithEOF");
    }
  }

/**
 * <em>HxSort</em> ::=  <font color="red">{Sort}</font><font color="red">:hx</font>   <a href="#N_HxSimpleSort">&lang;HxSimpleSort&rang;</a>    <a href="#N_HxSimpleSorts">&lang;HxSimpleSorts&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSort");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSort:{
        t = jj_consume_token(MT_HxSort);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_27:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[96] = jj_gen;
              break label_27;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[97] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSort:{
        jj_consume_token(IT_HxSort);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxSimpleSort:
      case IT_HxSimpleSort:
      case MT_HxSortParam:
      case IT_HxSortParam:
      case MT_HxSortName:
      case IT_HxSortName:
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, hx("Sort"), null)) ;
        sink = N_HxSimpleSort(sink, env);
        sink = N_HxSimpleSorts(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[98] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSort");
    }
  }

/** <em>HxSimpleSorts$WithEOF</em> ::= <em>HxSimpleSorts</em> EOF . */
  final public net.sf.crsx.Sink N_HxSimpleSorts$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSimpleSorts$WithEOF");
    try {
      sink = N_HxSimpleSorts(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSimpleSorts$WithEOF");
    }
  }

/**
 * <em>HxSimpleSorts</em> ::=   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <font color="red">{$Cons}</font>   <a href="#N_HxSimpleSort">&lang;HxSimpleSort&rang;</a>    <a href="#N_HxSimpleSortTail">&lang;HxSimpleSortTail&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_HxSimpleSorts(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSimpleSorts");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSimpleSorts:{
        t = jj_consume_token(MT_HxSimpleSorts);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_28:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[99] = jj_gen;
              break label_28;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[100] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSimpleSorts:{
        jj_consume_token(IT_HxSimpleSorts);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_LPAREN:{
        jj_consume_token(T_HX_LPAREN);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxSimpleSort:
        case IT_HxSimpleSort:
        case MT_HxSortParam:
        case IT_HxSortParam:
        case MT_HxSortName:
        case IT_HxSortName:
        case MT_HxVariable:
        case IT_HxVariable:
        case T_HX_VAR:
        case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
          sink = N_HxSimpleSort(sink, env);
          sink = N_HxSimpleSortTail(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[101] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
        jj_consume_token(T_HX_RPAREN);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[102] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSimpleSorts");
    }
  }

/**
 * <em>HxSimpleSortTail</em> ::=   <a href="#T_HX_COMMA">HX_COMMA</a>   <font color="red">{$Cons}</font>   <a href="#N_HxSimpleSort">&lang;HxSimpleSort&rang;</a>    <a href="#N_HxSimpleSortTail">&lang;HxSimpleSortTail&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_HxSimpleSortTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSimpleSortTail");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSimpleSortTail:{
        t = jj_consume_token(MT_HxSimpleSortTail);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_29:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[103] = jj_gen;
              break label_29;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[104] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSimpleSortTail:{
        jj_consume_token(IT_HxSimpleSortTail);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_COMMA:{
        jj_consume_token(T_HX_COMMA);
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxSimpleSort(sink, env);
        sink = N_HxSimpleSortTail(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[105] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSimpleSortTail");
    }
  }

/** <em>HxSimpleSort$WithEOF</em> ::= <em>HxSimpleSort</em> EOF . */
  final public net.sf.crsx.Sink N_HxSimpleSort$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSimpleSort$WithEOF");
    try {
      sink = N_HxSimpleSort(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSimpleSort$WithEOF");
    }
  }

/**
 * <em>HxSimpleSort</em> ::=  <font color="red">{SortName}</font><font color="red">:hx</font>   <a href="#N_HxSortName">&lang;HxSortName&rang;</a>    <a href="#N_HxMetaVariables">&lang;HxMetaVariables&rang;</a>   <br>
 *  |  <font color="red">{SortParam}</font><font color="red">:hx</font>   <a href="#N_HxSortParam">&lang;HxSortParam&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxSimpleSort(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSimpleSort");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSimpleSort:{
        t = jj_consume_token(MT_HxSimpleSort);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_30:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[106] = jj_gen;
              break label_30;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[107] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSimpleSort:{
        jj_consume_token(IT_HxSimpleSort);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxSortName:
      case IT_HxSortName:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, hx("SortName"), null)) ;
        sink = N_HxSortName(sink, env);
        sink = N_HxMetaVariables(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxSortParam:
      case IT_HxSortParam:
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:{
sink = sink .start(makeTConstructor(sink, t, hx("SortParam"), null)) ;
        sink = N_HxSortParam(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[108] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSimpleSort");
    }
  }

/** <em>HxMetaVariables$WithEOF</em> ::= <em>HxMetaVariables</em> EOF . */
  final public net.sf.crsx.Sink N_HxMetaVariables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxMetaVariables$WithEOF");
    try {
      sink = N_HxMetaVariables(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxMetaVariables$WithEOF");
    }
  }

/**
 * <em>HxMetaVariables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>    <font color="red">{$Nil}</font>  <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_HxMetaVariables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxMetaVariables");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxMetaVariables:{
        t = jj_consume_token(MT_HxMetaVariables);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_31:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[109] = jj_gen;
              break label_31;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[110] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxMetaVariables:{
        jj_consume_token(IT_HxMetaVariables);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxMetaVariable:
      case IT_HxMetaVariable:
      case T_HX_META:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxMetaVariable(sink, env);
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
{if ("" != null) return sink .end().end() ;}
        break;
        }
      default:
        jj_la1[111] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxMetaVariables");
    }
  }

/** <em>HxSortParam$WithEOF</em> ::= <em>HxSortParam</em> EOF . */
  final public net.sf.crsx.Sink N_HxSortParam$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortParam$WithEOF");
    try {
      sink = N_HxSortParam(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortParam$WithEOF");
    }
  }

/**
 * <em>HxSortParam</em> ::=  <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!</font> 
 */
  final public net.sf.crsx.Sink N_HxSortParam(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortParam");
    try {net.sf.crsx.Variable v_HxVariable = null;
        Token t = null;
        net.sf.crsx.Sink bs_HxVariable = null;
        String c0 = null;
        net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
        String s_HxVariable = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSortParam:{
        t = jj_consume_token(MT_HxSortParam);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_32:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[112] = jj_gen;
              break label_32;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[113] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSortParam:{
        jj_consume_token(IT_HxSortParam);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:{
bs_HxVariable = b_HxVariable.sink();
        N_HxVariable(bs_HxVariable, env);
if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");}
                c0 = b_HxVariable.term(true).constructor().symbol();
                s_HxVariable = c0;
                v_HxVariable = env.get(s_HxVariable);
                if (v_HxVariable == null) {if (true) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");}
                sink = sink .use(v_HxVariable) ;
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[114] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortParam");
    }
  }

/** <em>HxFormPrec$WithEOF</em> ::= <em>HxFormPrec</em> EOF . */
  final public net.sf.crsx.Sink N_HxFormPrec$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxFormPrec$WithEOF");
    try {
      sink = N_HxFormPrec(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxFormPrec$WithEOF");
    }
  }

/**
 * <em>HxFormPrec</em> ::=  (   <a href="#T_HX_AT">HX_AT</a>   <a href="#N_HxNatural">&lang;HxNatural&rang;</a>   |  <font color="red">{"0"}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxFormPrec(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxFormPrec");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxFormPrec:{
        t = jj_consume_token(MT_HxFormPrec);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_33:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[115] = jj_gen;
              break label_33;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[116] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxFormPrec:{
        jj_consume_token(IT_HxFormPrec);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[118] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_AT:{
          jj_consume_token(T_HX_AT);
          sink = N_HxNatural(sink, env);
          break;
          }
        default:
          jj_la1[117] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "0", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxFormPrec");
    }
  }

/** <em>HxInheritedRefs$WithEOF</em> ::= <em>HxInheritedRefs</em> EOF . */
  final public net.sf.crsx.Sink N_HxInheritedRefs$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxInheritedRefs$WithEOF");
    try {
      sink = N_HxInheritedRefs(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxInheritedRefs$WithEOF");
    }
  }

/**
 * <em>HxInheritedRefs</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_HxInheritedRef">&lang;HxInheritedRef&rang;</a>    <a href="#N_HxInheritedRefs">&lang;HxInheritedRefs&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxInheritedRefs(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxInheritedRefs");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxInheritedRefs:{
        t = jj_consume_token(MT_HxInheritedRefs);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_34:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[119] = jj_gen;
              break label_34;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[120] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxInheritedRefs:{
        jj_consume_token(IT_HxInheritedRefs);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[122] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxInheritedRef:
        case IT_HxInheritedRef:
        case T_HX_DOWN:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
          sink = N_HxInheritedRef(sink, env);
          sink = N_HxInheritedRefs(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[121] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxInheritedRefs");
    }
  }

/** <em>HxInheritedRef$WithEOF</em> ::= <em>HxInheritedRef</em> EOF . */
  final public net.sf.crsx.Sink N_HxInheritedRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxInheritedRef$WithEOF");
    try {
      sink = N_HxInheritedRef(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxInheritedRef$WithEOF");
    }
  }

/**
 * <em>HxInheritedRef</em> ::=   <a href="#T_HX_DOWN">HX_DOWN</a>   <a href="#N_HxAttributeName">&lang;HxAttributeName&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxInheritedRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxInheritedRef");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxInheritedRef:{
        t = jj_consume_token(MT_HxInheritedRef);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_35:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[123] = jj_gen;
              break label_35;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[124] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxInheritedRef:{
        jj_consume_token(IT_HxInheritedRef);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_DOWN:{
        jj_consume_token(T_HX_DOWN);
        sink = N_HxAttributeName(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[125] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxInheritedRef");
    }
  }

/** <em>HxRule$WithEOF</em> ::= <em>HxRule</em> EOF . */
  final public net.sf.crsx.Sink N_HxRule$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRule$WithEOF");
    try {
      sink = N_HxRule(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRule$WithEOF");
    }
  }

/**
 * <em>HxRule</em> ::=  <font color="red">{Rule}</font><font color="red">:hx</font>   <a href="#N_HxRulePrefix">&lang;HxRulePrefix&rang;</a>    <a href="#N_HxTopPattern">&lang;HxTopPattern&rang;</a>    (   <a href="#T_HX_ARROW">HX_ARROW</a>   <a href="#N_HxTopTerm">&lang;HxTopTerm&rang;</a>   |  <font color="red">{NullTerm}</font><font color="red">:hx</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxRule(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRule");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRule:{
        t = jj_consume_token(MT_HxRule);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_36:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[126] = jj_gen;
              break label_36;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[127] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRule:{
        jj_consume_token(IT_HxRule);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxRulePrefix:
      case IT_HxRulePrefix:
      case MT_HxRulePriority:
      case IT_HxRulePriority:
      case MT_HxTopPattern:
      case IT_HxTopPattern:
      case MT_HxConstructor:
      case IT_HxConstructor:
      case MT_HxPattern:
      case IT_HxPattern:
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_LBRACKET:
      case T_HX_PRIORITY:
      case T_HX_DEFAULT:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, hx("Rule"), null)) ;
        sink = N_HxRulePrefix(sink, env);
        sink = N_HxTopPattern(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_ARROW:{
          jj_consume_token(T_HX_ARROW);
          sink = N_HxTopTerm(sink, env);
          break;
          }
        default:
          jj_la1[128] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("NullTerm"), null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[129] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRule");
    }
  }

/** <em>HxRulePrefix$WithEOF</em> ::= <em>HxRulePrefix</em> EOF . */
  final public net.sf.crsx.Sink N_HxRulePrefix$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRulePrefix$WithEOF");
    try {
      sink = N_HxRulePrefix(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRulePrefix$WithEOF");
    }
  }

/**
 * <em>HxRulePrefix</em> ::=  <font color="red">{RulePrefix}</font><font color="red">:hx</font>   <a href="#N_HxRulePriority">&lang;HxRulePriority&rang;</a>    (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   (  <a href="#N_HxRuleOptions">&lang;HxRuleOptions&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxRulePrefix(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRulePrefix");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRulePrefix:{
        t = jj_consume_token(MT_HxRulePrefix);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_37:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[130] = jj_gen;
              break label_37;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[131] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRulePrefix:{
        jj_consume_token(IT_HxRulePrefix);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[134] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("RulePrefix"), null)) ;
        sink = N_HxRulePriority(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_LBRACKET:{
          jj_consume_token(T_HX_LBRACKET);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case MT_HxRuleOptions:
          case IT_HxRuleOptions:
          case MT_HxTopPattern:
          case IT_HxTopPattern:
          case MT_HxConstructor:
          case IT_HxConstructor:
          case MT_HxPattern:
          case IT_HxPattern:
          case MT_HxConcrete:
          case IT_HxConcrete:
          case T_HX_CONCRETE:
          case MT_HxLiteral:
          case IT_HxLiteral:
          case MT_HxNumber:
          case IT_HxNumber:
          case MT_HxNatural:
          case IT_HxNatural:
          case MT_HxString:
          case IT_HxString:
          case T_HX_NATURAL:
          case T_HX_UNNATURAL:
          case T_HX_STRING:
          case T_HX_CONSTRUCTOR:{
            sink = N_HxRuleOptions(sink, env);
            break;
            }
          default:
            jj_la1[132] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
          }
          jj_consume_token(T_HX_RBRACKET);
          break;
          }
        default:
          jj_la1[133] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRulePrefix");
    }
  }

/** <em>HxRulePriority$WithEOF</em> ::= <em>HxRulePriority</em> EOF . */
  final public net.sf.crsx.Sink N_HxRulePriority$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRulePriority$WithEOF");
    try {
      sink = N_HxRulePriority(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRulePriority$WithEOF");
    }
  }

/**
 * <em>HxRulePriority</em> ::=  (   <a href="#T_HX_DEFAULT">HX_DEFAULT</a><font color="red">:hx</font>  |   <a href="#T_HX_PRIORITY">HX_PRIORITY</a><font color="red">:hx</font>  |  <font color="red">{Normal}</font><font color="red">:hx</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxRulePriority(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRulePriority");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRulePriority:{
        t = jj_consume_token(MT_HxRulePriority);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_38:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[135] = jj_gen;
              break label_38;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[136] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRulePriority:{
        jj_consume_token(IT_HxRulePriority);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[138] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_DEFAULT:{
          t = jj_consume_token(T_HX_DEFAULT);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_PRIORITY:{
          t = jj_consume_token(T_HX_PRIORITY);
sink = sink .start(makeTConstructor(sink, t, hx(t.toString()), null)) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[137] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("Normal"), null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRulePriority");
    }
  }

/** <em>HxRuleOptions$WithEOF</em> ::= <em>HxRuleOptions</em> EOF . */
  final public net.sf.crsx.Sink N_HxRuleOptions$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRuleOptions$WithEOF");
    try {
      sink = N_HxRuleOptions(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRuleOptions$WithEOF");
    }
  }

/**
 * <em>HxRuleOptions</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxTopPattern">&lang;HxTopPattern&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxRuleOptions">&lang;HxRuleOptions&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxRuleOptions(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRuleOptions");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRuleOptions:{
        t = jj_consume_token(MT_HxRuleOptions);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_39:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[139] = jj_gen;
              break label_39;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[140] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRuleOptions:{
        jj_consume_token(IT_HxRuleOptions);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxTopPattern:
      case IT_HxTopPattern:
      case MT_HxConstructor:
      case IT_HxConstructor:
      case MT_HxPattern:
      case IT_HxPattern:
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxTopPattern(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_COMMA:{
          jj_consume_token(T_HX_COMMA);
          sink = N_HxRuleOptions(sink, env);
          break;
          }
        default:
          jj_la1[141] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[142] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRuleOptions");
    }
  }

/* "Last top level sort name" hack. */
  final public 
net.sf.crsx.Sink N_Store_HxSortName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Store_HxSortName");
    try {net.sf.crsx.util.Buffer b = new net.sf.crsx.util.Buffer(sink);
      N_HxSortName(b.sink(), env);
net.sf.crsx.Term term = b.term(false);
                storedSort = net.sf.crsx.util.Util.symbol(term);
                {if ("" != null) return term.copy(sink, true, net.sf.crsx.util.LinkedExtensibleMap.EMPTY_RENAMING);}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Store_HxSortName");
    }
  }

  final public net.sf.crsx.Sink N_Restoring_HxDeclarations(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Restoring_HxDeclarations");
    try {String savedStoredSort = storedSort;
      sink = N_HxDeclarations(sink, env);
storedSort = savedStoredSort;
                {if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Restoring_HxDeclarations");
    }
  }

/** <em>HxTopTerm$WithEOF</em> ::= <em>HxTopTerm</em> EOF . */
  final public net.sf.crsx.Sink N_HxTopTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTopTerm$WithEOF");
    try {
      sink = N_HxTopTerm(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTopTerm$WithEOF");
    }
  }

/**
 * <em>HxTopTerm</em> ::=  <a href="#N_HxTerm">&lang;HxTerm&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxTopTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTopTerm");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxTopTerm:{
        t = jj_consume_token(MT_HxTopTerm);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_40:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[143] = jj_gen;
              break label_40;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[144] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxTopTerm:{
        jj_consume_token(IT_HxTopTerm);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxConstructor:
      case IT_HxConstructor:
      case MT_HxTerm:
      case IT_HxTerm:
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:
      case MT_HxVariable:
      case IT_HxVariable:
      case MT_HxMetaVariable:
      case IT_HxMetaVariable:
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_META:
      case T_HX_VAR:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:
      case T_HX_CONSTRUCTOR:{
        sink = N_HxTerm(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[145] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTopTerm");
    }
  }

/** <em>HxTopPattern$WithEOF</em> ::= <em>HxTopPattern</em> EOF . */
  final public net.sf.crsx.Sink N_HxTopPattern$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTopPattern$WithEOF");
    try {
      sink = N_HxTopPattern(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTopPattern$WithEOF");
    }
  }

/**
 * <em>HxTopPattern</em> ::=  <a href="#N_HxPattern">&lang;HxPattern&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxTopPattern(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTopPattern");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxTopPattern:{
        t = jj_consume_token(MT_HxTopPattern);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_41:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[146] = jj_gen;
              break label_41;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[147] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxTopPattern:{
        jj_consume_token(IT_HxTopPattern);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxConstructor:
      case IT_HxConstructor:
      case MT_HxPattern:
      case IT_HxPattern:
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:
      case T_HX_CONSTRUCTOR:{
        sink = N_HxPattern(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[148] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTopPattern");
    }
  }

/** <em>HxAttributes$WithEOF</em> ::= <em>HxAttributes</em> EOF . */
  final public net.sf.crsx.Sink N_HxAttributes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributes$WithEOF");
    try {
      sink = N_HxAttributes(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributes$WithEOF");
    }
  }

/**
 * <em>HxAttributes</em> ::=  (  <font color="red">{$Cons}</font>   <a href="#N_HxAttribute">&lang;HxAttribute&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxAttributes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributes");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxAttributes:{
        t = jj_consume_token(MT_HxAttributes);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_42:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[149] = jj_gen;
              break label_42;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[150] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxAttributes:{
        jj_consume_token(IT_HxAttributes);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[152] = jj_gen;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxAttributeKind:
        case IT_HxAttributeKind:
        case MT_HxAttribute:
        case IT_HxAttribute:
        case T_HX_UP:
        case T_HX_DOWN:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
          sink = N_HxAttribute(sink, env);
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[151] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributes");
    }
  }

/** <em>HxSortName$WithEOF</em> ::= <em>HxSortName</em> EOF . */
  final public net.sf.crsx.Sink N_HxSortName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortName$WithEOF");
    try {
      sink = N_HxSortName(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortName$WithEOF");
    }
  }

/**
 * <em>HxSortName</em> ::=   <a href="#T_HX_CONSTRUCTOR">HX_CONSTRUCTOR</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxSortName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSortName");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSortName:{
        t = jj_consume_token(MT_HxSortName);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_43:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[153] = jj_gen;
              break label_43;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[154] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSortName:{
        jj_consume_token(IT_HxSortName);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CONSTRUCTOR:{
        t = jj_consume_token(T_HX_CONSTRUCTOR);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[155] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSortName");
    }
  }

/** <em>HxConstructor$WithEOF</em> ::= <em>HxConstructor</em> EOF . */
  final public net.sf.crsx.Sink N_HxConstructor$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxConstructor$WithEOF");
    try {
      sink = N_HxConstructor(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxConstructor$WithEOF");
    }
  }

/**
 * <em>HxConstructor</em> ::=   <a href="#T_HX_CONSTRUCTOR">HX_CONSTRUCTOR</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxConstructor(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxConstructor");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxConstructor:{
        t = jj_consume_token(MT_HxConstructor);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_44:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[156] = jj_gen;
              break label_44;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[157] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxConstructor:{
        jj_consume_token(IT_HxConstructor);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CONSTRUCTOR:{
        t = jj_consume_token(T_HX_CONSTRUCTOR);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[158] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxConstructor");
    }
  }

/** <em>HxTerm$WithEOF</em> ::= <em>HxTerm</em> EOF . */
  final public net.sf.crsx.Sink N_HxTerm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTerm$WithEOF");
    try {
      sink = N_HxTerm(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTerm$WithEOF");
    }
  }

/**
 * <em>HxTerm</em> ::=  <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!:#v</font>   (  <font color="red">{Special}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>   <a href="#N_HxConcreteText">&lang;HxConcreteText&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{VariableUse}</font><font color="red">:hx</font>   <font color="red">{{#v}}</font>   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   )  <br>
 *  |  <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a> <font color="red">:#C</font>   <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{UnparsedSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxConcrete">&lang;HxConcrete&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{MetaApplicationSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>    (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   (  <a href="#N_HxTerms">&lang;HxTerms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a>    (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{VariableUseSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{LiteralSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxLiteral">&lang;HxLiteral&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:hx</font>   <a href="#N_HxLiteral">&lang;HxLiteral&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   <br>
 *  |  <font color="red">{Unparsed}</font><font color="red">:hx</font>   <a href="#N_HxConcrete">&lang;HxConcrete&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   <br>
 *  |  <font color="red">{MetaApplication}</font><font color="red">:hx</font>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>    (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   (  <a href="#N_HxTerms">&lang;HxTerms&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxTerm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTerm");
    try {net.sf.crsx.Variable v_HxVariable = null;
        net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs__C = null;
        String s_HxVariable = null;
        net.sf.crsx.Variable v__v = null;
        String c9 = null;
        net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
        String s__v = null;
        Token t = null;
        net.sf.crsx.Sink bs_HxVariable = null;
        net.sf.crsx.util.Buffer b__v = new net.sf.crsx.util.Buffer(sink);
        String c0 = null;
        net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs__R = null;
        net.sf.crsx.Sink bs__v = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxTerm:{
        t = jj_consume_token(MT_HxTerm);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_45:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[159] = jj_gen;
              break label_45;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[160] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxTerm:{
        jj_consume_token(IT_HxTerm);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:{
bs__v = b__v.sink();
        N_HxVariable(bs__v, env);
if (b__v.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b__v.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b__v.term(false)+")");}
                c0 = b__v.term(true).constructor().symbol();
                s__v = c0;
                v__v = (env.containsKey(s__v) ? env.get(s__v) : factory.freeVariable(s__v, true, true));
                if (v__v == null) {if (true) throw new ParseException("Variable "+s__v+" cannot be resolved?");}
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxConcreteText:
        case IT_HxConcreteText:
        case T_HX_CONCRETE:{
sink = sink .start(makeTConstructor(sink, t, hx("Special"), null)) ;
sink = sink .use(v__v) ;
          sink = N_HxConcreteText(sink, env);
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[161] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("VariableUse"), null)) ;
sink = sink .use(v__v) ;
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
        }
{if ("" != null) return sink;}
        break;
        }
      case MT_HxConstructor:
      case IT_HxConstructor:
      case T_HX_CONSTRUCTOR:{
bs__C = b__C.sink();
        N_HxConstructor(bs__C, env);
bs__R = b__R.sink();
        N_HxRepeat(bs__R, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxConcrete:
        case IT_HxConcrete:
        case T_HX_CONCRETE:{
sink = sink .start(makeTConstructor(sink, t, hx("UnparsedSorted"), null)) ;
sink = sink .copy(b__C, true) ;
sink = sink .copy(b__R, true) ;
          sink = N_HxConcrete(sink, env);
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        case MT_HxMetaVariable:
        case IT_HxMetaVariable:
        case T_HX_META:{
sink = sink .start(makeTConstructor(sink, t, hx("MetaApplicationSorted"), null)) ;
sink = sink .copy(b__C, true) ;
sink = sink .copy(b__R, true) ;
          sink = N_HxMetaVariable(sink, env);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case T_HX_LBRACKET:{
            jj_consume_token(T_HX_LBRACKET);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case MT_HxConstructor:
            case IT_HxConstructor:
            case MT_HxTerm:
            case IT_HxTerm:
            case MT_HxTerms:
            case IT_HxTerms:
            case MT_HxConcrete:
            case IT_HxConcrete:
            case T_HX_CONCRETE:
            case MT_HxVariable:
            case IT_HxVariable:
            case MT_HxMetaVariable:
            case IT_HxMetaVariable:
            case MT_HxLiteral:
            case IT_HxLiteral:
            case MT_HxNumber:
            case IT_HxNumber:
            case MT_HxNatural:
            case IT_HxNatural:
            case MT_HxString:
            case IT_HxString:
            case T_HX_META:
            case T_HX_VAR:
            case T_HX_NATURAL:
            case T_HX_UNNATURAL:
            case T_HX_STRING:
            case T_HX_CONSTRUCTOR:{
              sink = N_HxTerms(sink, env);
              break;
              }
            default:
              jj_la1[162] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
            }
            jj_consume_token(T_HX_RBRACKET);
            break;
            }
          default:
            jj_la1[163] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
          }
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        case MT_HxConstructor:
        case IT_HxConstructor:
        case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, hx("ConstructionSorted"), null)) ;
sink = sink .copy(b__C, true) ;
sink = sink .copy(b__R, true) ;
          sink = N_HxConstructor(sink, env);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case T_HX_LPAREN:{
            jj_consume_token(T_HX_LPAREN);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case MT_HxConstructor:
            case IT_HxConstructor:
            case MT_HxTerm:
            case IT_HxTerm:
            case MT_HxScopes:
            case IT_HxScopes:
            case MT_HxScope:
            case IT_HxScope:
            case MT_HxConcrete:
            case IT_HxConcrete:
            case T_HX_CONCRETE:
            case MT_HxVariable:
            case IT_HxVariable:
            case MT_HxMetaVariable:
            case IT_HxMetaVariable:
            case MT_HxLiteral:
            case IT_HxLiteral:
            case MT_HxNumber:
            case IT_HxNumber:
            case MT_HxNatural:
            case IT_HxNatural:
            case MT_HxString:
            case IT_HxString:
            case T_HX_LBRACKET:
            case T_HX_META:
            case T_HX_VAR:
            case T_HX_NATURAL:
            case T_HX_UNNATURAL:
            case T_HX_STRING:
            case T_HX_CONSTRUCTOR:{
              sink = N_HxScopes(sink, env);
              break;
              }
            default:
              jj_la1[164] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
            }
            jj_consume_token(T_HX_RPAREN);
            break;
            }
          default:
            jj_la1[165] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
          }
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        case MT_HxVariable:
        case IT_HxVariable:
        case T_HX_VAR:{
sink = sink .start(makeTConstructor(sink, t, hx("VariableUseSorted"), null)) ;
sink = sink .copy(b__C, true) ;
sink = sink .copy(b__R, true) ;
bs_HxVariable = b_HxVariable.sink();
          N_HxVariable(bs_HxVariable, env);
if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
                         {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");}
                        c9 = b_HxVariable.term(true).constructor().symbol();
                        s_HxVariable = c9;
                        v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
                        if (v_HxVariable == null) {if (true) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");}
                        sink = sink .use(v_HxVariable) ;
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        case MT_HxLiteral:
        case IT_HxLiteral:
        case MT_HxNumber:
        case IT_HxNumber:
        case MT_HxNatural:
        case IT_HxNatural:
        case MT_HxString:
        case IT_HxString:
        case T_HX_NATURAL:
        case T_HX_UNNATURAL:
        case T_HX_STRING:{
sink = sink .start(makeTConstructor(sink, t, hx("LiteralSorted"), null)) ;
sink = sink .copy(b__C, true) ;
sink = sink .copy(b__R, true) ;
          sink = N_HxLiteral(sink, env);
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[168] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("Construction"), null)) ;
sink = sink .copy(b__C, true) ;
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case T_HX_LPAREN:{
            jj_consume_token(T_HX_LPAREN);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case MT_HxConstructor:
            case IT_HxConstructor:
            case MT_HxTerm:
            case IT_HxTerm:
            case MT_HxScopes:
            case IT_HxScopes:
            case MT_HxScope:
            case IT_HxScope:
            case MT_HxConcrete:
            case IT_HxConcrete:
            case T_HX_CONCRETE:
            case MT_HxVariable:
            case IT_HxVariable:
            case MT_HxMetaVariable:
            case IT_HxMetaVariable:
            case MT_HxLiteral:
            case IT_HxLiteral:
            case MT_HxNumber:
            case IT_HxNumber:
            case MT_HxNatural:
            case IT_HxNatural:
            case MT_HxString:
            case IT_HxString:
            case T_HX_LBRACKET:
            case T_HX_META:
            case T_HX_VAR:
            case T_HX_NATURAL:
            case T_HX_UNNATURAL:
            case T_HX_STRING:
            case T_HX_CONSTRUCTOR:{
              sink = N_HxScopes(sink, env);
              break;
              }
            default:
              jj_la1[166] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
            }
            jj_consume_token(T_HX_RPAREN);
            break;
            }
          default:
            jj_la1[167] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
          }
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
        }
{if ("" != null) return sink;}
        break;
        }
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:{
sink = sink .start(makeTConstructor(sink, t, hx("Literal"), null)) ;
        sink = N_HxLiteral(sink, env);
        sink = N_HxAttributes(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:{
sink = sink .start(makeTConstructor(sink, t, hx("Unparsed"), null)) ;
        sink = N_HxConcrete(sink, env);
        sink = N_HxAttributes(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxMetaVariable:
      case IT_HxMetaVariable:
      case T_HX_META:{
sink = sink .start(makeTConstructor(sink, t, hx("MetaApplication"), null)) ;
        sink = N_HxMetaVariable(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_LBRACKET:{
          jj_consume_token(T_HX_LBRACKET);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case MT_HxConstructor:
          case IT_HxConstructor:
          case MT_HxTerm:
          case IT_HxTerm:
          case MT_HxTerms:
          case IT_HxTerms:
          case MT_HxConcrete:
          case IT_HxConcrete:
          case T_HX_CONCRETE:
          case MT_HxVariable:
          case IT_HxVariable:
          case MT_HxMetaVariable:
          case IT_HxMetaVariable:
          case MT_HxLiteral:
          case IT_HxLiteral:
          case MT_HxNumber:
          case IT_HxNumber:
          case MT_HxNatural:
          case IT_HxNatural:
          case MT_HxString:
          case IT_HxString:
          case T_HX_META:
          case T_HX_VAR:
          case T_HX_NATURAL:
          case T_HX_UNNATURAL:
          case T_HX_STRING:
          case T_HX_CONSTRUCTOR:{
            sink = N_HxTerms(sink, env);
            break;
            }
          default:
            jj_la1[169] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
          }
          jj_consume_token(T_HX_RBRACKET);
          break;
          }
        default:
          jj_la1[170] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
        sink = N_HxAttributes(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[171] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTerm");
    }
  }

/**
 * <em>HxPattern</em> ::=  <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a> <font color="red">:#C</font>   <a href="#N_HxRepeat">&lang;HxRepeat&rang;</a> <font color="red">:#R</font>   (  <font color="red">{UnparsedSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxConcrete">&lang;HxConcrete&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{ConstructionSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxConstructor">&lang;HxConstructor&rang;</a>    (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{LiteralSorted}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   <font color="red">{{#R}}</font>   <a href="#N_HxLiteral">&lang;HxLiteral&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   |  <font color="red">{Construction}</font><font color="red">:hx</font>   <font color="red">{{#C}}</font>   (   <a href="#T_HX_LPAREN">HX_LPAREN</a>   (  <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RPAREN">HX_RPAREN</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   )  <br>
 *  |  <font color="red">{Literal}</font><font color="red">:hx</font>   <a href="#N_HxLiteral">&lang;HxLiteral&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>   <br>
 *  |  <font color="red">{Unparsed}</font><font color="red">:hx</font>   <a href="#N_HxConcrete">&lang;HxConcrete&rang;</a>    <a href="#N_HxAttributes">&lang;HxAttributes&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxPattern(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxPattern");
    try {net.sf.crsx.util.Buffer b__R = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__C = new net.sf.crsx.util.Buffer(sink);
        Token t = null;
        net.sf.crsx.Sink bs__C = null;
        net.sf.crsx.Sink bs__R = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxPattern:{
        t = jj_consume_token(MT_HxPattern);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_46:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[172] = jj_gen;
              break label_46;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[173] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxPattern:{
        jj_consume_token(IT_HxPattern);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxConstructor:
      case IT_HxConstructor:
      case T_HX_CONSTRUCTOR:{
bs__C = b__C.sink();
        N_HxConstructor(bs__C, env);
bs__R = b__R.sink();
        N_HxRepeat(bs__R, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxConcrete:
        case IT_HxConcrete:
        case T_HX_CONCRETE:{
sink = sink .start(makeTConstructor(sink, t, hx("UnparsedSorted"), null)) ;
sink = sink .copy(b__C, true) ;
sink = sink .copy(b__R, true) ;
          sink = N_HxConcrete(sink, env);
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        case MT_HxConstructor:
        case IT_HxConstructor:
        case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, hx("ConstructionSorted"), null)) ;
sink = sink .copy(b__C, true) ;
sink = sink .copy(b__R, true) ;
          sink = N_HxConstructor(sink, env);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case T_HX_LPAREN:{
            jj_consume_token(T_HX_LPAREN);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case MT_HxConstructor:
            case IT_HxConstructor:
            case MT_HxTerm:
            case IT_HxTerm:
            case MT_HxScopes:
            case IT_HxScopes:
            case MT_HxScope:
            case IT_HxScope:
            case MT_HxConcrete:
            case IT_HxConcrete:
            case T_HX_CONCRETE:
            case MT_HxVariable:
            case IT_HxVariable:
            case MT_HxMetaVariable:
            case IT_HxMetaVariable:
            case MT_HxLiteral:
            case IT_HxLiteral:
            case MT_HxNumber:
            case IT_HxNumber:
            case MT_HxNatural:
            case IT_HxNatural:
            case MT_HxString:
            case IT_HxString:
            case T_HX_LBRACKET:
            case T_HX_META:
            case T_HX_VAR:
            case T_HX_NATURAL:
            case T_HX_UNNATURAL:
            case T_HX_STRING:
            case T_HX_CONSTRUCTOR:{
              sink = N_HxScopes(sink, env);
              break;
              }
            default:
              jj_la1[174] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
            }
            jj_consume_token(T_HX_RPAREN);
            break;
            }
          default:
            jj_la1[175] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
          }
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        case MT_HxLiteral:
        case IT_HxLiteral:
        case MT_HxNumber:
        case IT_HxNumber:
        case MT_HxNatural:
        case IT_HxNatural:
        case MT_HxString:
        case IT_HxString:
        case T_HX_NATURAL:
        case T_HX_UNNATURAL:
        case T_HX_STRING:{
sink = sink .start(makeTConstructor(sink, t, hx("LiteralSorted"), null)) ;
sink = sink .copy(b__C, true) ;
sink = sink .copy(b__R, true) ;
          sink = N_HxLiteral(sink, env);
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[178] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("Construction"), null)) ;
sink = sink .copy(b__C, true) ;
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case T_HX_LPAREN:{
            jj_consume_token(T_HX_LPAREN);
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case MT_HxConstructor:
            case IT_HxConstructor:
            case MT_HxTerm:
            case IT_HxTerm:
            case MT_HxScopes:
            case IT_HxScopes:
            case MT_HxScope:
            case IT_HxScope:
            case MT_HxConcrete:
            case IT_HxConcrete:
            case T_HX_CONCRETE:
            case MT_HxVariable:
            case IT_HxVariable:
            case MT_HxMetaVariable:
            case IT_HxMetaVariable:
            case MT_HxLiteral:
            case IT_HxLiteral:
            case MT_HxNumber:
            case IT_HxNumber:
            case MT_HxNatural:
            case IT_HxNatural:
            case MT_HxString:
            case IT_HxString:
            case T_HX_LBRACKET:
            case T_HX_META:
            case T_HX_VAR:
            case T_HX_NATURAL:
            case T_HX_UNNATURAL:
            case T_HX_STRING:
            case T_HX_CONSTRUCTOR:{
              sink = N_HxScopes(sink, env);
              break;
              }
            default:
              jj_la1[176] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
            }
            jj_consume_token(T_HX_RPAREN);
            break;
            }
          default:
            jj_la1[177] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
          }
          sink = N_HxAttributes(sink, env);
sink = sink .end() ;
        }
{if ("" != null) return sink;}
        break;
        }
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:{
sink = sink .start(makeTConstructor(sink, t, hx("Literal"), null)) ;
        sink = N_HxLiteral(sink, env);
        sink = N_HxAttributes(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:{
sink = sink .start(makeTConstructor(sink, t, hx("Unparsed"), null)) ;
        sink = N_HxConcrete(sink, env);
        sink = N_HxAttributes(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[179] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxPattern");
    }
  }

/** <em>HxScopes$WithEOF</em> ::= <em>HxScopes</em> EOF . */
  final public net.sf.crsx.Sink N_HxScopes$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxScopes$WithEOF");
    try {
      sink = N_HxScopes(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxScopes$WithEOF");
    }
  }

/**
 * <em>HxScopes</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxScope">&lang;HxScope&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxScopes">&lang;HxScopes&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxScopes(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxScopes");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxScopes:{
        t = jj_consume_token(MT_HxScopes);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_47:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[180] = jj_gen;
              break label_47;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[181] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxScopes:{
        jj_consume_token(IT_HxScopes);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxConstructor:
      case IT_HxConstructor:
      case MT_HxTerm:
      case IT_HxTerm:
      case MT_HxScope:
      case IT_HxScope:
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:
      case MT_HxVariable:
      case IT_HxVariable:
      case MT_HxMetaVariable:
      case IT_HxMetaVariable:
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_LBRACKET:
      case T_HX_META:
      case T_HX_VAR:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxScope(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_COMMA:{
          jj_consume_token(T_HX_COMMA);
          sink = N_HxScopes(sink, env);
          break;
          }
        default:
          jj_la1[182] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[183] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxScopes");
    }
  }

/** <em>HxScope$WithEOF</em> ::= <em>HxScope</em> EOF . */
  final public net.sf.crsx.Sink N_HxScope$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxScope$WithEOF");
    try {
      sink = N_HxScope(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxScope$WithEOF");
    }
  }

/**
 * <em>HxScope</em> ::=  <font color="red">{Scope}</font><font color="red">:hx</font>   (   <a href="#T_HX_LBRACKET">HX_LBRACKET</a>   (  <a href="#N_HxVariableList">&lang;HxVariableList&rang;</a>   |  <font color="red">{$Nil}</font>  )    <a href="#T_HX_RBRACKET">HX_RBRACKET</a>  |  <font color="red">{$Nil}</font>  )   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxScope(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxScope");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxScope:{
        t = jj_consume_token(MT_HxScope);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_48:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[184] = jj_gen;
              break label_48;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[185] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxScope:{
        jj_consume_token(IT_HxScope);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxConstructor:
      case IT_HxConstructor:
      case MT_HxTerm:
      case IT_HxTerm:
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:
      case MT_HxVariable:
      case IT_HxVariable:
      case MT_HxMetaVariable:
      case IT_HxMetaVariable:
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_LBRACKET:
      case T_HX_META:
      case T_HX_VAR:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, hx("Scope"), null)) ;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_LBRACKET:{
          jj_consume_token(T_HX_LBRACKET);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case MT_HxVariableList:
          case IT_HxVariableList:
          case MT_HxVariable:
          case IT_HxVariable:
          case T_HX_VAR:{
            sink = N_HxVariableList(sink, env);
            break;
            }
          default:
            jj_la1[186] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
          }
          jj_consume_token(T_HX_RBRACKET);
          break;
          }
        default:
          jj_la1[187] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
        sink = N_HxTerm(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[188] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxScope");
    }
  }

/** <em>HxVariables$WithEOF</em> ::= <em>HxVariables</em> EOF . */
  final public net.sf.crsx.Sink N_HxVariables$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxVariables$WithEOF");
    try {
      sink = N_HxVariables(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxVariables$WithEOF");
    }
  }

/**
 * <em>HxVariables</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>   <a href="#N_HxVariables">&lang;HxVariables&rang;</a>   <br>
 *  |  <font color="red">{$Nil}</font> 
 */
  final public net.sf.crsx.Sink N_HxVariables(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxVariables");
    try {net.sf.crsx.Variable v_HxVariable = null;
        Token t = null;
        net.sf.crsx.Sink bs_HxVariable = null;
        String c0 = null;
        net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
        String s_HxVariable = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxVariables:{
        t = jj_consume_token(MT_HxVariables);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_49:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[189] = jj_gen;
              break label_49;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[190] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxVariables:{
        jj_consume_token(IT_HxVariables);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
bs_HxVariable = b_HxVariable.sink();
        N_HxVariable(bs_HxVariable, env);
if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");}
                c0 = b_HxVariable.term(true).constructor().symbol();
                s_HxVariable = c0;
                v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
                if (v_HxVariable == null) {if (true) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");}
                sink = sink .use(v_HxVariable) ;
        sink = N_HxVariables(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[191] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxVariables");
    }
  }

/**
 * <em>HxVariableList</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>   (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxVariableList">&lang;HxVariableList&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxVariableList(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxVariableList");
    try {net.sf.crsx.Variable v_HxVariable = null;
        Token t = null;
        net.sf.crsx.Sink bs_HxVariable = null;
        String c0 = null;
        net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
        String s_HxVariable = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxVariableList:{
        t = jj_consume_token(MT_HxVariableList);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_50:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[192] = jj_gen;
              break label_50;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[193] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxVariableList:{
        jj_consume_token(IT_HxVariableList);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
bs_HxVariable = b_HxVariable.sink();
        N_HxVariable(bs_HxVariable, env);
if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
                 {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");}
                c0 = b_HxVariable.term(true).constructor().symbol();
                s_HxVariable = c0;
                v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
                if (v_HxVariable == null) {if (true) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");}
                sink = sink .use(v_HxVariable) ;
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_COMMA:{
          jj_consume_token(T_HX_COMMA);
          sink = N_HxVariableList(sink, env);
          break;
          }
        default:
          jj_la1[194] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[195] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxVariableList");
    }
  }

/** <em>HxTerms$WithEOF</em> ::= <em>HxTerms</em> EOF . */
  final public net.sf.crsx.Sink N_HxTerms$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTerms$WithEOF");
    try {
      sink = N_HxTerms(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTerms$WithEOF");
    }
  }

/**
 * <em>HxTerms</em> ::=  <font color="red">{$Cons}</font>   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>    (   <a href="#T_HX_COMMA">HX_COMMA</a>   <a href="#N_HxTerms">&lang;HxTerms&rang;</a>   |  <font color="red">{$Nil}</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxTerms(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTerms");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxTerms:{
        t = jj_consume_token(MT_HxTerms);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_51:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[196] = jj_gen;
              break label_51;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[197] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxTerms:{
        jj_consume_token(IT_HxTerms);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxConstructor:
      case IT_HxConstructor:
      case MT_HxTerm:
      case IT_HxTerm:
      case MT_HxConcrete:
      case IT_HxConcrete:
      case T_HX_CONCRETE:
      case MT_HxVariable:
      case IT_HxVariable:
      case MT_HxMetaVariable:
      case IT_HxMetaVariable:
      case MT_HxLiteral:
      case IT_HxLiteral:
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_META:
      case T_HX_VAR:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:
      case T_HX_CONSTRUCTOR:{
sink = sink .start(makeTConstructor(sink, t, "$Cons", null)) ;
        sink = N_HxTerm(sink, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_COMMA:{
          jj_consume_token(T_HX_COMMA);
          sink = N_HxTerms(sink, env);
          break;
          }
        default:
          jj_la1[198] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, "$Nil", null)) ;
sink = sink .end() ;
        }
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[199] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTerms");
    }
  }

/** <em>HxAttribute$WithEOF</em> ::= <em>HxAttribute</em> EOF . */
  final public net.sf.crsx.Sink N_HxAttribute$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttribute$WithEOF");
    try {
      sink = N_HxAttribute(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttribute$WithEOF");
    }
  }

/**
 * <em>HxAttribute</em> ::=  <a href="#N_HxAttributeKind">&lang;HxAttributeKind&rang;</a> <font color="red">:#kind</font>   (  <font color="red">{Attribute}</font><font color="red">:hx</font>   <font color="red">{{#kind}}</font>   <a href="#N_HxAttributeName">&lang;HxAttributeName&rang;</a>    <a href="#N_HxAttributeValue">&lang;HxAttributeValue&rang;</a>   |  <font color="red">{CatchAllAttributes}</font><font color="red">:hx</font>   <font color="red">{{#kind}}</font>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>   |  <a href="#N_HxSystemAttribute">&lang;HxSystemAttribute&rang;</a>   ) 
 */
  final public net.sf.crsx.Sink N_HxAttribute(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttribute");
    try {Token t = null;
        net.sf.crsx.Sink bs__kind = null;
        net.sf.crsx.util.Buffer b__kind = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxAttribute:{
        t = jj_consume_token(MT_HxAttribute);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_52:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[200] = jj_gen;
              break label_52;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[201] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxAttribute:{
        jj_consume_token(IT_HxAttribute);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxAttributeKind:
      case IT_HxAttributeKind:
      case T_HX_UP:
      case T_HX_DOWN:{
bs__kind = b__kind.sink();
        N_HxAttributeKind(bs__kind, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxAttributeName:
        case IT_HxAttributeName:
        case T_HX_VAR:{
sink = sink .start(makeTConstructor(sink, t, hx("Attribute"), null)) ;
sink = sink .copy(b__kind, true) ;
          sink = N_HxAttributeName(sink, env);
          sink = N_HxAttributeValue(sink, env);
sink = sink .end() ;
          break;
          }
        case MT_HxMetaVariable:
        case IT_HxMetaVariable:
        case T_HX_META:{
sink = sink .start(makeTConstructor(sink, t, hx("CatchAllAttributes"), null)) ;
sink = sink .copy(b__kind, true) ;
          sink = N_HxMetaVariable(sink, env);
sink = sink .end() ;
          break;
          }
        case MT_HxSystemAttribute:
        case IT_HxSystemAttribute:
        case T_HX_DOT:{
          sink = N_HxSystemAttribute(sink, env);
          break;
          }
        default:
          jj_la1[202] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[203] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttribute");
    }
  }

/**
 * <em>HxSystemAttribute</em> ::=  <font color="red">{SystemAttribute}</font><font color="red">:hx</font>    <a href="#T_HX_DOT">HX_DOT</a>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a>     <a href="#T_HX_LPAREN">HX_LPAREN</a>   <a href="#N_HxTopPattern">&lang;HxTopPattern&rang;</a>     <a href="#T_HX_RPAREN">HX_RPAREN</a> 
 */
  final public net.sf.crsx.Sink N_HxSystemAttribute(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSystemAttribute");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSystemAttribute:{
        t = jj_consume_token(MT_HxSystemAttribute);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_53:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[204] = jj_gen;
              break label_53;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[205] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSystemAttribute:{
        jj_consume_token(IT_HxSystemAttribute);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_DOT:{
sink = sink .start(makeTConstructor(sink, t, hx("SystemAttribute"), null)) ;
        jj_consume_token(T_HX_DOT);
        sink = N_HxVariable(sink, env);
        jj_consume_token(T_HX_LPAREN);
        sink = N_HxTopPattern(sink, env);
        jj_consume_token(T_HX_RPAREN);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[206] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSystemAttribute");
    }
  }

/** <em>HxAttributeValue$WithEOF</em> ::= <em>HxAttributeValue</em> EOF . */
  final public net.sf.crsx.Sink N_HxAttributeValue$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributeValue$WithEOF");
    try {
      sink = N_HxAttributeValue(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributeValue$WithEOF");
    }
  }

/**
 * <em>HxAttributeValue</em> ::=  <font color="red">{AttributeValue}</font><font color="red">:hx</font>    <a href="#T_HX_LPAREN">HX_LPAREN</a>   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>     <a href="#T_HX_RPAREN">HX_RPAREN</a>  <br>
 *  |   <a href="#T_HX_LBRACE">HX_LBRACE</a>   (  (  <a href="#N_HxTerm">&lang;HxTerm&rang;</a> <font color="red">:#</font>   (  <font color="red">{AttributeKeyValue}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>    <a href="#T_HX_COLON">HX_COLON</a>   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>   |  <font color="red">{AttributeKey}</font><font color="red">:hx</font>   <font color="red">{{#}}</font>  )  )  |  <font color="red">{AttributeCatchAll}</font><font color="red">:hx</font>    <a href="#T_HX_COLON">HX_COLON</a>   <a href="#N_HxMetaVariable">&lang;HxMetaVariable&rang;</a>   |  <font color="red">{AttributeNotKey}</font><font color="red">:hx</font>    <a href="#T_HX_NOT">HX_NOT</a>   <a href="#N_HxTerm">&lang;HxTerm&rang;</a>   )    <a href="#T_HX_RBRACE">HX_RBRACE</a> 
 */
  final public net.sf.crsx.Sink N_HxAttributeValue(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributeValue");
    try {Token t = null;
        net.sf.crsx.Sink bs__ = null;
        net.sf.crsx.util.Buffer b__ = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxAttributeValue:{
        t = jj_consume_token(MT_HxAttributeValue);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_54:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[207] = jj_gen;
              break label_54;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[208] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxAttributeValue:{
        jj_consume_token(IT_HxAttributeValue);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_LPAREN:{
sink = sink .start(makeTConstructor(sink, t, hx("AttributeValue"), null)) ;
        jj_consume_token(T_HX_LPAREN);
        sink = N_HxTerm(sink, env);
        jj_consume_token(T_HX_RPAREN);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_LBRACE:{
        jj_consume_token(T_HX_LBRACE);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxConstructor:
        case IT_HxConstructor:
        case MT_HxTerm:
        case IT_HxTerm:
        case MT_HxConcrete:
        case IT_HxConcrete:
        case T_HX_CONCRETE:
        case MT_HxVariable:
        case IT_HxVariable:
        case MT_HxMetaVariable:
        case IT_HxMetaVariable:
        case MT_HxLiteral:
        case IT_HxLiteral:
        case MT_HxNumber:
        case IT_HxNumber:
        case MT_HxNatural:
        case IT_HxNatural:
        case MT_HxString:
        case IT_HxString:
        case T_HX_META:
        case T_HX_VAR:
        case T_HX_NATURAL:
        case T_HX_UNNATURAL:
        case T_HX_STRING:
        case T_HX_CONSTRUCTOR:{
bs__ = b__.sink();
          N_HxTerm(bs__, env);
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case T_HX_COLON:{
sink = sink .start(makeTConstructor(sink, t, hx("AttributeKeyValue"), null)) ;
sink = sink .copy(b__, true) ;
            jj_consume_token(T_HX_COLON);
            sink = N_HxTerm(sink, env);
sink = sink .end() ;
            break;
            }
          default:
            jj_la1[209] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("AttributeKey"), null)) ;
sink = sink .copy(b__, true) ;
sink = sink .end() ;
          }
          break;
          }
        case T_HX_COLON:{
sink = sink .start(makeTConstructor(sink, t, hx("AttributeCatchAll"), null)) ;
          jj_consume_token(T_HX_COLON);
          sink = N_HxMetaVariable(sink, env);
sink = sink .end() ;
          break;
          }
        case T_HX_NOT:{
sink = sink .start(makeTConstructor(sink, t, hx("AttributeNotKey"), null)) ;
          jj_consume_token(T_HX_NOT);
          sink = N_HxTerm(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[210] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(T_HX_RBRACE);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[211] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributeValue");
    }
  }

/** <em>HxConcrete$WithEOF</em> ::= <em>HxConcrete</em> EOF . */
  final public net.sf.crsx.Sink N_HxConcrete$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxConcrete$WithEOF");
    try {
      sink = N_HxConcrete(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxConcrete$WithEOF");
    }
  }

/**
 * <em>HxConcrete</em> ::=   <a href="#T_HX_CONCRETE">HX_CONCRETE</a><font color="red">$:unwrap</font> 
 */
  final public net.sf.crsx.Sink N_HxConcrete(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxConcrete");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxConcrete:{
        t = jj_consume_token(MT_HxConcrete);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_55:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[212] = jj_gen;
              break label_55;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[213] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxConcrete:{
        jj_consume_token(IT_HxConcrete);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CONCRETE:{
        t = jj_consume_token(T_HX_CONCRETE);
sink = sink .start(makeTConstructor(sink, t, unwrap(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[214] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxConcrete");
    }
  }

/** <em>HxConcreteText$WithEOF</em> ::= <em>HxConcreteText</em> EOF . */
  final public net.sf.crsx.Sink N_HxConcreteText$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxConcreteText$WithEOF");
    try {
      sink = N_HxConcreteText(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxConcreteText$WithEOF");
    }
  }

/**
 * <em>HxConcreteText</em> ::=   <a href="#T_HX_CONCRETE">HX_CONCRETE</a><font color="red">$$:unwrap:{n}</font> 
 */
  final public net.sf.crsx.Sink N_HxConcreteText(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxConcreteText");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxConcreteText:{
        t = jj_consume_token(MT_HxConcreteText);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_56:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[215] = jj_gen;
              break label_56;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[216] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxConcreteText:{
        jj_consume_token(IT_HxConcreteText);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CONCRETE:{
        t = jj_consume_token(T_HX_CONCRETE);
try {sink = factory.parser(factory).parse(sink, "n", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[217] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxConcreteText");
    }
  }

/** <em>HxModuleName$WithEOF</em> ::= <em>HxModuleName</em> EOF . */
  final public net.sf.crsx.Sink N_HxModuleName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxModuleName$WithEOF");
    try {
      sink = N_HxModuleName(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxModuleName$WithEOF");
    }
  }

/**
 * <em>HxModuleName</em> ::=  (  <a href="#N_HxString">&lang;HxString&rang;</a> <font color="red">:checkModuleString</font>  |   <a href="#T_HX_DOTTEDNAME">HX_DOTTEDNAME</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxModuleName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxModuleName");
    try {Token t = null;
        net.sf.crsx.Sink bs_HxString = null;
        String c0 = null;
        net.sf.crsx.util.Buffer b_HxString = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxModuleName:{
        t = jj_consume_token(MT_HxModuleName);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_57:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[218] = jj_gen;
              break label_57;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[219] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxModuleName:{
        jj_consume_token(IT_HxModuleName);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxString:
      case IT_HxString:
      case T_HX_DOTTEDNAME:
      case T_HX_STRING:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxString:
        case IT_HxString:
        case T_HX_STRING:{
bs_HxString = b_HxString.sink();
          N_HxString(bs_HxString, env);
if (b_HxString.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxString.term(false).arity() != 0)
                         {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxString.term(false)+")");}
                        c0 = b_HxString.term(true).constructor().symbol();
                        sink = sink .start(makeTConstructor(sink, t, checkModuleString(c0), null)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_DOTTEDNAME:{
          t = jj_consume_token(T_HX_DOTTEDNAME);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[220] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[221] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxModuleName");
    }
  }

/** <em>HxVariable$WithEOF</em> ::= <em>HxVariable</em> EOF . */
  final public net.sf.crsx.Sink N_HxVariable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxVariable$WithEOF");
    try {
      sink = N_HxVariable(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxVariable$WithEOF");
    }
  }

/**
 * <em>HxVariable</em> ::=   <a href="#T_HX_VAR">HX_VAR</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxVariable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxVariable");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxVariable:{
        t = jj_consume_token(MT_HxVariable);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_58:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[222] = jj_gen;
              break label_58;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[223] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxVariable:{
        jj_consume_token(IT_HxVariable);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_VAR:{
        t = jj_consume_token(T_HX_VAR);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[224] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxVariable");
    }
  }

/** <em>HxMetaVariable$WithEOF</em> ::= <em>HxMetaVariable</em> EOF . */
  final public net.sf.crsx.Sink N_HxMetaVariable$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxMetaVariable$WithEOF");
    try {
      sink = N_HxMetaVariable(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxMetaVariable$WithEOF");
    }
  }

/**
 * <em>HxMetaVariable</em> ::=   <a href="#T_HX_META">HX_META</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxMetaVariable(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxMetaVariable");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxMetaVariable:{
        t = jj_consume_token(MT_HxMetaVariable);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_59:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[225] = jj_gen;
              break label_59;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[226] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxMetaVariable:{
        jj_consume_token(IT_HxMetaVariable);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_META:{
        t = jj_consume_token(T_HX_META);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[227] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxMetaVariable");
    }
  }

/** <em>HxAttributeName$WithEOF</em> ::= <em>HxAttributeName</em> EOF . */
  final public net.sf.crsx.Sink N_HxAttributeName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributeName$WithEOF");
    try {
      sink = N_HxAttributeName(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributeName$WithEOF");
    }
  }

/**
 * <em>HxAttributeName</em> ::=   <a href="#T_HX_VAR">HX_VAR</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxAttributeName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxAttributeName");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxAttributeName:{
        t = jj_consume_token(MT_HxAttributeName);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_60:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[228] = jj_gen;
              break label_60;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[229] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxAttributeName:{
        jj_consume_token(IT_HxAttributeName);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_VAR:{
        t = jj_consume_token(T_HX_VAR);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[230] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxAttributeName");
    }
  }

/** <em>HxSeparator$WithEOF</em> ::= <em>HxSeparator</em> EOF . */
  final public net.sf.crsx.Sink N_HxSeparator$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSeparator$WithEOF");
    try {
      sink = N_HxSeparator(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSeparator$WithEOF");
    }
  }

/**
 * <em>HxSeparator</em> ::=  (   <a href="#T_HX_BAR">HX_BAR</a><font color="red">$</font>  |   <a href="#T_HX_SEMI">HX_SEMI</a><font color="red">$</font>  |   <a href="#T_HX_COMMA">HX_COMMA</a><font color="red">$</font>  |   <a href="#T_HX_COLON">HX_COLON</a><font color="red">$</font>  |   <a href="#T_HX_STAR">HX_STAR</a><font color="red">$</font>  |   <a href="#T_HX_DOT">HX_DOT</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxSeparator(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxSeparator");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxSeparator:{
        t = jj_consume_token(MT_HxSeparator);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_61:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[231] = jj_gen;
              break label_61;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[232] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxSeparator:{
        jj_consume_token(IT_HxSeparator);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_SEMI:
      case T_HX_BAR:
      case T_HX_STAR:
      case T_HX_DOT:
      case T_HX_COLON:
      case T_HX_COMMA:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_BAR:{
          t = jj_consume_token(T_HX_BAR);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_SEMI:{
          t = jj_consume_token(T_HX_SEMI);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_COMMA:{
          t = jj_consume_token(T_HX_COMMA);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_COLON:{
          t = jj_consume_token(T_HX_COLON);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_STAR:{
          t = jj_consume_token(T_HX_STAR);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_DOT:{
          t = jj_consume_token(T_HX_DOT);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[233] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[234] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxSeparator");
    }
  }

/** <em>HxTokenName$WithEOF</em> ::= <em>HxTokenName</em> EOF . */
  final public net.sf.crsx.Sink N_HxTokenName$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTokenName$WithEOF");
    try {
token_source.SwitchTo(HX_RE);
      sink = N_HxTokenName(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTokenName$WithEOF");
    }
  }

/**
 * <em>HxTokenName</em> ::=   <a href="#T_HX_RE_NAME">HX_RE_NAME</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxTokenName(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxTokenName");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxTokenName:{
        t = jj_consume_token(MT_HxTokenName);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_62:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[235] = jj_gen;
              break label_62;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[236] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxTokenName:{
        jj_consume_token(IT_HxTokenName);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_RE_NAME:{
        t = jj_consume_token(T_HX_RE_NAME);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[237] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxTokenName");
    }
  }

/** <em>HxFragmentRef$WithEOF</em> ::= <em>HxFragmentRef</em> EOF . */
  final public net.sf.crsx.Sink N_HxFragmentRef$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxFragmentRef$WithEOF");
    try {
token_source.SwitchTo(HX_RE);
      sink = N_HxFragmentRef(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxFragmentRef$WithEOF");
    }
  }

/**
 * <em>HxFragmentRef</em> ::=   <a href="#T_HX_FRAGMENT_REF">HX_FRAGMENT_REF</a><font color="red">$:unwrap</font> 
 */
  final public net.sf.crsx.Sink N_HxFragmentRef(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxFragmentRef");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxFragmentRef:{
        t = jj_consume_token(MT_HxFragmentRef);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_63:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[238] = jj_gen;
              break label_63;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[239] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxFragmentRef:{
        jj_consume_token(IT_HxFragmentRef);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_FRAGMENT_REF:{
        t = jj_consume_token(T_HX_FRAGMENT_REF);
sink = sink .start(makeTConstructor(sink, t, unwrap(t.toString()), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[240] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxFragmentRef");
    }
  }

/** <em>HxRegExpWord$WithEOF</em> ::= <em>HxRegExpWord</em> EOF . */
  final public net.sf.crsx.Sink N_HxRegExpWord$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpWord$WithEOF");
    try {
token_source.SwitchTo(HX_RE);
      sink = N_HxRegExpWord(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpWord$WithEOF");
    }
  }

/**
 * <em>HxRegExpWord</em> ::=  (   <a href="#T_HX_RE_NAME">HX_RE_NAME</a><font color="red">$</font>  |   <a href="#T_HX_RE_WORD">HX_RE_WORD</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxRegExpWord(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpWord");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRegExpWord:{
        t = jj_consume_token(MT_HxRegExpWord);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_64:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[241] = jj_gen;
              break label_64;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[242] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRegExpWord:{
        jj_consume_token(IT_HxRegExpWord);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_RE_NAME:
      case T_HX_RE_WORD:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_RE_NAME:{
          t = jj_consume_token(T_HX_RE_NAME);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_RE_WORD:{
          t = jj_consume_token(T_HX_RE_WORD);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[243] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[244] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpWord");
    }
  }

/** <em>HxLiteral$WithEOF</em> ::= <em>HxLiteral</em> EOF . */
  final public net.sf.crsx.Sink N_HxLiteral$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxLiteral$WithEOF");
    try {
      sink = N_HxLiteral(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxLiteral$WithEOF");
    }
  }

/**
 * <em>HxLiteral</em> ::=  (  <a href="#N_HxString">&lang;HxString&rang;</a>   |  <a href="#N_HxNumber">&lang;HxNumber&rang;</a>   ) 
 */
  final public net.sf.crsx.Sink N_HxLiteral(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxLiteral");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxLiteral:{
        t = jj_consume_token(MT_HxLiteral);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_65:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[245] = jj_gen;
              break label_65;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[246] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxLiteral:{
        jj_consume_token(IT_HxLiteral);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxNumber:
      case IT_HxNumber:
      case MT_HxNatural:
      case IT_HxNatural:
      case MT_HxString:
      case IT_HxString:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:
      case T_HX_STRING:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxString:
        case IT_HxString:
        case T_HX_STRING:{
          sink = N_HxString(sink, env);
          break;
          }
        case MT_HxNumber:
        case IT_HxNumber:
        case MT_HxNatural:
        case IT_HxNatural:
        case T_HX_NATURAL:
        case T_HX_UNNATURAL:{
          sink = N_HxNumber(sink, env);
          break;
          }
        default:
          jj_la1[247] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[248] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxLiteral");
    }
  }

/**
 * <em>HxNumber</em> ::=  (  <a href="#N_HxNatural">&lang;HxNatural&rang;</a>   |   <a href="#T_HX_UNNATURAL">HX_UNNATURAL</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxNumber(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxNumber");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxNumber:{
        t = jj_consume_token(MT_HxNumber);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_66:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[249] = jj_gen;
              break label_66;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[250] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxNumber:{
        jj_consume_token(IT_HxNumber);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxNatural:
      case IT_HxNatural:
      case T_HX_NATURAL:
      case T_HX_UNNATURAL:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxNatural:
        case IT_HxNatural:
        case T_HX_NATURAL:{
          sink = N_HxNatural(sink, env);
          break;
          }
        case T_HX_UNNATURAL:{
          t = jj_consume_token(T_HX_UNNATURAL);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[251] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[252] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxNumber");
    }
  }

/**
 * <em>HxNatural</em> ::=   <a href="#T_HX_NATURAL">HX_NATURAL</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxNatural(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxNatural");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxNatural:{
        t = jj_consume_token(MT_HxNatural);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_67:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[253] = jj_gen;
              break label_67;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[254] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxNatural:{
        jj_consume_token(IT_HxNatural);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_NATURAL:{
        t = jj_consume_token(T_HX_NATURAL);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[255] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxNatural");
    }
  }

/**
 * <em>HxString</em> ::=   <a href="#T_HX_STRING">HX_STRING</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxString(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxString");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxString:{
        t = jj_consume_token(MT_HxString);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_68:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[256] = jj_gen;
              break label_68;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[257] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxString:{
        jj_consume_token(IT_HxString);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_STRING:{
        t = jj_consume_token(T_HX_STRING);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[258] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxString");
    }
  }

/** <em>HxRegExpClass$WithEOF</em> ::= <em>HxRegExpClass</em> EOF . */
  final public net.sf.crsx.Sink N_HxRegExpClass$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpClass$WithEOF");
    try {
token_source.SwitchTo(HX_RE);
      sink = N_HxRegExpClass(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpClass$WithEOF");
    }
  }

/**
 * <em>HxRegExpClass</em> ::=   <a href="#T_HX_CHAR_CLASS">HX_CHAR_CLASS</a><font color="red">$$:unwrap:{rawHxCC}</font> 
 */
  final public net.sf.crsx.Sink N_HxRegExpClass(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxRegExpClass");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxRegExpClass:{
        t = jj_consume_token(MT_HxRegExpClass);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_69:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[259] = jj_gen;
              break label_69;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[260] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxRegExpClass:{
        jj_consume_token(IT_HxRegExpClass);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CHAR_CLASS:{
        t = jj_consume_token(T_HX_CHAR_CLASS);
try {sink = factory.parser(factory).parse(sink, "rawHxCC", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[261] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxRegExpClass");
    }
  }

/** <em>HxCC$WithEOF</em> ::= <em>HxCC</em> EOF . */
  final public net.sf.crsx.Sink N_HxCC$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC$WithEOF");
    try {
token_source.SwitchTo(HX_CC);
      sink = N_HxCC(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC$WithEOF");
    }
  }

/**
 * <em>HxCC</em> ::=  <a href="#N_HxCC_RangesTop">&lang;HxCC_RangesTop&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxCC(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxCC:{
        t = jj_consume_token(MT_HxCC);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_70:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[262] = jj_gen;
              break label_70;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[263] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxCC:{
        jj_consume_token(IT_HxCC);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxCC_RangesTop:
      case IT_HxCC_RangesTop:
      case MT_HxCC_FirstRangeStartChar:
      case IT_HxCC_FirstRangeStartChar:
      case T_HX_CC_NOT:
      case T_HX_CC_RBRACKET:
      case T_HX_CC_DASH:
      case T_HX_CC_OTHER:
      case T_HX_CC_SKIP:{
        sink = N_HxCC_RangesTop(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[264] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC");
    }
  }

/** <em>HxCC_RangesTop$WithEOF</em> ::= <em>HxCC_RangesTop</em> EOF . */
  final public net.sf.crsx.Sink N_HxCC_RangesTop$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_RangesTop$WithEOF");
    try {
token_source.SwitchTo(HX_CC);
      sink = N_HxCC_RangesTop(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_RangesTop$WithEOF");
    }
  }

/**
 * <em>HxCC_RangesTop</em> ::=  <font color="red">{RegExpClassNot}</font><font color="red">:hx</font>    <a href="#T_HX_CC_NOT">HX_CC_NOT</a>   <a href="#N_HxCC_FirstRangeStartChar">&lang;HxCC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo&rang;</a>   <br>
 *  |  <a href="#N_HxCC_FirstRangeStartChar">&lang;HxCC_FirstRangeStartChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo&rang;</a>   <br>
 *  |   <a href="#T_HX_CC_SKIP">HX_CC_SKIP</a>   <a href="#N_HxCC_RangesTop">&lang;HxCC_RangesTop&rang;</a>  
 */
  final public net.sf.crsx.Sink N_HxCC_RangesTop(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_RangesTop");
    try {Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.Sink bs__lo = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxCC_RangesTop:{
        t = jj_consume_token(MT_HxCC_RangesTop);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_71:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[265] = jj_gen;
              break label_71;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[266] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxCC_RangesTop:{
        jj_consume_token(IT_HxCC_RangesTop);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CC_NOT:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassNot"), null)) ;
        jj_consume_token(T_HX_CC_NOT);
bs__lo = b__lo.sink();
        N_HxCC_FirstRangeStartChar(bs__lo, env);
s1 = b1.sink();
                s1 .copy(b__lo, true) ;
        sink = N_HxCC_RangeTail(sink, env, b1);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxCC_FirstRangeStartChar:
      case IT_HxCC_FirstRangeStartChar:
      case T_HX_CC_RBRACKET:
      case T_HX_CC_DASH:
      case T_HX_CC_OTHER:{
bs__lo = b__lo.sink();
        N_HxCC_FirstRangeStartChar(bs__lo, env);
s1 = b1.sink();
                s1 .copy(b__lo, true) ;
        sink = N_HxCC_RangeTail(sink, env, b1);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CC_SKIP:{
        jj_consume_token(T_HX_CC_SKIP);
        sink = N_HxCC_RangesTop(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[267] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_RangesTop");
    }
  }

/** <em>HxCC_Ranges$WithEOF</em> ::= <em>HxCC_Ranges</em> EOF . */
  final public net.sf.crsx.Sink N_HxCC_Ranges$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_Ranges$WithEOF");
    try {
token_source.SwitchTo(HX_CC);
      sink = N_HxCC_Ranges(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_Ranges$WithEOF");
    }
  }

/**
 * <em>HxCC_Ranges</em> ::=  <a href="#N_HxCC_RangeChar">&lang;HxCC_RangeChar&rang;</a> <font color="red">:#lo</font>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo&rang;</a>   <br>
 *  |   <a href="#T_HX_CC_SKIP">HX_CC_SKIP</a>   <a href="#N_HxCC_Ranges">&lang;HxCC_Ranges&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassDone}</font><font color="red">:hx</font> 
 */
  final public net.sf.crsx.Sink N_HxCC_Ranges(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_Ranges");
    try {Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.Sink bs__lo = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.util.Buffer b__lo = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxCC_Ranges:{
        t = jj_consume_token(MT_HxCC_Ranges);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_72:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[268] = jj_gen;
              break label_72;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[269] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxCC_Ranges:{
        jj_consume_token(IT_HxCC_Ranges);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxCC_RangeChar:
      case IT_HxCC_RangeChar:
      case T_HX_CC_NOT:
      case T_HX_CC_DASH:
      case T_HX_CC_OTHER:{
bs__lo = b__lo.sink();
        N_HxCC_RangeChar(bs__lo, env);
s1 = b1.sink();
                s1 .copy(b__lo, true) ;
        sink = N_HxCC_RangeTail(sink, env, b1);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CC_SKIP:{
        jj_consume_token(T_HX_CC_SKIP);
        sink = N_HxCC_Ranges(sink, env);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[270] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_Ranges");
    }
  }

/**
 * <em>HxCC_RangeTail</em> ::=   <a href="#T_HX_CC_DASH">HX_CC_DASH</a>   (  <font color="red">{RegExpClassRange}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <a href="#N_HxCC_RangeChar">&lang;HxCC_RangeChar&rang;</a>    <a href="#N_HxCC_Ranges">&lang;HxCC_Ranges&rang;</a>   |  <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:hx</font>  )  <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <a href="#N_HxCC_NonDashRangeStartChar">&lang;HxCC_NonDashRangeStartChar&rang;</a> <font color="red">:#lo2</font>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo2&rang;</a>   <br>
 *  |   <a href="#T_HX_CC_SKIP">HX_CC_SKIP</a>   <a href="#N_HxCC_RangeTail">&lang;HxCC_RangeTail #lo&rang;</a>   <br>
 *  |  <font color="red">{RegExpClassChar}</font><font color="red">:hx</font>   <font color="red">{{#lo}}</font>   <font color="red">{RegExpClassDone}</font><font color="red">:hx</font> 
 */
  final public net.sf.crsx.Sink N_HxCC_RangeTail(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env, net.sf.crsx.util.Buffer b__lo) throws ParseException {
    trace_call("N_HxCC_RangeTail");
    try {Token t = null;
        net.sf.crsx.Sink s1 = null;
        net.sf.crsx.util.Buffer b1 = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Sink bs__lo2 = null;
        net.sf.crsx.util.Buffer b__lo2 = new net.sf.crsx.util.Buffer(sink);
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxCC_RangeTail:{
        t = jj_consume_token(MT_HxCC_RangeTail);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_73:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[271] = jj_gen;
              break label_73;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[272] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxCC_RangeTail:{
        jj_consume_token(IT_HxCC_RangeTail);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CC_DASH:{
        jj_consume_token(T_HX_CC_DASH);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case MT_HxCC_RangeChar:
        case IT_HxCC_RangeChar:
        case T_HX_CC_NOT:
        case T_HX_CC_DASH:
        case T_HX_CC_OTHER:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassRange"), null)) ;
sink = sink .copy(b__lo, false) ;
          sink = N_HxCC_RangeChar(sink, env);
          sink = N_HxCC_Ranges(sink, env);
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[273] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
sink = sink .copy(b__lo, false) ;
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
sink = sink .end().end() ;
        }
{if ("" != null) return sink;}
        break;
        }
      case MT_HxCC_NonDashRangeStartChar:
      case IT_HxCC_NonDashRangeStartChar:
      case T_HX_CC_NOT:
      case T_HX_CC_OTHER:{
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
sink = sink .copy(b__lo, false) ;
bs__lo2 = b__lo2.sink();
        N_HxCC_NonDashRangeStartChar(bs__lo2, env);
s1 = b1.sink();
                s1 .copy(b__lo2, true) ;
        sink = N_HxCC_RangeTail(sink, env, b1);
{if ("" != null) return sink .end() ;}
        break;
        }
      case T_HX_CC_SKIP:{
        jj_consume_token(T_HX_CC_SKIP);
s1 = b1.sink();
                s1 .copy(b__lo, false) ;
        sink = N_HxCC_RangeTail(sink, env, b1);
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[274] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassChar"), null)) ;
sink = sink .copy(b__lo, false) ;
sink = sink .start(makeTConstructor(sink, t, hx("RegExpClassDone"), null)) ;
{if ("" != null) return sink .end().end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_RangeTail");
    }
  }

/** <em>HxCC_FirstRangeStartChar$WithEOF</em> ::= <em>HxCC_FirstRangeStartChar</em> EOF . */
  final public net.sf.crsx.Sink N_HxCC_FirstRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_FirstRangeStartChar$WithEOF");
    try {
token_source.SwitchTo(HX_CC);
      sink = N_HxCC_FirstRangeStartChar(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_FirstRangeStartChar$WithEOF");
    }
  }

/**
 * <em>HxCC_FirstRangeStartChar</em> ::=  (   <a href="#T_HX_CC_RBRACKET">HX_CC_RBRACKET</a><font color="red">$</font>  |   <a href="#T_HX_CC_DASH">HX_CC_DASH</a><font color="red">$</font>  |   <a href="#T_HX_CC_OTHER">HX_CC_OTHER</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxCC_FirstRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_FirstRangeStartChar");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxCC_FirstRangeStartChar:{
        t = jj_consume_token(MT_HxCC_FirstRangeStartChar);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_74:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[275] = jj_gen;
              break label_74;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[276] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxCC_FirstRangeStartChar:{
        jj_consume_token(IT_HxCC_FirstRangeStartChar);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CC_RBRACKET:
      case T_HX_CC_DASH:
      case T_HX_CC_OTHER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_CC_RBRACKET:{
          t = jj_consume_token(T_HX_CC_RBRACKET);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_CC_DASH:{
          t = jj_consume_token(T_HX_CC_DASH);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_CC_OTHER:{
          t = jj_consume_token(T_HX_CC_OTHER);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[277] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[278] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_FirstRangeStartChar");
    }
  }

/** <em>HxCC_NonDashRangeStartChar$WithEOF</em> ::= <em>HxCC_NonDashRangeStartChar</em> EOF . */
  final public net.sf.crsx.Sink N_HxCC_NonDashRangeStartChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_NonDashRangeStartChar$WithEOF");
    try {
token_source.SwitchTo(HX_CC);
      sink = N_HxCC_NonDashRangeStartChar(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_NonDashRangeStartChar$WithEOF");
    }
  }

/**
 * <em>HxCC_NonDashRangeStartChar</em> ::=  (   <a href="#T_HX_CC_NOT">HX_CC_NOT</a><font color="red">$</font>  |   <a href="#T_HX_CC_OTHER">HX_CC_OTHER</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxCC_NonDashRangeStartChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_NonDashRangeStartChar");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxCC_NonDashRangeStartChar:{
        t = jj_consume_token(MT_HxCC_NonDashRangeStartChar);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_75:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[279] = jj_gen;
              break label_75;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[280] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxCC_NonDashRangeStartChar:{
        jj_consume_token(IT_HxCC_NonDashRangeStartChar);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CC_NOT:
      case T_HX_CC_OTHER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_CC_NOT:{
          t = jj_consume_token(T_HX_CC_NOT);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_CC_OTHER:{
          t = jj_consume_token(T_HX_CC_OTHER);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[281] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[282] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_NonDashRangeStartChar");
    }
  }

/** <em>HxCC_RangeChar$WithEOF</em> ::= <em>HxCC_RangeChar</em> EOF . */
  final public net.sf.crsx.Sink N_HxCC_RangeChar$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_RangeChar$WithEOF");
    try {
token_source.SwitchTo(HX_CC);
      sink = N_HxCC_RangeChar(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_RangeChar$WithEOF");
    }
  }

/**
 * <em>HxCC_RangeChar</em> ::=  (   <a href="#T_HX_CC_NOT">HX_CC_NOT</a><font color="red">$</font>  |   <a href="#T_HX_CC_DASH">HX_CC_DASH</a><font color="red">$</font>  |   <a href="#T_HX_CC_OTHER">HX_CC_OTHER</a><font color="red">$</font>  ) 
 */
  final public net.sf.crsx.Sink N_HxCC_RangeChar(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxCC_RangeChar");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxCC_RangeChar:{
        t = jj_consume_token(MT_HxCC_RangeChar);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_76:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[283] = jj_gen;
              break label_76;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[284] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxCC_RangeChar:{
        jj_consume_token(IT_HxCC_RangeChar);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CC_NOT:
      case T_HX_CC_DASH:
      case T_HX_CC_OTHER:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_CC_NOT:{
          t = jj_consume_token(T_HX_CC_NOT);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_CC_DASH:{
          t = jj_consume_token(T_HX_CC_DASH);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        case T_HX_CC_OTHER:{
          t = jj_consume_token(T_HX_CC_OTHER);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[285] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[286] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxCC_RangeChar");
    }
  }

/** <em>HxParsedForm$WithEOF</em> ::= <em>HxParsedForm</em> EOF . */
  final public net.sf.crsx.Sink N_HxParsedForm$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxParsedForm$WithEOF");
    try {
      sink = N_HxParsedForm(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxParsedForm$WithEOF");
    }
  }

/**
 * <em>HxParsedForm</em> ::=   <a href="#T_HX_CONCRETE">HX_CONCRETE</a><font color="red">$$:unwrap:{rawHxPP}</font> 
 */
  final public net.sf.crsx.Sink N_HxParsedForm(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxParsedForm");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxParsedForm:{
        t = jj_consume_token(MT_HxParsedForm);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_77:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[287] = jj_gen;
              break label_77;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[288] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxParsedForm:{
        jj_consume_token(IT_HxParsedForm);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_CONCRETE:{
        t = jj_consume_token(T_HX_CONCRETE);
try {sink = factory.parser(factory).parse(sink, "rawHxPP", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[289] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxParsedForm");
    }
  }

/** <em>HxPP$WithEOF</em> ::= <em>HxPP</em> EOF . */
  final public net.sf.crsx.Sink N_HxPP$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxPP$WithEOF");
    try {
token_source.SwitchTo(HX_PP);
      sink = N_HxPP(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxPP$WithEOF");
    }
  }

/**
 * <em>HxPP</em> ::=  <font color="red">{ParsedFormSpace}</font><font color="red">:hx</font>   <a href="#N_HxPPConcreteSpace">&lang;HxPPConcreteSpace&rang;</a>    <a href="#N_HxPP">&lang;HxPP&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormWord}</font><font color="red">:hx</font>   <a href="#N_HxPPConcreteWord">&lang;HxPPConcreteWord&rang;</a>    <a href="#N_HxPP">&lang;HxPP&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormTerm}</font><font color="red">:hx</font>   <a href="#N_HxPPUnconcrete">&lang;HxPPUnconcrete&rang;</a>    <a href="#N_HxPP">&lang;HxPP&rang;</a>   <br>
 *  |  <font color="red">{ParsedFormDone}</font><font color="red">:hx</font> 
 */
  final public net.sf.crsx.Sink N_HxPP(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxPP");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxPP:{
        t = jj_consume_token(MT_HxPP);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_78:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[290] = jj_gen;
              break label_78;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[291] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxPP:{
        jj_consume_token(IT_HxPP);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxPPConcreteSpace:
      case IT_HxPPConcreteSpace:
      case T_HX_PP_CONCRETE_SPACE:{
sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormSpace"), null)) ;
        sink = N_HxPPConcreteSpace(sink, env);
        sink = N_HxPP(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxPPConcreteWord:
      case IT_HxPPConcreteWord:
      case T_HX_PP_CONCRETE_WORD:{
sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormWord"), null)) ;
        sink = N_HxPPConcreteWord(sink, env);
        sink = N_HxPP(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      case MT_HxPPUnconcrete:
      case IT_HxPPUnconcrete:
      case T_HX_PP_UNCONCRETE:{
sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormTerm"), null)) ;
        sink = N_HxPPUnconcrete(sink, env);
        sink = N_HxPP(sink, env);
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[292] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("ParsedFormDone"), null)) ;
{if ("" != null) return sink .end() ;}
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxPP");
    }
  }

/** <em>HxPPConcreteSpace$WithEOF</em> ::= <em>HxPPConcreteSpace</em> EOF . */
  final public net.sf.crsx.Sink N_HxPPConcreteSpace$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxPPConcreteSpace$WithEOF");
    try {
token_source.SwitchTo(HX_PP);
      sink = N_HxPPConcreteSpace(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxPPConcreteSpace$WithEOF");
    }
  }

/**
 * <em>HxPPConcreteSpace</em> ::=   <a href="#T_HX_PP_CONCRETE_SPACE">HX_PP_CONCRETE_SPACE</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxPPConcreteSpace(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxPPConcreteSpace");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxPPConcreteSpace:{
        t = jj_consume_token(MT_HxPPConcreteSpace);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_79:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[293] = jj_gen;
              break label_79;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[294] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxPPConcreteSpace:{
        jj_consume_token(IT_HxPPConcreteSpace);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_PP_CONCRETE_SPACE:{
        t = jj_consume_token(T_HX_PP_CONCRETE_SPACE);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[295] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxPPConcreteSpace");
    }
  }

/** <em>HxPPConcreteWord$WithEOF</em> ::= <em>HxPPConcreteWord</em> EOF . */
  final public net.sf.crsx.Sink N_HxPPConcreteWord$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxPPConcreteWord$WithEOF");
    try {
token_source.SwitchTo(HX_PP);
      sink = N_HxPPConcreteWord(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxPPConcreteWord$WithEOF");
    }
  }

/**
 * <em>HxPPConcreteWord</em> ::=   <a href="#T_HX_PP_CONCRETE_WORD">HX_PP_CONCRETE_WORD</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_HxPPConcreteWord(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxPPConcreteWord");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxPPConcreteWord:{
        t = jj_consume_token(MT_HxPPConcreteWord);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_80:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[296] = jj_gen;
              break label_80;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[297] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxPPConcreteWord:{
        jj_consume_token(IT_HxPPConcreteWord);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_PP_CONCRETE_WORD:{
        t = jj_consume_token(T_HX_PP_CONCRETE_WORD);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[298] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxPPConcreteWord");
    }
  }

/** <em>HxPPUnconcrete$WithEOF</em> ::= <em>HxPPUnconcrete</em> EOF . */
  final public net.sf.crsx.Sink N_HxPPUnconcrete$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxPPUnconcrete$WithEOF");
    try {
token_source.SwitchTo(HX_PP);
      sink = N_HxPPUnconcrete(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxPPUnconcrete$WithEOF");
    }
  }

/**
 * <em>HxPPUnconcrete</em> ::=   <a href="#T_HX_PP_UNCONCRETE">HX_PP_UNCONCRETE</a><font color="red">$$:unwrap:{rawHxScopeSortPrec}</font> 
 */
  final public net.sf.crsx.Sink N_HxPPUnconcrete(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxPPUnconcrete");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxPPUnconcrete:{
        t = jj_consume_token(MT_HxPPUnconcrete);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_81:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[299] = jj_gen;
              break label_81;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[300] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxPPUnconcrete:{
        jj_consume_token(IT_HxPPUnconcrete);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case T_HX_PP_UNCONCRETE:{
        t = jj_consume_token(T_HX_PP_UNCONCRETE);
try {sink = factory.parser(factory).parse(sink, "rawHxScopeSortPrec", new java.io.StringReader(unwrap(t.toString())), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[301] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxPPUnconcrete");
    }
  }

/** <em>HxScopeSortPrec$WithEOF</em> ::= <em>HxScopeSortPrec</em> EOF . */
  final public net.sf.crsx.Sink N_HxScopeSortPrec$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxScopeSortPrec$WithEOF");
    try {
      sink = N_HxScopeSortPrec(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxScopeSortPrec$WithEOF");
    }
  }

/**
 * <em>HxScopeSortPrec</em> ::=  <a href="#N_HxScopeSort">&lang;HxScopeSort&rang;</a> <font color="red">:#S</font>   (  <font color="red">{ScopeSortPrecBind}</font><font color="red">:hx</font>    <a href="#T_HX_BINDS">HX_BINDS</a>   <font color="red">{{#S}}</font>   <a href="#N_HxVariable">&lang;HxVariable&rang;</a> <font color="red">!!!</font>  |  <font color="red">{ScopeSortPrec}</font><font color="red">:hx</font>   <font color="red">{{#S}}</font>   <a href="#N_HxFormPrec">&lang;HxFormPrec&rang;</a>   ) 
 */
  final public net.sf.crsx.Sink N_HxScopeSortPrec(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_HxScopeSortPrec");
    try {net.sf.crsx.util.Buffer b__S = new net.sf.crsx.util.Buffer(sink);
        net.sf.crsx.Variable v_HxVariable = null;
        Token t = null;
        net.sf.crsx.Sink bs_HxVariable = null;
        String c2 = null;
        net.sf.crsx.util.Buffer b_HxVariable = new net.sf.crsx.util.Buffer(sink);
        String s_HxVariable = null;
        net.sf.crsx.Sink bs__S = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case MT_HxScopeSortPrec:{
        t = jj_consume_token(MT_HxScopeSortPrec);
sink = sink .startMetaApplication(t.toString());
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 3:{
          jj_consume_token(3);
          sink = N_HxSortParam(sink, env);
          label_82:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 4:{
              ;
              break;
              }
            default:
              jj_la1[302] = jj_gen;
              break label_82;
            }
            jj_consume_token(4);
            sink = N_HxSortParam(sink, env);
          }
          jj_consume_token(5);
          break;
          }
        default:
          jj_la1[303] = jj_gen;
          ;
        }
{if ("" != null) return sink.endMetaApplication();}
        break;
        }
      case IT_HxScopeSortPrec:{
        jj_consume_token(IT_HxScopeSortPrec);
        sink = N_HxEmbedded(sink, env);
{if ("" != null) return sink;}
        break;
        }
      case MT_HxScopeSort:
      case IT_HxScopeSort:
      case MT_HxSort:
      case IT_HxSort:
      case MT_HxSimpleSort:
      case IT_HxSimpleSort:
      case MT_HxSortParam:
      case IT_HxSortParam:
      case MT_HxSortName:
      case IT_HxSortName:
      case MT_HxVariable:
      case IT_HxVariable:
      case T_HX_VAR:
      case T_HX_CONSTRUCTOR:{
bs__S = b__S.sink();
        N_HxScopeSort(bs__S, env);
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case T_HX_BINDS:{
sink = sink .start(makeTConstructor(sink, t, hx("ScopeSortPrecBind"), null)) ;
          jj_consume_token(T_HX_BINDS);
sink = sink .copy(b__S, true) ;
bs_HxVariable = b_HxVariable.sink();
          N_HxVariable(bs_HxVariable, env);
if (b_HxVariable.term(false).kind() != net.sf.crsx.Kind.CONSTRUCTION || b_HxVariable.term(false).arity() != 0)
                         {if (true) throw new ParseException("Subterm can only be used as constant if it contains a single constructor ("+b_HxVariable.term(false)+")");}
                        c2 = b_HxVariable.term(true).constructor().symbol();
                        s_HxVariable = c2;
                        v_HxVariable = (env.containsKey(s_HxVariable) ? env.get(s_HxVariable) : factory.freeVariable(s_HxVariable, true, true));
                        if (v_HxVariable == null) {if (true) throw new ParseException("Variable "+s_HxVariable+" cannot be resolved?");}
                        sink = sink .use(v_HxVariable) ;
sink = sink .end() ;
          break;
          }
        default:
          jj_la1[304] = jj_gen;
sink = sink .start(makeTConstructor(sink, t, hx("ScopeSortPrec"), null)) ;
sink = sink .copy(b__S, true) ;
          sink = N_HxFormPrec(sink, env);
sink = sink .end() ;
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[305] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_HxScopeSortPrec");
    }
  }

  /** Generated Token Manager. */
  public HxRawTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[306];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static private int[] jj_la1_5;
  static private int[] jj_la1_6;
  static private int[] jj_la1_7;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
      jj_la1_init_4();
      jj_la1_init_5();
      jj_la1_init_6();
      jj_la1_init_7();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x10,0x8,0xc6,0x10,0x8,0xc0,0x10,0x8,0x3cc0,0x300,0x10,0x8,0x0,0x0,0x3cc0,0x10,0x8,0x0,0x3000,0x10,0x8,0x0,0xc000,0x10,0x8,0x0,0x30000,0x10,0x8,0xc0000,0x10,0x8,0xcf00000,0x10,0x8,0xcc00000,0x10,0x8,0x0,0x3000000,0x10,0x8,0xc000000,0x10,0x8,0x30000000,0x10,0x8,0x0,0xc0000000,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0xc000,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0xc000,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x10,0x8,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0xc,0x0,0x0,0xf0,0x0,0x0,0x0,0x0,0x300,0xc0,0x0,0x0,0xc30c3c00,0x0,0x300,0x0,0x0,0x0,0xc30c3c00,0x0,0x0,0xc30c3000,0x0,0x0,0xc300c000,0x0,0x0,0x30000,0x0,0x0,0x0,0xc30c0000,0x0,0x0,0x0,0xf00000,0x0,0x0,0x0,0xc00000,0x0,0x0,0xc3000000,0x0,0x0,0xc0000000,0xc000000,0x0,0x0,0x30000000,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc30c0000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xcc30fc00,0x0,0x0,0x0,0x0,0x0,0xcc30fc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000000,0x0,0x0,0x0,0x300000c,0x0,0xc000000,0x0,0x0,0x0,0x300000c,0x0,0x0,0x300000c,0x0,0x0,0x300000c,0x0,0x0,0x0,0x0,0x0,0x0,0x300000c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300000c,0x0,0x0,0x300000c,0x0,0x0,0x0,0x0,0x0,0x0,0x300000c,0x0,0x0,0x3,0x0,0x0,0xc,0x0,0x0,0x0,0x30,0x0,0x0,0x300,0xc0,0x0,0x0,0x300,0x0,0x0,0x0,0xcc30fc00,0x0,0x0,0xcc330000,0x0,0x3000,0x0,0x0,0x0,0xc000,0x0,0x0,0x0,0xcc330000,0x0,0x0,0x3c0c0000,0x0,0x0,0xcc300000,0x0,0x0,0x0,0xc00000,0x0,0x0,0x3000000,0x0,0x0,0xc000000,0x0,0x0,0x0,0x3c000000,0x0,0x3c000000,0x0,0x3c000000,0x0,0xc000000,0x3c000000,0x0,0x3c000000,0x0,0x0,0x3c000000,0x0,0x3c000000,0x0,0xc000000,0xcc000000,0x0,0x0,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300000c,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1030000,0x0,0x0,0x0,0x0,0x0,0x1030000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1030000,0x0,0x0,0x1030000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1030000,0x0,0x0,0x1030000,0x0,0x0,0x1030000,0x0,0x0,0xc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10c0000,0x1030300,0x0,0x103000f,0x0,0x103000f,0x0,0x1030000,0x1030300,0x0,0x1030000,0x0,0x0,0x103000f,0x0,0x103000f,0x0,0x1030000,0x1030000,0x0,0x0,0x0,0x103000f,0x0,0x0,0xc0,0x0,0x103000c,0x0,0x0,0x30,0x0,0x0,0x0,0xc0,0x0,0x0,0x0,0x1030300,0x0,0x0,0x3000,0xc00,0x0,0x0,0x3000,0x0,0x0,0x0,0x1030000,0xc000,0x0,0x0,0x1030000,0x0,0x0,0x10c0000,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc000,0x0,0x0,0x0,0x300,0x0,0x3fc000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf03c00,0x0,0x0,0xf03c00,0x0,0x0,0x0,0x0,0x0,0x0,0xf03c00,0x0,0x0,0x3000c0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0xc,0x0,0x0,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc000,0x0,0x0,0x3fc000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc000,0x0,0x0,0x3fc00f,0x0,0x0,0x3fc000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc00f,0x0,0x3fc00f,0x0,0x3fc00f,0x0,0x3fc00f,0x3fc00f,0x0,0x3fc00f,0x0,0x0,0x3fc00f,0x0,0x3fc00f,0x0,0x3fc000,0x3fc000,0x0,0x0,0x0,0x3fc00f,0x0,0x0,0x3,0x0,0x3fc00f,0x0,0x0,0x3,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0x3fc00f,0x0,0x0,0x3c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3fc00f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300000,0x300000,0x0,0x0,0x3,0x0,0x0,0xc,0x0,0x0,0x30,0x0,0x0,0x0,0xc0,0x0,0x0,0x300,0x0,0x0,0xc00,0x0,0x0,0x0,0x3000,0x0,0x0,0x3f0000,0x3fc000,0x0,0x0,0xc0000,0xf0000,0x0,0x0,0xc0000,0x0,0x0,0x300000,0x0,0x0,0xc00000,0x0,0x0,0xf000000,0x0,0x0,0xc000000,0x0,0x0,0x30000000,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,};
   }
   private static void jj_la1_init_5() {
      jj_la1_5 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc000000,0x0,0x0,0x0,0x0,0x0,0xc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x10000000,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x10000000,0x0,0x0,0x4c000000,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x0,0xc0,0x8000000,0x0,0x0,0x0,0x10000000,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4c000000,0x4c000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3,0x0,0x0,0x3,0x0,0x0,0x30,0x0,0x0,0x30,0xc,0x0,0x0,0x0,0x3,0x0,0x0,0x0,0xc,0x0,0x0,0x0,0x30,0x0,0x0,0xc0,0x0,0x0,0x40ff00,0x0,0x0,0xc00,0x0,0x0,0x3000,0x0,0x0,0x40c000,0x0,0x0,0x0,0x30000,};
   }
   private static void jj_la1_init_6() {
      jj_la1_6 = new int[] {0x0,0x0,0x10000,0x0,0x0,0x10000,0x0,0x0,0x79070050,0x0,0x0,0x0,0x0,0x8000000,0x79070050,0x0,0x0,0x40000,0x0,0x0,0x0,0x1800,0x1800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x4,0x0,0x0,0x2,0x1,0x0,0x0,0x4,0x0,0x0,0x10c,0x0,0x0,0x28,0x10,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x80000,0x4d80800,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x100,0x40,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x180,0x0,0x0,0x40,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x1000,0x0,0x0,0x400,0x30000040,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x30000000,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40,0x40,0x0,0x40,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x40,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x100,0x40,0x0,0x0,0x0,0x40,0x40,0x0,0x0,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x4,0x1800,0x0,0x0,0x4,0x0,0x0,0x8,0x2008,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10c,0x10c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_7() {
      jj_la1_7 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800681c,0x0,0x0,0x0,0x90,0x0,0x800681c,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0xa41c0,0x0,0x0,0xa41c0,0x0,0x0,0x0,0x0,0x0,0x0,0xa41c0,0x0,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0x8000400,0x0,0x8000000,0x0,0x0,0x0,0x8000400,0x0,0x0,0x8000400,0x0,0x0,0x8000400,0x0,0x0,0x0,0x0,0x0,0x0,0x8000400,0x0,0x0,0x0,0x400,0x0,0x0,0x2,0x400,0x0,0x0,0x8000400,0x0,0x0,0x8000400,0x0,0x0,0x0,0x0,0x0,0x0,0x8000400,0x0,0x0,0x200,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8006800,0x0,0x0,0x8006800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8006800,0x0,0x0,0x8006e00,0x0,0x0,0x8006800,0x0,0x0,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x8000000,0x0,0x0,0x0,0x8006e00,0x0,0x8006e00,0x0,0x8006e00,0x0,0x8006e00,0x8006e00,0x0,0x8006e00,0x0,0x0,0x8006e00,0x0,0x8006e00,0x0,0x8006800,0x8006800,0x0,0x0,0x0,0x8006e00,0x0,0x0,0x400,0x0,0x8006e00,0x0,0x0,0x400,0x0,0x0,0x0,0x400,0x0,0x0,0x0,0x8006e00,0x0,0x0,0x600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8006e00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x4000,0x0,0x0,0x400,0x0,0x0,0x200,0x0,0x0,0x400,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x40,0x0,0x0,0x180,0x180,0x0,0x0,0x6800,0x6800,0x0,0x0,0x2800,0x2800,0x0,0x0,0x800,0x0,0x0,0x4000,0x0,0x0,0x80000,0x0,0x0,0x1f00000,0x0,0x0,0x1f00000,0x0,0x0,0x1d00000,0x0,0x0,0xd00000,0x1d00000,0x0,0x0,0xe00000,0xe00000,0x0,0x0,0x900000,0x900000,0x0,0x0,0xd00000,0xd00000,0x0,0x0,0x0,0x0,0x0,0x6000000,0x0,0x0,0x2000000,0x0,0x0,0x4000000,0x0,0x0,0x0,0x0,0x0,0x1,0x8000400,};
   }

  /** Constructor with InputStream. */
  public HxRaw(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public HxRaw(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new HxRawTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public HxRaw(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new HxRawTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public HxRaw(HxRawTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(HxRawTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 306; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[252];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 306; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
          if ((jj_la1_7[i] & (1<<j)) != 0) {
            la1tokens[224+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 252; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}
