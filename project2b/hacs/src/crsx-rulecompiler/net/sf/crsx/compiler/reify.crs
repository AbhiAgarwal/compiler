// Copyright © 2012 IBM Corporation.

// This file defines the sort of terms generated by the CRSX $Reify directive.
// The term represents a complete CRSX rewrite system with optional compilation annotations.

Reified[(

Reify_CRSX ::=(

	// Declaration*
	CRSX[ $String, $List[Reified_Declaration] ];

);

// DECLARATIONS

Reified_Declaration ::=(

	// ∀ x . Declaration
	POLYMORPHIC[ variable : Reified_Variable . Reified_Declaration ];

	// Sort ::= Form*
	DATA[ Reified_Sort, $List[Reified_Form] ];

	// Form :: Sort ;
	// Name1[ CompileType[Type], Option*1 ] : TermL1 → TermR1
	// ...
	// Namen[ CompileType[Type], Option*n ] : TermLn → TermRn
	// 
	FUNCTION[
		$String<!-- Qualified Name (prefix + function). Must be unique. Qualified names of the form Cons1.Cons2...Consn -->,
		$String<!-- CompileType. Either 'dispatch', 'contract', 'shuffle' or 'full' -->,
		$List[$Numeric]<!--discriminatorpath-->, // Unused.
		$String<!--Function-->,
		$List[Reified_Form],  // TODO: Should not be a list?
		Reified_Sort,          <!-- Function Sort -->
		$List[Reified_Rule]    <!-- List of rules -->
	];

);

Reified_Sort ::=(

	// sort property wrapper 
	SORT-PROPERTY[ Reified_Sort, Reified_Sort, Reified_Sort ];

	// type-variable
	SORT-VARIABLE[ Reified_Variable ];

	// Name[Sort*]
	SORT[ $String<!--Name-->, $List[Reified_Sort] ];

);

Reified_Form ::=(

	// variable
	SORT-ALLOWS-VARIABLES;

	// {Sort : Sort} Form
	SORT-SET[ Reified_Sort, Reified_Sort, Reified_Form ];

	// C[FormArgument*]
	FORM[ $String<!--Constructor-->, $List[Reified_FormArgument] ];

);

Reified_FormArgument ::=(

	// v:Sort . FormArgument
	FORM-BINDER[ Reified_Kind, Reified_Sort, v:Reified_Variable . Reified_FormArgument ];

	// Sort
	FORM-ARGUMENT[ Reified_Sort ];

);

// RULES (of functions)

Reified_Rule ::=(

	// Name[ Option* ] : Term → Term
	RULE[ $String<!--Name-->, $List[Reified_Option], Reified_Term<!--Pattern-->, Reified_Term<!--Contraction--> ];

);

Reified_Option ::=(

	// Name[Term] -- each option value is reported separately
	OPTION[ $String<!--Option-->, Reified_Term<!--Value--> ];

);


// TERMS

Reified_Term ::=(

	// {MetaVariable} Term
	PROPERTY-REF[ $String<!--Reference-->, Reified_Use, Reified_Term<!--Scope--> ];

	// {Term : Term} Term
	PROPERTY[ Reified_Term<!--Key-->, Reified_Term<!--Value-->, Reified_Term<!--Scope--> ];

	// {¬Term} Term
	PROPERTY-NOT[ Reified_Term<!--Key-->, Reified_Term<!--Scope--> ];

	// Constructor [ Binder* ]
	CONSTRUCTION[Reified_Kind, $String<!--Constructor-->, $List[Reified_Binder] ];

	// Literal (of Type)
	LITERAL[ $String<!--Value-->, Reified_Sort ];

	// variable
	VARIABLE-USE[ Reified_Variable ];

	// MetaVariable [ MetaArgument* ]
	META-APPLICATION[ $String<!--MetaVar-->, $List[Reified_Binder], Reified_Use ];

	// $[ Term, Term*, Options* ]
	EVALUATOR[ $String, $List[Reified_Term], $List[$List[Reified_Option]] ];

	// Special option (TO BE REMOVED)
	FreshReuseOrigin[Reified_Variable, $String, $Numeric];

);

Reified_Variable ::=( variable; );

Reified_Binder ::=(

	// b Binder (not as meta-application arguments)
	BINDER[ Reified_Promiscuity, Reified_Kind, Reified_Depth, Reified_Sort, $List[Reified_Occurrence], binder : Reified_Variable . Reified_Binder ];

	// . Term
	ARGUMENT[ Reified_Sort, Reified_Term ]; // note: Reified_Sort only instantiated in constructions

	// !variable (only as meta-application arguments)
	META-REQUIRED-VARIABLE[ Reified_Variable ];

);

Reified_Promiscuity ::=( LINEAR; PROMISCUOUS; );

Reified_Kind ::=( KDATA; KFUNCTION; ); // Whether binder/construction is data or function.

Reified_Depth ::=( SHALLOW; DEEP; ); // Whether binder occurrence is shallow or deep

Reified_Occurrence ::=( META-USE[$String<!--MetaVar-->, $Numeric<!--Count-->]; OTHER; );

Reified_Use ::=( NA;
   <!-- For Pattern Only -->
   DISCARD;
   <!-- For Contractum and Pattern --> 
   USE[$Numeric<!-- counter -->]; ); 

)]
