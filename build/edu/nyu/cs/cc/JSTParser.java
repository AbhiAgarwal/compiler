/* JSTParser.java */
/* Generated By:JavaCC: Do not edit this line. JSTParser.java */
package edu.nyu.cs.cc;

/** PG Grammar for HACS module edu.nyu.cs.cc.JST.
 * @version $Id: CookPG.crs,v 1.48 2014/01/26 21:14:39 krisrose Exp $
 */
public class JSTParser implements net.sf.crsx.Parser, JSTParserConstants {
        /** Factory. */
        net.sf.crsx.Factory<? extends net.sf.crsx.Term> factory;
        /** Compilation unit name for error messages. */
        String unit;
        /** Whether the parser should capture token locations. */
        boolean captureLocations = true;
        /** Constructor with token location information. */
        private net.sf.crsx.Constructor makeTConstructor(net.sf.crsx.Sink sink, Token t, Object object, String sort)
        {
                net.sf.crsx.Constructor c = sort == null ? sink.makeConstructor(object) : sink.makeLiteral(object, sort);
                if (t == null) t = token;
                if (captureLocations && t != null)
                {
                        if (factory.get("meta") == null)
                                c = net.sf.crsx.util.Util.wrapWithLocation(sink, c, unit, t.beginLine, t.beginColumn);
                }
                return c;
        }

        /** Helper interface with category non-terminal calls. */
        abstract class CategoryCall { abstract net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException; }
        /** Direct category invocations. */
        java.util.Map<String,CategoryCall> categoryCall = new java.util.HashMap<String,CategoryCall>();
        {
                categoryCall.put("jst", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Identifier$WithEOF(sink, bound);} });
                categoryCall.put("jstIdentifier", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Identifier$WithEOF(sink, bound);} });
                categoryCall.put("jstDecimal", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Decimal$WithEOF(sink, bound);} });
                categoryCall.put("jstString", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_String$WithEOF(sink, bound);} });
                categoryCall.put("jstType", new CategoryCall(){ net.sf.crsx.Sink call(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws ParseException {return N_Type$WithEOF(sink, bound);} });
        }

        // Constructor.

        /** Construct dummy instance. */
        public JSTParser()
        {
                this((java.io.Reader) null);
                disable_tracing();
        }

        // Parser implementation.

        public net.sf.crsx.Parser parser(net.sf.crsx.Factory<? extends net.sf.crsx.Term> f)
        {
                if (factory != null)
                {
                        net.sf.crsx.Parser parser = new JSTParser().parser(f);
                        parser.setParserVerbose(trace_enabled); parser.setParserLocation(captureLocations);
                        return parser;
                }
                else
                {
                        factory = f;
                        assert f != null : "Or Else!";
                        return this;
                }
        }

        public void setParserVerbose(boolean verbose)
        {
                if (verbose)
                        enable_tracing();
                else
                        disable_tracing();
        }

        public void setParserLocation(boolean capture)
        {
                captureLocations = capture;
        }

        public void setEmbeddedParser(net.sf.crsx.Parser subparser) throws net.sf.crsx.CRSException
        {}

        public Iterable<String> categories()
        {
                return categoryCall.keySet();
        }

        public net.sf.crsx.Sink parse(net.sf.crsx.Sink sink, String category, java.io.Reader reader, String unit, int firstLine, int firstColumn, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                try
                {
                        this.unit = unit;
                        ReInit((java.io.Reader) null);
                        jj_input_stream.ReInit(reader, firstLine, firstColumn); token_source = new JSTParserTokenManager(jj_input_stream); // hacks to update line and column numbers
                        if (bound == null) bound = new net.sf.crsx.util.LinkedExtensibleMap<String, net.sf.crsx.Variable>();
                        if (category == null || category.length() == 0) return N_Identifier(sink, bound);
                        else if (categoryCall.containsKey(category)) return categoryCall.get(category).call(sink, bound);
                        else throw new net.sf.crsx.CRSException("Parser category '"+category+"' not supported!");
                }
                catch (ParseException e)
                {
                        throw new net.sf.crsx.CRSException(e.getMessage());
                }
        }

        public net.sf.crsx.Term parseTerm(net.sf.crsx.Maker maker, String category, java.io.Reader reader, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> bound) throws net.sf.crsx.CRSException, java.io.IOException
        {
                net.sf.crsx.util.Buffer buffer = new net.sf.crsx.util.Buffer(maker);
                parse(buffer.sink(), category, reader, null, 1, 1, bound);
                return buffer.term(true);
        }


static String unmeta(String s, int i) {String inner = s.substring(1, s.length()-1).trim(); return (inner.length() > i ? inner.substring(i) : inner).trim();}

        /**
	 * Run the parser and print the resulting term.
	 * @param args should contain two strings: the category and an input file name
	 */
        public static void main(String[] args)
        {
                try
                {
                        if (args.length != 2)
                        {
                                System.err.println("Usage: JSTParser category input");
                                System.exit(2);
                        }
                        String category = args[0];
                        java.io.Reader reader = new java.io.FileReader(args[1]);
                        net.sf.crsx.Factory<net.sf.crsx.generic.GenericTerm> factory = new net.sf.crsx.generic.GenericFactory();
                        net.sf.crsx.Parser parser = new JSTParser();
                        net.sf.crsx.Sink sink = factory.sink(System.out);
                        parser.parser(factory).parse(sink, category, reader, null, 1, 1, null);
                }
                catch (net.sf.crsx.CRSException e)
                {
                        System.err.println("CRS error: "+e);
                        System.exit(1);
                }
                catch (java.io.IOException e)
                {
                        System.err.println("I/O error: "+e);
                        System.exit(1);
                }
        }

/* GRAMMAR. */

/* Productions for Identifier token. */

/** <em>Identifier$WithEOF</em> ::= <em>Identifier</em> EOF . */
  final public net.sf.crsx.Sink N_Identifier$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Identifier$WithEOF");
    try {
      sink = N_Identifier(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Identifier$WithEOF");
    }
  }

/**
 * <em>Identifier</em> ::=   <a href="#T_meta1_T_M_IDENTIFIER">meta1_T_M_IDENTIFIER</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_IDENTIFIER">meta2_T_M_IDENTIFIER</a><font color="red">$$:%{unmeta(#,10)%}</font>  <br>
 *  |   <a href="#T_T_M_IDENTIFIER">T_M_IDENTIFIER</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_Identifier(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Identifier");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case T_meta1_T_M_IDENTIFIER:{
        t = jj_consume_token(T_meta1_T_M_IDENTIFIER);
try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      case T_meta2_T_M_IDENTIFIER:{
        t = jj_consume_token(T_meta2_T_M_IDENTIFIER);
try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),10)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      case T_T_M_IDENTIFIER:{
        t = jj_consume_token(T_T_M_IDENTIFIER);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Identifier");
    }
  }

/* Productions for Decimal token. */

/** <em>Decimal$WithEOF</em> ::= <em>Decimal</em> EOF . */
  final public net.sf.crsx.Sink N_Decimal$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Decimal$WithEOF");
    try {
      sink = N_Decimal(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Decimal$WithEOF");
    }
  }

/**
 * <em>Decimal</em> ::=   <a href="#T_meta1_T_M_DECIMAL">meta1_T_M_DECIMAL</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_DECIMAL">meta2_T_M_DECIMAL</a><font color="red">$$:%{unmeta(#,7)%}</font>  <br>
 *  |   <a href="#T_T_M_DECIMAL">T_M_DECIMAL</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_Decimal(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Decimal");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case T_meta1_T_M_DECIMAL:{
        t = jj_consume_token(T_meta1_T_M_DECIMAL);
try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      case T_meta2_T_M_DECIMAL:{
        t = jj_consume_token(T_meta2_T_M_DECIMAL);
try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),7)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      case T_T_M_DECIMAL:{
        t = jj_consume_token(T_T_M_DECIMAL);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Decimal");
    }
  }

/* Productions for String token. */

/** <em>String$WithEOF</em> ::= <em>String</em> EOF . */
  final public net.sf.crsx.Sink N_String$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_String$WithEOF");
    try {
      sink = N_String(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_String$WithEOF");
    }
  }

/**
 * <em>String</em> ::=   <a href="#T_meta1_T_M_STRING">meta1_T_M_STRING</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_STRING">meta2_T_M_STRING</a><font color="red">$$:%{unmeta(#,6)%}</font>  <br>
 *  |   <a href="#T_T_M_STRING">T_M_STRING</a><font color="red">$</font> 
 */
  final public net.sf.crsx.Sink N_String(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_String");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case T_meta1_T_M_STRING:{
        t = jj_consume_token(T_meta1_T_M_STRING);
try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      case T_meta2_T_M_STRING:{
        t = jj_consume_token(T_meta2_T_M_STRING);
try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),6)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      case T_T_M_STRING:{
        t = jj_consume_token(T_T_M_STRING);
sink = sink .start(makeTConstructor(sink, t, t.toString(), net.sf.crsx.CRS.STRING_SORT)) ;
{if ("" != null) return sink .end() ;}
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_String");
    }
  }

/* Productions for Type sort with (highest) precedence 0. */

/** <em>Type$WithEOF</em> ::= <em>Type</em> EOF . */
  final public net.sf.crsx.Sink N_Type$WithEOF(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Type$WithEOF");
    try {
      sink = N_Type(sink, env);
      jj_consume_token(0);
{if ("" != null) return sink;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Type$WithEOF");
    }
  }

/**
 * <em>Type</em> ::=   <a href="#T_meta1_T_M_TYPE">meta1_T_M_TYPE</a><font color="red">$$:%{unmeta(#,0)%}</font>  <br>
 *  |   <a href="#T_meta2_T_M_TYPE">meta2_T_M_TYPE</a><font color="red">$$:%{unmeta(#,4)%}</font>  <br>
 *  |  (   "<code>Identifier</code>"   <font color="red">{{Type__M_Identifier}}</font>  |  (   "<code>boolean</code>"   <font color="red">{{Type__M_boolean}}</font>  |  (   "<code>int</code>"   <font color="red">{{Type__M_int}}</font>  |  (   "<code>string</code>"   <font color="red">{{Type__M_string}}</font>  |   "<code>void</code>"   <font color="red">{{Type__M_void}}</font>  )  )  )  ) 
 */
  final public net.sf.crsx.Sink N_Type(net.sf.crsx.Sink sink, net.sf.crsx.util.ExtensibleMap<String, net.sf.crsx.Variable> env) throws ParseException {
    trace_call("N_Type");
    try {Token t = null;
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case T_meta1_T_M_TYPE:{
        t = jj_consume_token(T_meta1_T_M_TYPE);
try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),0)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      case T_meta2_T_M_TYPE:{
        t = jj_consume_token(T_meta2_T_M_TYPE);
try {sink = factory.parser(factory).parse(sink, null, new java.io.StringReader(unmeta(t.toString(),4)), unit, t.beginLine, t.beginColumn+1, env);}
                catch (java.io.IOException e) {{if (true) throw new ParseException(e.getMessage());}}
                catch (net.sf.crsx.CRSException e) {Throwable cause = e.getCause(); if (cause instanceof ParseException) {if (true) throw (ParseException) cause;} else {if (true) throw new ParseException(e.getMessage());}}
{if ("" != null) return sink;}
        break;
        }
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:{
        switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
        case 19:{
          jj_consume_token(19);
sink = sink .start(sink.makeConstructor("Type__M_Identifier")) .end() ;
          break;
          }
        case 20:
        case 21:
        case 22:
        case 23:{
          switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
          case 20:{
            jj_consume_token(20);
sink = sink .start(sink.makeConstructor("Type__M_boolean")) .end() ;
            break;
            }
          case 21:
          case 22:
          case 23:{
            switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
            case 21:{
              jj_consume_token(21);
sink = sink .start(sink.makeConstructor("Type__M_int")) .end() ;
              break;
              }
            case 22:
            case 23:{
              switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
              case 22:{
                jj_consume_token(22);
sink = sink .start(sink.makeConstructor("Type__M_string")) .end() ;
                break;
                }
              case 23:{
                jj_consume_token(23);
sink = sink .start(sink.makeConstructor("Type__M_void")) .end() ;
                break;
                }
              default:
                jj_la1[3] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
              }
              break;
              }
            default:
              jj_la1[4] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
            }
          default:
            jj_la1[5] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
          }
        default:
          jj_la1[6] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
{if ("" != null) return sink;}
        break;
        }
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("N_Type");
    }
  }

  /** Generated Token Manager. */
  public JSTParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[8];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x22,0x880,0x22000,0xc00000,0xe00000,0xf00000,0xf80000,0x11f80000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x2,0x4,0x8,0x0,0x0,0x0,0x0,0x0,};
   }

  /** Constructor with InputStream. */
  public JSTParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public JSTParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new JSTParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public JSTParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new JSTParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public JSTParser(JSTParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(JSTParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 8; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[37];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 8; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 37; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}
